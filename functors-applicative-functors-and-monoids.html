<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
        <style>
            @import url(css/style.css);
        </style>
        <script src="js/jquery.js"></script>
        <script src="js/jquery.chili-2.2.js"></script>
        <script src="js/script.js"></script>
        <script>
             ChiliBook.recipeFolder = "js/chili/";  
             ChiliBook.automaticSelector = "pre";
        </script>
        <title>Functors, Applicative Functors與Monoids</title>
    </head>
    <body>
        <div id="header">
            <img id="beta" alt="beta" src="img/beta.png" />
        </div>

        <div id="main">
            <ul class="nav">
                <li class="left">  <img src="img/prv.png"></img><a href="functionally-solving-problems.html">函數式地思考來解決問題</a></li>
                <li class="center"><a href="chapters.html">Index</a></li>
                <li class="right"> <a href="a-fistful-of-monads.html">來看看幾種Moand</a><img src="img/nxt.png"></img></li>
            </ul>
            <a name="Functors, Applicative Functors與Monoids"></a><h1>Functors, Applicative Functors與Monoids</h1><p>Haskell的一些特色，像是純粹性，高階函數，algebraic data types，typeclasses，</p><p>這些讓我們可以從更高的角度來看到polymorphism這件事。</p><p>不像OOP當中需要從龐大的型態階層來思考。</p><p>我們只需要看看手邊的型態的行為，將他們跟適當地typeclass對應起來就可以了。</p><p>像<code>Int</code>的行為跟很多東西很像。</p><p>好比說他可以比較相不相等，可以從大到小排列，也可以將他們一一窮舉出來。</p><p>Typeclass的運用是很隨意的。</p><p>我們可以定義自己的資料型態，然後描述他可以怎樣被操作，跟typeclass關聯起來便定義了他的行為。</p><p>由於Haskell強大的型態系統，</p><p>這讓我們只要讀函數的型態宣告就可以知道很多資訊。</p><p>typeclass可以定義得很抽象很general。</p><p>我們之前有看過typeclass定義了可以比較兩個東西是否相等，或是定義了可以比較兩個東西的大小。</p><p>這些是既抽象但又描述簡潔的行為，</p><p>但我們不會認為他們有什麼特別之處，因為我們時常碰到他們。</p><p>最近我們看過了functor，基本上他們是一群可以被map over的物件。</p><p>這是其中一個例子能夠抽象但又漂亮地描述行為。</p><p>在這一章中，</p><p>我們會詳加闡述functors，</p><p>並會提到比較強一些的版本，也就是applicative functors。</p><p>我們也會提到monoids。</p><a name="溫習Functors"></a><h2>溫習Functors</h2><p>我們已經在之前的章節提到functors。</p><p>如果你還沒讀那個章節，</p><p>也許你應該先去看看。</p><p>或是你直接假裝你已經讀過了。</p><p>來快速複習一下：</p><p>Functors是可以被map over的物件，</p><p>像是lists，<code>Maybe</code>，trees等等。</p><p>在Haskell中我們是用<code>Functor</code>這個typeclass來描述他。</p><p>這個typeclass只有一個method，叫做<code>fmap</code>，</p><p>他的型態是<code>fmap :: (a -> b) ->  fa -> f b</code>。</p><p>這型態說明了如果給我一個從<code>a</code>映到<code>b</code>的函數，以及一個裝了<code>a</code>的盒子，</p><p>我會回給你一個裝了<code>b</code>的盒子。</p><p>就好像用這個函數將每個元素都轉成<code>b</code>一樣</p><blockquote><p><b>給一點建議</b>。這盒子的比喻嘗試讓你抓到些functors是如何運作的感覺。在之後我們也會用相同的比喻來比喻applicative functors跟monads。在多數情況下這種比喻是恰當的，但不要過度引申，有些functors是不適用這個比喻的。一個比較正確的形容是functors是一個計算語境(computational context)。這個語境可能是這個computation可能帶有值，或是有可能會失敗(像<code>Maybe</code>跟<code>Either a</code>)，或是他可能有多個值(像lists)，等等。</p></blockquote><p>如果一個type constructor要是<code>Functor</code>的instance，那他的kind必須是<code>* -> *</code>，</p><p>這代表他必須剛好接受一個type當作type parameter。</p><p>像是<code>Maybe</code>可以是Functor的一個instance，</p><p>因為他接受一個type parameter，來做成像是<code>Maybe Int</code>，或是<code>Maybe String</code>。</p><p>如果一個type constructor接受兩個參數，</p><p>像是<code>Either</code>，我們必須給他兩個type parameter。</p><p>所以我們不能這樣寫：<code>instance Functor Either where</code>，</p><p>但我們可以寫<code>instance Functor (Either a) where</code>，</p><p>如果我們把<code>fmap</code>限縮成只是<code>Either a</code>的，</p><p>那他的型態就是<code>fmap :: (b -> c) -> Either a b -> Either a c</code>。</p><p>就像你看到的，<code>Either a</code>的是固定的一部分，</p><p>因為<code>Either a</code>只恰好接受一個type parameter，</p><p>但<code>Either</code>則要接球兩個type parameters。</p><p>這樣fmap的型態變成<code>fmap :: (b -> c) -> Either b -> Either c</code>，這不太合理。</p><p>我們知道有許多型態都是<code>Functor</code>的instance，</p><p>像是<code>[]</code>，<code>Maybe</code>，<code>Either a</code>以及我們自己寫的<code>Tree</code>。</p><p>我們也看到了如何用一個函數map他們。</p><p>在這一章節，我們再多舉兩個例子，也就是<code>IO</code>跟<code>(->) r</code>。</p><p>如果一個值的型態是<code>IO String</code>，</p><p>他代表的是一個會被計算成String結果的I/O action。</p><p>我們可以用do syntax來把結果綁定到某個名稱。</p><p>我們之前把I/O action比喻做長了腳的盒子，會到真實世界幫我們取一些值回來。</p><p>我們可以檢視他們取了什麼值，</p><p>但一旦看過，我們必須要把值放回盒子中。</p><p>用這個比喻，<code>IO</code>的行為就像是一個functor。</p><p>我們來看看<code>IO</code>是怎麼樣的一個<code>Functor</code>instance。</p><p>當我們<code>fmap</code>用一個function來map over I/O action時，</p><p>我們會想要拿回一個裝著已經用function映射過值的I/O action。</p><pre class="code">instance Functor IO where
    fmap f action = do
        result <- action
        return (f result)</pre><a name="Applicative functors"></a><h2>Applicative functors</h2><a name="關鍵字"newtype""></a><h2>關鍵字"newtype"</h2><a name="Monoids"></a><h2>Monoids</h2>
            <ul class="nav">
                <li class="left">  <img src="img/prv.png"></img><a href="functionally-solving-problems.html">函數式地思考來解決問題</a></li>
                <li class="center"><a href="chapters.html">Index</a></li>
                <li class="right"> <a href="a-fistful-of-monads.html">來看看幾種Moand</a><img src="img/nxt.png"></img></li>
            </ul>
        </div>
        <div id="footer">
        </div>
    </body>
</html>
