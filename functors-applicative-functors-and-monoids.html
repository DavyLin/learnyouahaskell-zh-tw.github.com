<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
        <style>
            @import url(css/style.css);
            @import url(css/feedback.css);
        </style>
        <script src="js/jquery.js"></script>
        <script src="js/jquery.chili-2.2.js"></script>
        <script src="js/script.js"></script>
        <script src="js/html2canvas.js"></script>
        <script src="js/jsfeedback.js"></script>
        <script>
             ChiliBook.recipeFolder = "js/chili/";  
             ChiliBook.automaticSelector = "pre";
        </script>
        <script>
            $(function(){
                $('#feedback').click(function(){
                    $('body').feedback();
                })
            });
        </script>
        <script type="text/javascript">
            var _gaq = _gaq || [];
            _gaq.push(['_setAccount', 'UA-32830659-1']);
            _gaq.push(['_trackPageview']);

            (function() {
                var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
                ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
                    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
            })();
        </script>
        <title>Functors, Applicative Functors與Monoids</title>
    </head>
    <body>
        <div id="header">
            <img id="beta" alt="beta" src="img/beta.png" />
        </div>

        <div id="main">
            <ul class="nav">
                <li class="left">  <img src="img/prv.png"></img><a href="functionally-solving-problems.html">函數式地思考來解決問題</a></li>
                <li class="center"><a href="chapters.html">Index</a></li>
                <li class="right"> <a href="a-fistful-of-monads.html">來看看幾種Monad</a><img src="img/nxt.png"></img></li>
            </ul>
            <a name="Functors, Applicative Functors與Monoids"></a><h1>Functors, Applicative Functors與Monoids</h1><p>Haskell的一些特色，像是純粹性，高階函數，algebraic data types，typeclasses，這些讓我們可以從更高的角度來看到polymorphism這件事。不像OOP當中需要從龐大的型態階層來思考。我們只需要看看手邊的型態的行為，將他們跟適當地typeclass對應起來就可以了。像<code>Int</code>的行為跟很多東西很像。好比說他可以比較相不相等，可以從大到小排列，也可以將他們一一窮舉出來。</p><p>Typeclass的運用是很隨意的。我們可以定義自己的資料型態，然後描述他可以怎樣被操作，跟typeclass關聯起來便定義了他的行為。由於Haskell強大的型態系統，這讓我們只要讀函數的型態宣告就可以知道很多資訊。typeclass可以定義得很抽象很general。我們之前有看過typeclass定義了可以比較兩個東西是否相等，或是定義了可以比較兩個東西的大小。這些是既抽象但又描述簡潔的行為，但我們不會認為他們有什麼特別之處，因為我們時常碰到他們。最近我們看過了functor，基本上他們是一群可以被map over的物件。這是其中一個例子能夠抽象但又漂亮地描述行為。在這一章中，我們會詳加闡述functors，並會提到比較強一些的版本，也就是applicative functors。我們也會提到monoids。</p><a name="溫習Functors"></a><h2>溫習Functors</h2><img src="img/frogtor.png" style="float:right"></img><p>我們已經在之前的章節提到functors。如果你還沒讀那個章節，也許你應該先去看看。或是你直接假裝你已經讀過了。</p><p>來快速複習一下：Functors是可以被map over的物件，像是lists，<code>Maybe</code>，trees等等。在Haskell中我們是用<code>Functor</code>這個typeclass來描述他。這個typeclass只有一個method，叫做<code>fmap</code>，他的型態是<code>fmap :: (a -> b) ->  fa -> f b</code>。這型態說明了如果給我一個從<code>a</code>映到<code>b</code>的函數，以及一個裝了<code>a</code>的盒子，我會回給你一個裝了<code>b</code>的盒子。就好像用這個函數將每個元素都轉成<code>b</code>一樣</p><blockquote><p><b>給一點建議</b>。這盒子的比喻嘗試讓你抓到些functors是如何運作的感覺。在之後我們也會用相同的比喻來比喻applicative functors跟monads。在多數情況下這種比喻是恰當的，但不要過度引申，有些functors是不適用這個比喻的。一個比較正確的形容是functors是一個計算語境(computational context)。這個語境可能是這個computation可能帶有值，或是有可能會失敗(像<code>Maybe</code>跟<code>Either a</code>)，或是他可能有多個值(像lists)，等等。</p></blockquote><p>如果一個type constructor要是<code>Functor</code>的instance，那他的kind必須是<code>* -> *</code>，這代表他必須剛好接受一個type當作type parameter。像是<code>Maybe</code>可以是Functor的一個instance，因為他接受一個type parameter，來做成像是<code>Maybe Int</code>，或是<code>Maybe String</code>。如果一個type constructor接受兩個參數，像是<code>Either</code>，我們必須給他兩個type parameter。所以我們不能這樣寫：<code>instance Functor Either where</code>，但我們可以寫<code>instance Functor (Either a) where</code>，如果我們把<code>fmap</code>限縮成只是<code>Either a</code>的，那他的型態就是<code>fmap :: (b -> c) -> Either a b -> Either a c</code>。就像你看到的，<code>Either a</code>的是固定的一部分，因為<code>Either a</code>只恰好接受一個type parameter，但<code>Either</code>則要接球兩個type parameters。這樣fmap的型態變成<code>fmap :: (b -> c) -> Either b -> Either c</code>，這不太合理。</p><p>我們知道有許多型態都是<code>Functor</code>的instance，像是<code>[]</code>，<code>Maybe</code>，<code>Either a</code>以及我們自己寫的<code>Tree</code>。我們也看到了如何用一個函數map他們。在這一章節，我們再多舉兩個例子，也就是<code>IO</code>跟<code>(->) r</code>。</p><p>如果一個值的型態是<code>IO String</code>，他代表的是一個會被計算成String結果的I/O action。我們可以用do syntax來把結果綁定到某個名稱。我們之前把I/O action比喻做長了腳的盒子，會到真實世界幫我們取一些值回來。我們可以檢視他們取了什麼值，但一旦看過，我們必須要把值放回盒子中。用這個比喻，<code>IO</code>的行為就像是一個functor。</p><p>我們來看看<code>IO</code>是怎麼樣的一個<code>Functor</code>instance。當我們<code>fmap</code>用一個function來map over I/O action時，我們會想要拿回一個裝著已經用function映射過值的I/O action。</p><pre class="code">instance Functor IO where
    fmap f action = do
        result <- action
        return (f result)</pre><p>對一個I/O action做map over動作的結果仍會是一個I/O action，所以我們才用do syntax來把兩個I/O action黏成一個。在<code>fmap</code>的實做中，我們先執行了原本傳進的I/O action，並把結果綁定成<code>result</code>。然後我們寫了<code>return (f result)</code>。<code>return</code>就如你所知道的，是一個只會回傳包了你傳給他東西的I/O action。還有一個do block的回傳值一定是他最後一個I/O action的回傳值。這也是為什麼我們需要return。其實他只是回傳包了<code>f result</code>的I/O action。</p><p>我們可以再多實驗一下來找到些感覺。來看看這段code：</p><pre class="code">main = do line <- getLine   
        let line' = reverse line  
        putStrLn $ "You said " ++ line' ++ " backwards!"  
        putStrLn $ "Yes, you really said" ++ line' ++ " backwards!"</pre><p>這程式要求使用者輸入一行文字，然後印出一行反過來的。</p><p>我們可以用<code>fmap</code>來改寫：</p><pre class="code">main = do line <- fmap reverse getLine  
            putStrLn $ "You said " ++ line ++ " backwards!"  
            putStrLn $ "Yes, you really said" ++ line ++ " backwards!"</pre><img src="img/alien.png" style="float:left"></img><p>就像我們用<code>fmap</code><code>reverse</code>來map over<code>Just "blah"</code>會得到<code>Just "halb"</code>，我們也可以<code>fmap</code><code>reverse</code>來map over<code>getLine</code>。<code>getLine</code>是一個I/O action，他的type是<code>IO String</code>，而用<code>reverse</code>來map over他會回傳一個取回一個字串並<code>reverse</code>他的I/O action。就像我們apply一個function到一個<code>Maybe</code>一樣，我們也可以apply一個function到一個<code>IO</code>，只是這個<code>IO</code>會跑去外面拿回某些值。然後我們把結果用<code><-</code>綁定到某個名稱，而這個名稱綁定的值是已經<code>reverse</code>過了。</p><p>而<code>fmap (++"!") getLine</code>這個I/O action表現得就像<code>getLine</code>，只是他的結果多了一個<code>"!"</code>在最後。</p><p>如果我們限縮<code>fmap</code>到<code>IO</code>型態上，那fmap的型態是<code>fmap :: (a -> b) -> IO a -> IO b</code>。<code>fmap</code>接受一個函數跟一個I/O action，並回傳一個I/O action包含了已經apply過function的結果。</p><p>如果你曾經注意到你想要將一個I/O action綁定到一個名稱上，只是為了要apply一個function。你可以考慮使用<code>fmap</code>，那會更漂亮地表達這件事。或者你想要對functor中的資料做transformation，你可以先將你要用的function寫在top level，或是把他作成一個lambda function，甚至用function composition。</p><pre class="code">import Data.Char  
import Data.List  
  
main = do line <- fmap (intersperse '-' . reverse . map toUpper) getLine  
        putStrLn line</pre><pre class="code">$ runhaskell fmapping_io.hs  
hello there  
E-R-E-H-T- -O-L-L-E-H</pre><p>正如你想的，<code>intersperse '-' . reverse . map toUpper</code>合成了一個function，他接受一個字串，將他轉成大寫，然後反過來，再用<code>intersperse '-'</code>安插'-'。他是比較漂亮版本的<code>(\xs -> intersperse '-' (reverse (map toUpper xs)))</code>。</p><p>另一個<code>Functor</code>的案例是<code>(->) r</code>，只是我們先前沒有注意到。你可能會困惑到底<code>(->) r</code>究竟代表什麼？一個<code>r -> a</code>的型態可以寫成<code>(->) r a</code>，就像是<code>2 + 3</code>可以寫成<code>(+) 2 3</code>一樣。我們可以從一個不同的角度來看待<code>(->) r a</code>，他其實只是一個接受兩個參數的type constructor，好比<code>Either</code>。但記住我們說過<code>Functor</code>只能接受一個type constructor。這也是為什麼<code>(->)</code>不是<code>Functor</code>的一個instance，但<code>(->) r</code>則是。如果程式的語法允許的話，你也可以將<code>(->) r</code>寫成(r ->)。就如<code>(2+)</code>代表的其實是<code>(+) 2</code>。至於細節是如何呢？我們可以看看<code>Control.Monad.Instances</code>。</p><blockquote><p>我們通常說一個接受任何東西以及回傳隨便一個東西的函數型態是<code>a -> b</code>。<code>r -> a</code>是同樣意思，只是把符號代換了一下。</p></blockquote><pre class="code">instance Functor ((->) r) where  
    fmap f g = (\x -> f (g x))</pre><p>如果語法允許的話，他可以被寫成</p><pre class="code">instance Functor (r ->) where  
    fmap f g = (\x -> f (g x))</pre><p>但其實是不允許的，所以我們必須寫成第一種的樣子。</p><p>首先我們來看看<code>fmap</code>的型態。他的型態是<code>fmap :: (a -> b) -> f a -> f b</code>。我們把所有的<code>f</code>在心裡代換成<code>(->) r</code>。則<code>fmap</code>的型態就變成<code>fmap :: (a -> b) -> ((->) r a) -> ((->) r b)</code>。接著我們把<code>(->) r a</code>跟<code>(->) r b</code>換成<code>r -> a</code>跟<code>r -> b</code>。則我們得到<code>fmap :: (a -> b) -> (r -> a) -> (r -> b)</code>。</p><p>從上面的結果看到將一個function map over一個function會得到另一個function，就如map over一個function到<code>Maybe</code>會得到一個<code>Maybe</code>，而map over一個function到一個list會得到一個list。而<code>fmap :: (a -> b) -> (r -> a) -> (r -> b)</code>告訴我們什麼？他接受一個從<code>a</code>到<code>b</code>的function，跟一個從<code>r</code>到<code>a</code>的function，並回傳一個從<code>r</code>到<code>b</code>的function。這根本就是function composition。把<code>r -> a</code>的輸出接到<code>a -> b</code>的輸入，的確是function composition在做的事。如果你再仔細看看instance的定義，會發現真的就是一個function composition。</p><pre class="code">instance Functor ((->) r) where  
    fmap = (.)</pre><p>這很明顯就是把<code>fmap</code>當composition在用。可以用<code>:m + Control.Monad.Instances</code>把模組裝載進來，並做一些嘗試。</p><pre class="code">ghci> :t fmap (*3) (+100)  
fmap (*3) (+100) :: (Num a) => a -> a  
ghci> fmap (*3) (+100) 1  
303  
ghci> (*3) `fmap` (+100) $ 1  
303  
ghci> (*3) . (+100) $ 1  
303  
ghci> fmap (show . (*3)) (*100) 1  
"300"</pre><p>我們呼叫<code>fmap</code>的方式是infix的方式，這跟<code>.</code>很像。在第二行，我們把<code>(*3)</code>map over到<code>(+100)</code>上，這會回傳一個先把輸入值<code>(+100)</code>再<code>(*3)</code>的function，我們再用<code>1</code>去呼叫他。</p><p>到這邊為止盒子的比喻還適用嗎？如果你硬是要解釋的話還是解釋得通。當我們將<code>fmap (+3)</code>map over<code>Just 3</code>的時候，對於<code>Maybe</code>我們很容易把他想成是裝了值的盒子，我們只是對盒子裡面的值<code>(+3)</code>。但對於<code>fmap (*3) (+100)</code>呢？你可以把<code>(+100)</code>想成是一個裝了值的盒子。有點像把I/O action想成長了腳的盒子一樣。對<code>(+100)</code>使用<code>fmap (*3)</code>會產生另一個表現得像<code>(+100)</code>的function。只是在算出值之前，會再多計算<code>(*3)</code>。這樣我們可以看出來<code>fmap</code>表現得就像<code>.</code>一樣。</p><p><code>fmap</code>等同於function composition這件事對我們來說並不是很實用，但至少是一個有趣的觀點。這也讓我們打開視野，看到盒子的比喻不是那麼恰當，functors其實比較像computation。function被map over到一個computation會產生經由那個function映射過後的computation。</p><img src="img/lifter.png" style="float:right"></img><p>在我們繼續看<code>fmap</code>該遵守的規則之前，我們再看一次<code>fmap</code>的型態，他是<code>fmap :: (a -> b) -> f a -> f b</code>。很明顯我們是在討論Functor，所以為了簡潔，我們就不寫<code>(Functor f) =></code>的部份。當我們在學curry的時候，我們說過Haskell的function實際上只接受一個參數。一個型態是<code>a -> b -> c</code>的函數實際上是接受<code>a</code>然後回傳<code>b -> c</code>，而<code>b -> c</code>實際上接受一個<code>b</code>然後回傳一個<code>c</code>。如果我們用比較少的參數呼叫一個函數，他就會回傳一個函數需要接受剩下的參數。所以<code>a -> b -> c</code>可以寫成<code>a -> (b -> c)</code>。這樣curry可以明顯一些。</p><p>同樣的，我們可以不要把<code>fmap</code>想成是一個接受function跟functor並回傳一個function的function。而是想成一個接受function並回傳一個新的function的function，回傳的function接受一個functor並回傳一個functor。他接受<code>a -> b</code>並回傳<code>f a -> f b</code>。這動作叫做lifting。我們用GHCI的<code>:t</code>來做的實驗。</p><pre class="code">ghci> :t fmap (*2)  
fmap (*2) :: (Num a, Functor f) => f a -> f a  
ghci> :t fmap (replicate 3)  
fmap (replicate 3) :: (Functor f) => f a -> f [a]</pre><p><code>fmap (*2)</code>接受一個functor<code>f</code>，並回傳一個基於數字的functor。那個functor可以是list，可以是<code>Maybe</code>，可以是<code>Either String</code>。<code>fmap (replicate 3)</code>可以接受一個基於任何型態的functor，並回傳一個基於list的functor。</p><blockquote><p>當我們提到functor over numbers的時候，你可以想像他是一個functor包含有許多數字在裡面。前面一種說法其實比較正確，但後面一種說法比較容易讓人理解。</p></blockquote><p>這樣的觀察在我們只有綁定一個部份套用的函數，像是<code>fmap (++"!")</code>，的時候會顯得更清楚，</p><p>你可以把<code>fmap</code>想做是一個函數，他接受另一個函數跟一個functor，然後把函數對functor每一個元素做映射，或你可以想做他是一個函數，他接受一個函數並把他lift到可以在functors上面操作。兩種想法都是正確的，而且在Haskell中是等價。</p><p><code>fmap (replicate 3) :: (Functor f) => f a -> f [a]</code>這樣的型態代表這個函數可以運作在任何functor上。至於確切的行為則要看究竟我們操作的是什麼樣的functor。如果我們是用<code>fmap (replicate 3)</code>對一個list操作，那我們會選擇<code>fmap</code>針對list的實作，也就是只是一個<code>map</code>。如果我們是碰到<code>Maybe a</code>。那他在碰到<code>Just</code>型態的時候，會對裡面的值套用<code>replicate 3</code>。而碰到<code>Nothing</code>的時候就回傳<code>Nothing</code>。</p><pre class="code">ghci> fmap (replicate 3) [1,2,3,4]  
[[1,1,1],[2,2,2],[3,3,3],[4,4,4]]  
ghci> fmap (replicate 3) (Just 4)  
Just [4,4,4]  
ghci> fmap (replicate 3) (Right "blah")  
Right ["blah","blah","blah"]  
ghci> fmap (replicate 3) Nothing  
Nothing  
ghci> fmap (replicate 3) (Left "foo")  
Left "foo"</pre><p>接下來我們來看看functor laws。一個東西要成為functor，必須要遵守某些定律。不管任何一個functor都被要求具有某些性質。他們必須是能被map over的。對他們呼叫<code>fmap</code>應該是要用一個函數map每一個元素，不多做任何事情。這些行為都被functor laws所描述。對於<code>Functor</code>的instance來說，總共兩條定律應該被遵守。不過他們不會在Haskell中自動被檢查，所以你必須自己確認這些條件。</p><p>functor law的第一條說明，如果我們對functor做map<code>id</code>，那得到的新的functor應該要跟原來的一樣。如果寫得正式一點，他代表<code>fmap id = id</code>。基本上他就是說對functor呼叫<code>fmap id</code>，應該等同於對functor呼叫<code>id</code>一樣。畢竟<code>id</code>只是identity function，他只會把參數照原樣丟出。他也可以被寫成<code>\x -> x</code>。如果我們對functor的概念就是可以被map over的物件，那<code>fmap id = id</code>的性就顯而易見。</p><p>我們來看看這個定律的幾個案例：</p><pre class="code">ghci> fmap id (Just 3)  
Just 3  
ghci> id (Just 3)  
Just 3  
ghci> fmap id [1..5]  
[1,2,3,4,5]  
ghci> id [1..5]  
[1,2,3,4,5]  
ghci> fmap id []  
[]  
ghci> fmap id Nothing  
Nothing</pre><p>如果我們看看<code>Maybe</code>的<code>fmap</code>的實作，我們不難發現第一定律為何被遵守。</p><pre class="code">instance Functor Maybe where  
    fmap f (Just x) = Just (f x)  
    fmap f Nothing = Nothing</pre><p>我們可以想像在<code>f</code>的位置擺上<code>id</code>。我們看到<code>fmap id</code>拿到<code>Just x</code>的時候，結果只不過是<code>Just (id x)</code>，而<code>id</code>有只回傳他拿到的東西，所以可以知道<code>Just (id x)</code>等價於<code>Just x</code>。所以說我們可以知道對<code>Maybe</code>中的<code>Just</code>用<code>id</code>去做map over的動作，會拿回一樣的值。</p><p>而將<code>id</code>map over<code>Nothing</code>會拿回<code>Nothing</code>並不稀奇。所以從這兩個<code>fmap</code>的實作，我們可以看到的確<code>fmap id = id</code>有被遵守。</p><img src="img/justice.png" style="float:left"></img><p>第二定律描述說先將兩個函數合成並將結果map over一個functor的結果，應該跟先將第一個函數map over一個functor，再將第二個函數map over那個functor的結果是一樣的。正式地寫下來的話就是<code>fmap (f . g) = fmap f . fmap g</code>。或是用另外一種寫法，對於任何一個functor F，下面這個式子應該要被遵守：<code>fmap (f . g) F = fmap f (fmap g F)</code>v</p><p>如果我們能夠證明某個型別遵守兩個定律，那我們就可以保證他跟其他functor對於映射方面都擁有相同的性質。我們知道如果對他用<code>fmap</code>，我們知道不會有除了mapping以外的事會發生，而他就僅僅會表現成某個可以被map over的東西。也就是一個functor。你可以再仔細檢視<code>fmap</code>對於某些型別的實作來了解第二定律。正如我們先前對<code>Maybe</code>檢視第一定律一般。</p><p>如果你需要的話，我們能在這邊演練一下<code>Maybe</code>是如何遵守第二定律的。首先<code>fmap (f . g)</code>來map over<code>Nothing</code>的話，我們會得到<code>Nothing</code>。因為用任何函數來<code>fmap</code><code>Nothing</code>的話都會回傳<code>Nothing</code>。如果我們<code>fmap f (fmap g Nothing)</code>，我們會得到<code>Nothing</code>。可以看到當面對<code>Nothing</code>的時候，<code>Maybe</code>很顯然是遵守第二定律的。</p><p>那對於<code>Just something</code>呢？如果我們使用<code>fmap (f . g) (Just x)</code>的話，從實作的程式碼中我可以看到<code>Just ((f . g ) x)</code>，也就是<code>Just (f (g x))</code>。如果我們使用<code>fmap f (fmap g (Just x))</code>的話我們可以從實作知道<code>fmap g (Just x)</code>會是<code>Just (g x)</code>。<code>fmap f (fmap g (Just x))</code>跟<code>fmap f (Just (g x))</code>相等。而從實作上這又會相等於<code>Just (f (g x))</code>。</p><p>如果你不太理解這邊的說明，別擔心。只要確定你了解什麼是函數合成就好。在多數的情況下你可以直覺地對應到這些型別表現得就像containers或函數一樣。或是也可以換種方法，只要多嘗試對型別中不同的值做操作你就可以看看型別是否有遵守定律。</p><p>我們來看一些經典的例子。這些型別建構子雖然是<code>Functor</code>的instance，但實際上他們並不是functor，因為他們並不遵守這些定律。我們來看看其中一個型別。</p><pre class="code">data CMaybe a = CNothing | CJust Int a deriving (Show)</pre><p>C這邊代表的是計數器。他是一種看起來像是<code>Maybe a</code>的型別，只差在<code>Just</code>包含了兩個field而不是一個。在<code>CJust</code>中的第一個field是<code>Int</code>，他是扮演計數器用的。而第二個field則為型別<code>a</code>，他是從型別參數來的，而他確切的型別當然會依據我們選定的<code>CMaybe a</code>而定。我們來對他作些操作來獲得些操作上的直覺吧。</p><pre class="code">ghci> CNothing  
CNothing  
ghci> CJust 0 "haha"  
CJust 0 "haha"  
ghci> :t CNothing  
CNothing :: CMaybe a  
ghci> :t CJust 0 "haha"  
CJust 0 "haha" :: CMaybe [Char]  
ghci> CJust 100 [1,2,3]  
CJust 100 [1,2,3]</pre><p>如果我們使用<code>CNothing</code>，就代表不含有field。如果我們用的是<code>CJust</code>，那第一個field是整數，而第二個field可以為任何型別。我們來定義一個<code>Functor</code>的instance，這樣每次我們使用<code>fmap</code>的時候，函數會被套用在第二個field，而第一個field會被加一。</p><pre class="code">instance Functor CMaybe where  
    fmap f CNothing = CNothing  
    fmap f (CJust counter x) = CJust (counter+1) (f x)</pre><p>這種定義方式有點像是<code>Maybe</code>的定義方式，只差在當我們使用<code>fmap</code>的時候，如果碰到的不是空值，那我們不只會套用函數，還會把計數器加一。我們可以來看一些範例操作。</p><pre class="code">ghci> fmap (++"ha") (CJust 0 "ho")  
CJust 1 "hoha"  
ghci> fmap (++"he") (fmap (++"ha") (CJust 0 "ho"))  
CJust 2 "hohahe"  
ghci> fmap (++"blah") CNothing  
CNothing</pre><p>這些會遵守functor laws嗎？要知道有不遵守的情形，只要找到一個反例就好了。</p><pre class="code">ghci> fmap id (CJust 0 "haha")  
CJust 1 "haha"  
ghci> id (CJust 0 "haha")  
CJust 0 "haha"</pre><p>我們知道functor law的第一定律描述當我們用<code>id</code>來map over一個functor的時候，他的結果應該跟只對functor呼叫<code>id</code>的結果一樣。但我們可以看到這個例子中，這對於<code>CMaybe</code>並不遵守。儘管他的確是<code>Functor</code>typeclass的一個instace。但他並不遵守functor law因此不是一個functor。如果有人使用我們的<code>CMaybe</code>型別，把他當作functor用，那他就會期待functor laws會被遵守。但<code>CMaybe</code>並沒辦法滿足，便會造成錯誤的程式。當我們使用一個functor的時候，函數合成跟map over的先後順序不應該有影響。但對於<code>CMaybe</code>他是有影響的，因為他紀錄了被map over的次數。如果我們希望<code>CMaybe</code>遵守functor law，我們必須要讓<code>Int</code>欄位在做<code>fmap</code>的時候維持不變。</p><p>乍看之下functor laws看起來不是很必要，也容易讓人搞不懂，但我們知道如果一個型別遵守functor laws，那我們就能對他作些基本的假設。如果遵守了functor laws，我們知道對他做<code>fmap</code>不會做多餘的事情，只是用一個函數做映射而已。這讓寫出來的程式碼足夠抽象也容易擴展。因為我們可以用定律來推論型別的行為。</p><p>所有在標準函式庫中的<code>Functor</code>的instance都遵守這些定律，但你可以自己檢查一遍。下一次你定義一個型別為<code>Functor</code>的instance的時候，花點時間確認他確實遵守functor laws。一旦你操作過足夠多的functors時，你就會獲得直覺，知道他們會有什麼樣的性質跟行為。而且functor laws也會覺得顯而易見。但就算沒有這些直覺，你仍然可以一行一行地來找看看有沒有反例讓這些定律失效。</p><p>我們可以把functor看作輸出具有context的值。例如說<code>Just 3</code>就是輸出<code>3</code>，但他又帶有一個可能沒有值的context。<code>[1,2,3]</code>輸出三個值，<code>1</code>,<code>2</code>跟<code>3</code>，同時也帶有可能有多個值或沒有值的context。<code>(+3)</code>則會帶有一個依賴於參數的context。</p><p>如果你把functor想做是輸出值這件事，那你可以把map over一個functor這件事想成在functor輸出的後面再多加一層轉換。當我們做<code>fmap (+3) [1,2,3]</code>的時候，我們是把<code>(+3)</code>接到<code>[1,2,3]</code>後面，所以當我們檢視任何一個list的輸出的時候，<code>(+3)</code>也會被套用在上面。另一個例子是對函數做map over。當我們做<code>fmap (+3) (*3)</code>，我們是把<code>(+3)</code>這個轉換套用在<code>(*3)</code>後面。這樣想的話會很自然就會把<code>fmap</code>跟函數合成關聯起來（<code>fmap (+3) (*3)</code>等價於<code>(+3) . (*3)`，也等價於</code>\x -> ((x<b>3)+3)<code>），畢竟我們是接受一個函數</code>(</b>3)<code>然後套用</code>(+3)轉換。最後的結果仍然是一個函數，只是當我們餵給他一個數字的時候，他會先乘上三然後做轉換加上三。這基本上就是函數合成在做的事。</p><a name="Applicative functors"></a><h2>Applicative functors</h2><img src="img/present.png" style="float:right"></img><p>在這個章節中，我們會學到applicative functors，也就是加強版的functors，在Haskell中是用在<code>Control.Applicative</code>中的<code>Applicative</code>這個typeclass來定義的。</p><p>你還記得Haskell中函數預設就是Curried的，那代表接受多個參數的函數實際上是接受一個參數然後回傳一個接受剩餘參數的函數，以此類推。如果一個函數的型別是<code>a -> b -> c</code>，我們通常會說這個函數接受兩個參數並回傳<code>c</code>，但他實際上是接受<code>a</code>並回傳一個<code>b -> c</code>的函數。這也是為什麼我們可以用<code>(f x) y</code>的方式呼叫<code>f x y</code>。這個機制讓我們可以partially apply一個函數，可以用比較少的參數呼叫他們。可以做成一個函數再餵給其他函數。</p><p>到目前為止，當我們要對functor map over一個函數的時候，我們用的函數都是只接受一個參數的。但如果我們要map一個接受兩個參數的函數呢？我們來看幾個具體的例子。如果我們有<code>Just 3</code>然後我們做<code>fmap (*) (Just 3)</code>，那我們會獲得什麼樣的結果？從<code>Maybe</code>對<code>Functor</code>的instance實作來看，我們知道如果他是<code>Just something</code>，他會對在<code>Just</code>中的<code>something</code>做映射。因此當<code>fmap (*) (Just 3)</code>會得到<code>Just ((*) 3)</code>，也可以寫做<code>Just (* 3)</code>。我們得到了一個包在<code>Just</code>中的函數。</p><pre class="code">ghci> :t fmap (++) (Just "hey")  
fmap (++) (Just "hey") :: Maybe ([Char] -> [Char])  
ghci> :t fmap compare (Just 'a')  
fmap compare (Just 'a') :: Maybe (Char -> Ordering)  
ghci> :t fmap compare "A LIST OF CHARS"  
fmap compare "A LIST OF CHARS" :: [Char -> Ordering]  
ghci> :t fmap (\x y z -> x + y / z) [3,4,5,6]  
fmap (\x y z -> x + y / z) [3,4,5,6] :: (Fractional a) => [a -> a -> a]</pre><p>如果我們map<code>compare</code>到一個包含許多字元的list呢？他的型別是<code>(Ord a) => a -> a -> Ordering</code>，我們會得到包含許多<code>Char -> Ordering</code>型別函數的list，因為<code>compare</code>被partially apply到list中的字元。他不是包含許多<code>(Ord a) => a -> Ordering</code>的函數，因為第一個<code>a</code>碰到的型別是<code>Char</code>，所以第二個<code>a</code>也必須是<code>Char</code>。</p><p>我們看到如何用一個多參數的函數來map functor，我們會得到一個包含了函數的functor。那現在我們能對這個包含了函數的functor做什麼呢？我們能用一個吃這些函數的函數來map over這個functor，這些在functor中的函數都會被當作參數丟給我們的函數。</p><pre class="code">ghci> let a = fmap (*) [1,2,3,4]  
ghci> :t a  
a :: [Integer -> Integer]  
ghci> fmap (\f -> f 9) a  
[9,18,27,36]</pre><p>但如果我們的有一個functor裡面是<code>Just (3 *)</code>還有另一個functor裡面是<code>Just 5</code>，但我們想要把第一個<code>Just (3 *)</code>map over<code>Just 5</code>呢？如果是普通的functor，那就沒救了。因為他們只允許map一個普通的函數。即使我們用<code>\f -> f 9</code>來map一個裝了很多函數的functor，我們也是使用了普通的函數。我們是無法單純用<code>fmap</code>來把包在一個functor的函數map另一個包在functor中的值。我們能用模式匹配<code>Just</code>來把函數從裡面抽出來，然後再map<code>Just 5</code>，但我們是希望有一個一般化的作法，對任何functor都有效。</p><p>我們來看看<code>Applicative</code>這個typeclass。他位在<code>Control.Applicative</code>中，在其中定義了兩個函數<code>pure</code>跟<code><*></code>。他並沒有提供預設的實作，如果我們想使用他必須要為他們applicative functor的實作。typeclass定義如下：</p><pre class="code">class (Functor f) => Applicative f where  
    pure :: a -> f a  
    (<*>) :: f (a -> b) -> f a -> f b</pre><p>這簡簡單單的三行可以讓我們學到不少。首先來看第一行。他開啟了<code>Applicative</code>的定義，並加上class contraint。描述了一個型別構造子要是<code>Applicative</code>，他必須也是<code>Functor</code>。這就是為什麼我們說一個型別構造子屬於<code>Applicative</code>的話，他也會是<code>Functor</code>，因此我們能對他使用<code>fmap</code>。</p><p>第一個定義的是<code>pure</code>。他的型別宣告是<code>pure :: a -> f a</code>。<code>f</code>代表applicative functor的instance。由於Haskell有一個優秀的型別系統，其中函數又是將一些參數映射成結果，我們可以從型別宣告中讀出許多訊息。<code>pure</code>應該要接受一個值，然後回傳一個包含那個值的applicative functor。我們這邊是用盒子來作比喻，即使有一些比喻不完全符合現實的情況。儘管這樣，<code>a -> f a</code>仍有許多豐富的資訊，他確實告訴我們他會接受一個值並回傳一個applicative functor，裡面裝有結果。</p><p>對於<code>pure</code>比較好的書法是把一個普通值放到一個預設的context下，一個最小的context但仍然包含這個值。</p><p><code><*></code>也非常有趣。他的型別是<code>f (a -> b) -> f a -> f b</code>。這有讓你聯想到什麼嗎？沒錯！就是<code>fmap :: (a -> b) -> f a -> f b</code>。他有點像加強版的<code>fmap</code>。然而<code>fmap</code>接受一個函數跟一個functor，然後套用functor之中的函數。<code><*></code>則是接受一個裝有函數的functor跟另一個functor，然後取出第一個functor中的函數將他對第二個functor中的值做map。</p><p>我們來看看<code>Maybe</code>的<code>Applicative</code>實作：</p><pre class="code">instance Applicative Maybe where  
    pure = Just  
    Nothing <*> _ = Nothing  
    (Just f) <*> something = fmap f something</pre><p>從class的定義我們可以看到<code>f</code>作為applicative functor會接受一個具體型別當作參數，所以我們是寫成<code>instance Applicative Maybe where</code>而不是寫成<code>instance Applicative (Maybe a) where</code>。</p><p>首先看到<code>pure</code>。他只不過是接受一個東西然後包成applicative functor。我們寫成<code>pure = Just</code>是因為<code>Just</code>不過就是一個普通函數。我們其實也可以寫成<code>pure x = Just x</code>。</p><p>接著我們定義了<code><*></code>。我們無法從<code>Nothing</code>中抽出一個涮，因為<code>Nothing</code>並不包含一個函數。所以我們說如果我們要嘗試從<code>Nothing</code>中取出一個函數，結果必定是<code>Nothing</code>。如果你看看<code>Applicative</code>的定義，你會看到他有<code>Functor</code>的限制，他代表<code><*></code>的兩個參數都會是functors。如果第一個參數不是<code>Nothing</code>，而是一個裝了函數的<code>Just</code>，而且我們希望將這個函數對第二個參數做map。這個也考慮到第二個參數是<code>Nothing</code>的情況，因為<code>fmap</code>任何一個函數至<code>Nothing</code>會回傳<code>Nothing</code>。</p><p>對於<code>Maybe</code>而言，如果左邊是<code>Just</code>，那<code><*></code>會從其中抽出了一個函數來map右邊的值。如果有任何一個參數是<code>Nothing</code>。那結果便是<code>Nothing</code>。</p><p>來試試看吧！</p><pre class="code">ghci> Just (+3) <*> Just 9  
Just 12  
ghci> pure (+3) <*> Just 10  
Just 13  
ghci> pure (+3) <*> Just 9  
Just 12  
ghci> Just (++"hahah") <*> Nothing  
Nothing  
ghci> Nothing <*> Just "woot"  
Nothing</pre><p>我們看到<code>pure (+3)</code>跟<code>Just (+3)</code>在這個case下是一樣的。如果你是在applicative context底下跟<code>Maybe</code>打交道的話請用<code>pure</code>，要不然就用<code>Just</code>。前四個輸入展示了函數是如何被取出並做map的動作，但在這個case底下，他們同樣也可以用unwrap函數來map over functors。最後一行比較有趣，因為我們試著從<code>Nothing</code>取出函數並將他map到某個值。結果當然是<code>Nothing</code>。</p><p>對於普通的functors，你可以用一個函數map over一個functors，但你可能沒辦法拿到結果。而applicative functors則讓你可以用單一一個函數操作好幾個functors。看看下面一段程式碼：</p><pre class="code">ghci> pure (+) <*> Just 3 <*> Just 5  
Just 8  
ghci> pure (+) <*> Just 3 <*> Nothing  
Nothing  
ghci> pure (+) <*> Nothing <*> Just 5  
Nothing</pre><img src="img/whale.png" style="float:right"></img><p>究竟我們寫了些什麽？我們來一步步看一下。<code><*></code>是left-associative，也就是說<code>pure (+) <*> Just 3 <*> Just 5</code>可以寫成<code>(pure (+) <*> Just 3) <*> Just 5</code>。首先<code>+</code>是擺在一個functor中，在這邊剛好他是一個<code>Maybe</code>。所以首先，我們有<code>pure (+)</code>，他等價於<code>Just (+)</code>。接下來由於partial application的關係，<code>Just (+) <*> Just 3</code>等價於<code>Just (3+)</code>。把一個<code>3</code>餵給<code>+</code>形成另一個只接受一個參數的函數，他的效果等於加上3。最後<code>Just (3+) <*> Just 5</code>被運算，其結果是<code>Just 8</code>。</p><p>這樣很棒吧！用applicative style的方式來使用applicative functors。像是<code>pure f <*> x <*> y <*> ...</code>就讓我們可以拿一個接受多個參數的函數，而且這些參數不一定是被包在functor中。就這樣來套用在多個在functor context的值。這個函數可以吃任意多的參數，畢竟<code><*></code>只是做partial application而已。</p><p>如果我們考慮到<code>pure f <*> x</code>等於<code>fmap f x</code>的話，這樣的用法就更方便了。這是applicative laws的其中一條。我們稍後會更仔細地檢視這條定律。現在我們先依直覺來使用他。就像我們先前所說的，<code>pure</code>把一個值放進一個預設的context中。如果我們要把一個函數放在一個預設的context，然後把他取出並套用在放在另一個applicative functor的值。我們會做的事就是把函數map over那個applicative functor。但我們不會寫成<code>pure f <*> x <*> y <*> ...</code>，而是寫成<code>fmap f x <*> y <*> ...</code>。這也是為什麽<code>Control.Aaplicative</code>會export一個函數<code><$></code>，他基本上就是中餟版的<code>fmap</code>。他是這麼被定義的：</p><pre class="code">(<$>) :: (Functor f) => (a -> b) -> f a -> f b  
f <$> x = fmap f x</pre><blockquote><p>要記住型別變數跟參數的名字還有值綁定的名稱不衝突。<code>f</code>在函數的型別宣告中是型別變數，說名<code>f</code>應該要滿足<code>Functor</code>typeclass的條件。而在函數本體中的<code>f</code>則表示一個函數，我們將他map over x。我們同樣用<code>f</code>來表示他們並代表他們是相同的東西。</p></blockquote><p><code><$></code>的使用顯示了applicative style的好處。如果我們想要將<code>f</code>套用三個applicative functor。我們可以寫成<code>f <$> x <*> y <*> z</code>。如果參數不是applicative functor而是普通值的話。我們則寫成<code>f x y z</code>。</p><p>我們再仔細看看他是如何運作的。我們有一個<code>Just "johntra"</code>跟<code>Just "volta"</code>這樣的值，我們希望將他們結合成一個<code>String</code>，並且包含在<code>Maybe</code>中。我們會這樣做：</p><pre class="code">ghci> (++) <$> Just "johntra" <*> Just "volta"  
Just "johntravolta"</pre><p>可以將上面的跟下面這行比較一下：</p><pre class="code">ghci> (++) "johntra" "volta"  
"johntravolta"</pre><p>可以將一個普通的函數套用在applicative functor上真不錯。只要稍微寫一些<code><$></code>跟<code><*></code>就可以把函數變成applicative style，可以操作applicatives並回傳applicatives。</p><p>總之當我們在做<code>(++) <$> Just "johntra" <*> Just "volta"</code>時，首先我們將<code>(++)</code>map over到<code>Just "johntra"</code>，然後產生<code>Just ("johntra"++)</code>，其中<code>(++)</code>的型別為<code>(++) :: [a] -> [a] -> [a]</code>，<code>Just ("johntra"++)</code>的型別為<code>Maybe ([Char] -> [Char])</code>。注意到<code>(++)</code>是如何吃掉第一個參數，以及我們是怎麼決定<code>a</code>是<code>Char</code>的。當我們做<code>Just ("johntra"++) <*> Just "volta"</code>，他接受一個包在<code>Just</code>中的函數，然後map over<code>Just "volta"</code>，產生了<code>Just "johntravolta"</code>。如果兩個值中有任意一個為<code>Nothing</code>，那整個結果就會是<code>Nothing</code>。</p><p>到目前為止我們只有用<code>Maybe</code>當作我們的案例，你可能也會想說applicative functor差不多就等於<code>Maybe</code>。不過其實有許多其他<code>Applicative</code>的instance。我們來看看有哪些。</p><p>List也是applicative functor。很驚訝嗎？來看看我們是怎麼定義<code>[]</code>為<code>Applicative</code>的instance的。</p><pre class="code">instance Applicative [] where  
    pure x = [x]  
    fs <*> xs = [f x | f <- fs, x <- xs]</pre><p>早先我們說過<code>pure</code>是把一個值放進預設的context中。換種說法就是一個會產生那個值的最小context。而對list而言最小context就是<code>[]</code>，但由於空的list並不包含一個值，所以我們沒辦法把他當作<code>pure</code>。這也是為什麼<code>pure</code>其實是接受一個值然後回傳一個包含單元素的list。同樣的，<code>Maybe</code>的最小context是<code>Nothing</code>，但他其實表示的是沒有值。所以<code>pure</code>其實是被實作成<code>Just</code>的。</p><pre class="code">ghci> pure "Hey" :: [String]  
["Hey"]  
ghci> pure "Hey" :: Maybe String  
Just "Hey"</pre><p>至於<code><*></code>呢？如果我們假定<code><*></code>的型別是限制在list上的話，我們會得到<code>(<*>) :: [a -> b] -> [a] -> [b]</code>。他是用list comprehension來實作的。<code><*></code>必須要從左邊的參數取出函數，將他map over右邊的參數。但左邊的list有可能不包含任何函數，也可能包含一個函數，甚至是多個函數。而右邊的list有可能包含多個值。這也是為什麼我們用list comprehension的方式來從兩個list取值。我們要對左右任意的組合都做套用的動作。而得到的結果就會是左右兩者任意組合的結果。</p><pre class="code">ghci> [(*0),(+100),(^2)] <*> [1,2,3]  
[0,0,0,101,102,103,1,4,9]</pre><p>左邊的list包含三個函數，而右邊的list有三個值。所以結果會是有九個元素的list。在左邊list中的每一個函數都被套用到右邊的值。如果我們今天在list中的函數是接收兩個參數的，我們也可以套用到兩個list上。</p><pre class="code">ghci> [(+),(*)] <*> [1,2] <*> [3,4]  
[4,5,5,6,3,4,6,8]</pre><p>由於<code><*></code>是left-associative，也就是說<code>[(+),(*)] <*> [1,2]</code>會先運作，產生<code>[(1+),(2+),(1*),(2*)]</code>。由於左邊的每一個函數都套用至右邊的每一個值。也就產生<code>[(1+),(2+),(1*),(2*)] <*> [3,4]</code>，其便是最終結果。</p><p>list的applicative style是相當有趣的：</p><pre class="code">ghci> (++) <$> ["ha","heh","hmm"] <*> ["?","!","."]  
["ha?","ha!","ha.","heh?","heh!","heh.","hmm?","hmm!","hmm."]</pre><p>看看我們是如何將一個接受兩個字串參數的函數套用到兩個applicative functor上的，只要用適當的applicative運算子就可以達成。</p><p>你可以將list看作是一個non-deterministic的計算。而對於像<code>100</code>或是<code>"what"</code>這樣的值則是deterministic的計算，只會有一個結果。而<code>[1,2,3]</code>則可以看作是沒有確定究竟是哪一種結果。所以他代表的是所有可能的結果。當你在做<code>(+) <$> [1,2,3] <*> [4,5,6]</code>，你可以想做是是把兩個non-deterministic的計算做<code>+</code>，只是他會產生另一個non-deterministic的計算，而且結果更加不確定。</p><p>Applicative style對於list而言是一個取代list comprehension的好方式。在第二章中，我們想要看到<code>[2,5,10]</code>跟<code>[8,10,11]</code>相乘的結果，所以我們這樣做：</p><pre class="code">ghci> [ x*y | x <- [2,5,10], y <- [8,10,11]]     
[16,20,22,40,50,55,80,100,110]</pre><p>我們只是從兩個list中取出元素，並將一個函數套用在任何元素的組合上。這也可以用applicative style的方式來寫：</p><pre class="code">ghci> (*) <$> [2,5,10] <*> [8,10,11]  
[16,20,22,40,50,55,80,100,110]</pre><p>這寫法對我來說比較清楚。可以清楚表達我們是要對兩個non-deterministic的計算做<code>*</code>。如果我們想要所有相乘大於50可能的計算結果，我們會這樣寫：</p><pre class="code">ghci> filter (>50) $ (*) <$> [2,5,10] <*> [8,10,11]  
[55,80,100,110]</pre><p>很容易看到<code>pure f <*> xs</code>等價於<code>fmap f xs</code>。而<code>pure f</code>就是<code>[f]</code>，而且<code>[f] <*> xs</code>可將左邊的每個函數套用至右邊的每個值。但左邊其實只有一個函數，所以他做起來就像是mapping。</p><p>另一個我們已經看過的<code>Applicative</code>的instnace是<code>IO</code>，來看看他是怎麼實作的：</p><pre class="code">instance Applicative IO where  
    pure = return  
    a <*> b = do  
        f <- a  
        x <- b  
        return (f x)</pre><img src="img/knight.png" style="float:left"></img><p>由於<code>pure</code>是把一個值放進最小的context中，所以將<code>return</code>定義成<code>pure</code>是很合理的。因為<code>return</code>也是做同樣的事情。他做了一個不做任何事情的I/O action，他可以產生某些值來作為結果，但他實際上並沒有做任何I/O的動作，例如說印出結果到終端或是檔案。</p><p>如果<code><*></code>被限定在<code>IO</code>上操作的話，他的型別會是<code>(<*>) :: IO (a -> b) -> IO a -> IO b</code>。他接受一個產生函數的I/O action，還有另一個I/O action，並從以上兩者創造一個新的I/O action，也就是把第二個參數餵給第一個參數。而得到回傳的結果，然後放到新的I/O action中。我們用do的語法來實作他。你還記得的話do就是把好幾個I/O action黏在一起，變成一個大的I/O action。</p><p>而對於<code>Maybe</code>跟<code>[]</code>而言，我們可以把<code><*></code>想做是從左邊的參數取出一個函數，然後套用到右邊的參數上。至於<code>IO</code>，這種取出的類比方式仍然適用，但我們必須多加一個sequencing的概念，因為我們是從兩個I/O action中取值，也是在sequencing，把他們黏成一個。我們從第一個I/O action中取值，但要取出I/O action的結果，他必須要先被執行過。</p><p>考慮下面這個範例：</p><pre class="code">myAction :: IO String  
myAction = do  
    a <- getLine  
    b <- getLine  
    return $ a ++ b</pre><p>這是一個提示使用者輸入兩行並產生將兩行輸入串接在一起結果的一個I/O action。我們先把兩個<code>getLine</code>黏在一起，然後用一個<code>return</code>，這是因為我們想要這個黏成的I/O action包含<code>a ++ b</code>的結果。我們也可以用applicative style的方式來描述：</p><pre class="code">myAction :: IO String  
myAction = (++) <$> getLine <*> getLine</pre><p>我們先前的作法是將兩個I/O action的結果餵給函數。還記得<code>getLine</code>的型別是<code>getLine :: IO String</code>。當我們對applicative functor使用<code><*></code>的時候，結果也會是applicative functor。</p><p>如果我們再使用盒子的類比，我們可以把<code>getLine</code>想做是一個去真實世界中拿取字串的盒子。而<code>(++) <$> getLine <*> getLine</code>會創造一個比較大的盒子，這個大盒子會派兩個盒子去終端拿取字串，並把結果串接起來放進自己的盒子中。</p><p><code>(++) <$> getLine <*> getLine</code>的型別是<code>IO String</code>，他代表這個表達式式一個再普通不過的I/O action，他裡面也裝著某種值。這也是為什麼我們可以這樣寫：</p><pre class="code">main = do  
    a <- (++) <$> getLine <*> getLine  
    putStrLn $ "The two lines concatenated turn out to be: " ++ a</pre><p>如果你發現你是在做binding I/O action的動作，而且在binding之後還呼叫一些函數，最後用<code>return</code>來將結果包起來。</p><p>那你可以考慮使用applicative style，這樣可以更簡潔。</p><p>另一個<code>Applicative</code>的instance是<code>(->) r</code>。雖然他們通常是用在code golf的情況，但他們還是十分有趣的例子。所以我們還是來看一下他們是怎麼被實做的。</p><p>如果你忘記<code>(->) r</code>的意思，回去翻翻前一章節我們介紹<code>(->) r</code>作為一個functor的範例。</p><pre class="code">instance Applicative ((->) r) where  
    pure x = (\_ -> x)  
    f <*> g = \x -> f x (g x)</pre><p>當我們用<code>pure</code>將一個值包成applicative functor的時候，他產生的結果永遠都會是那個值。也就是最小的context。那夜市為什麼對於function的<code>pure</code>實做來講，他就是接受一個值，然後造一個函數永遠回傳那個值，不管他被餵了什麼參數。如果你限定<code>pure</code>的型別至<code>(->) r</code>上，他就會是<code>pure :: a -> (r -> a)</code>。</p><pre class="code">ghci> (pure 3) "blah"  
3</pre><p>由於currying的關係，函數套用是left-associative，所以我們忽略掉括弧。</p><pre class="code">ghci> pure 3 "blah"  
3</pre><p>而<code><*></code>的實做是比較不容易瞭解的，我們最好看一下怎麼用applicative style的方式來使用作為applicative functor的function。</p><pre class="code">ghci> :t (+) <$> (+3) <*> (*100)  
(+) <$> (+3) <*> (*100) :: (Num a) => a -> a  
ghci> (+) <$> (+3) <*> (*100) $ 5  
508</pre><p>將兩個applicative functor餵給<code><*></code>可以產生一個新的applicative functor，所以如果我們丟給他兩個函數，我們能得到一個新的函數。所以是怎麼一回事呢？當我們做<code>(+) <$> (+3) <*> (*100)</code>，我們是在實做一個函數，他會將<code>(+3)</code>跟<code>(*100)</code>的結果再套用<code>+</code>。要看一個實際的範例的話，可以看一下<code>(+) <$> (+3) <*> (*100) $ 5</code>首先<code>5</code>被丟給<code>(+3)</code>跟<code>(*100)</code>，產生<code>8</code>跟<code>500</code>。然後<code>+</code>被套用到<code>8</code>跟<code>500</code>，得到<code>508</code>。</p><pre class="code">ghci> (\x y z -> [x,y,z]) <$> (+3) <*> (*2) <*> (/2) $ 5  
[8.0,10.0,2.5]</pre><img src="img/jazzb.png" style="float:right"></img><p>這邊也一樣。我們創建了一個函數，他會呼叫<code>\x y z -> [x,y,z]</code>，而丟的參數是<code>(+3)</code>,<code>(*2)</code>跟<code>(/2)</code>。<code>5</code>被丟給以上三個函數，然後他們結果又接到<code>\x y z -> [x, y, z]</code>。</p><p>你可以將函數想做是裝著最終結果的盒子，所以<code>k <$> f <*> g</code>會製造一個函數，他會將<code>f</code>跟<code>g</code>的結果丟給<code>k</code>。當我們做<code>(+) <$> Just 3 <*> Just 5</code>，我們是用<code>+</code>套用在一些可能有或可能沒有的值上，所以結果也會是可能有或沒有。當我們做<code>(+) <$> (+10) <*> (+5)</code>，我們是將<code>+</code>套用在<code>(+10)</code>跟<code>(+5)</code>的結果上，而結果也會是一個函數，當被餵給一個參數的時候會產生結果。</p><p>我們通常不會將函數當作applicative用，不過仍然值得當作練習。對於<code>(->) r</code>怎麼定義成<code>Applicative</code>的並不是真的那麼重要，所以如果你不是很懂的話也沒關係。這只是讓你獲得一些操作上的直覺罷了。</p><p>一個我們之前還沒碰過的<code>Applicative</code>的instance是<code>ZipList</code>，他是包含在<code>Control.Applicative</code>中。</p><p>對於list要作為一個applicative functor可以有多種方式。我們已經介紹過其中一種。如果套用<code><*></code>，左邊是許多函數，而右邊是許多值，那結果會是函數套用到值的所以盒。如果我們做<code>[(+3),(*2)] <*> [1,2]</code>。那<code>(+3)</code>會先套用至<code>1</code>跟<code>2</code>。接著<code>(*2)</code>套用至<code>1</code>跟<code>2</code>。而得到<code>[4,5,2,4]</code>。</p><p>然而<code>[(+3),(*2)] <*> [1,2]</code>也可以這樣運作:把左邊第一個函數套用至右邊第一個值，接著左邊第二個函數套用右邊第二個值，以此類推。這樣得到的會是<code>[4,4]</code>。或是<code>[1 + 3, 2 * 2]</code>。</p><p>由於一個型別不能對同一個typeclass定義兩個instance，所以才會定義了<code>ZipList a</code>，他只有一個構造子<code>ZipList</code>，他只包含一個欄位，他的型別是list。</p><pre class="code">instance Applicative ZipList where  
        pure x = ZipList (repeat x)  
        ZipList fs <*> ZipList xs = ZipList (zipWith (\f x -> f x) fs xs)</pre><p><code><*></code>做的就是我們之前說的。他將第一個函數套用至第一個值，第二個函數套用第二個值。這也是<code>zipWith (\f x -> f x) fs xs</code>做的事。由於<code>zipWith</code>的特性，所以結果會跟list中比較短的那個一樣長。</p><p><code>pure</code>也值得我們討論一下。他接受一個值，把他重複地放進一個list中。<code>pure "haha"</code>就會是<code>ZipList (["haha","haha","haha"...</code>。這可能會造成些混淆，畢竟我們說過<code>pure</code>是把一個值放進一個最小的context中。而你會想說無限長的list不可能會是一個最小的context。但對於zip list來說這是很合理的，因為他必須在list的每個位置都有值。這也遵守了<code>pure f <*> xs</code>必須要等價於<code>fmap f xs</code>的特性。如果<code>pure 3</code>只是回傳<code>ZipList [3]</code>，那<code>pure (*2) <*> ZipList [1,5,10]</code>就只會算出<code>ZipList [2]</code>，因為兩個zip list算出結果的長度會是比較短的那個的長度。如果我們zip一個有限長的list以及一個無限長的list，那結果的長會是有限長的list的長度。</p><p>那zip list是怎麼用applicative style操作的呢？我們來看看，<code>ZipList a</code>型別並沒有定義成<code>Show</code>的instance，所以我們必須用<code>getZipList</code>函數來從zip list取出一個普通的list。</p><pre class="code">ghci> getZipList $ (+) <$> ZipList [1,2,3] <*> ZipList [100,100,100]  
[101,102,103]  
ghci> getZipList $ (+) <$> ZipList [1,2,3] <*> ZipList [100,100..]  
[101,102,103]  
ghci> getZipList $ max <$> ZipList [1,2,3,4,5,3] <*> ZipList [5,3,1,2]  
[5,3,3,4]  
ghci> getZipList $ (,,) <$> ZipList "dog" <*> ZipList "cat" <*> ZipList "rat"  
[('d','c','r'),('o','a','a'),('g','t','t')]</pre><blockquote><p><code>(,,)</code>函數跟<code>\x y z -> (x,y,z)</code>是等價的，而<code>(,)</code>跟<code>\x y -> (x,y)</code>是等價的。</p></blockquote><p>除了<code>zipWith</code>，標準函式庫中也有<code>zipWith3</code>,<code>zipWith4</code>之類的函數，最多支援到7。<code>zipWith</code>接受一個接受兩個參數的函數，並把兩個list zip起來。<code>zipWith3</code>則接受一個接受三個參數的函數，然後把三個list zip起來。以此類推。用applicative style的方式來操作zip list的話，我們就不需要對每個數量的list都定義一個獨立的zip函數來zip他們。我們只需要用applicative style的方式來把任意數量的list zip起來就可以了。</p><p><code>Control.Applicative</code>定義了一個函數叫做<code>liftA2</code>，他的型別是<code>liftA2 :: (Applicative f) => (a -> b -> c) -> f a -> f b -> f c</code>。他定義如下：</p><pre class="code">liftA2 :: (Applicative f) => (a -> b -> c) -> f a -> f b -> f c  
liftA2 f a b = f <$> a <*> b</pre><p>並沒有太難理解的東西，他不過就是對兩個applicatives套用函數而已，而不用我們剛剛熟悉的applicative style。我們提及他的理由只是要展示為什麼applicative functors比起一般的普通functor要強。如果只是普通的functor的話，我們只能將一個函數map over這個functor。但有了applicative functor，我們可以對好多個functor套用一個函數。看看這個函數的型別，他會是<code>(a -> b -> c) -> (f a -> f b -> f c)</code>。當我們從這樣的角度來看他的話，我們可以說<code>liftA2</code>接受一個普通的二元函數，並將他升級成一個函數可以運作在兩個functor之上。</p><p>另外一個有趣的概念是，我們可以接受兩個applicative functor並把他們結合成一個applicative functor，這個新的將這兩個applicative functor裝在list中。舉裡來說，我們現在有<code>Just 3</code>跟<code>Just 4</code>。我們假設後者是一個只包含單元素的list。</p><pre class="code">ghci> fmap (\x -> [x]) (Just 4)  
Just [4]</pre><p>所以假設我們有<code>Just 3</code>跟<code>Just [4]</code>。我們有怎麼得到<code>Just [3,4]</code>呢？很簡單。</p><pre class="code">ghci> liftA2 (:) (Just 3) (Just [4])  
Just [3,4]  
ghci> (:) <$> Just 3 <*> Just [4]  
Just [3,4]</pre><p>還記得<code>:</code>是一個函數，他接受一個元素跟一個list，並回傳一個新的list，其中那個元素已經接在前面。現在我們有了<code>Just [3,4]</code>，我們能夠將他跟<code>Just 2</code>綁在一起變成<code>Just [2,3,4]</code>嗎？當然可以。我們可以將任意數量的applicative綁在一起變成一個applicative，裡面包含一個裝有結果的list。我們試著實作一個函數，他接受一串裝有applicative的list，然後回傳一個applicative裡面有一個裝有結果的list。我們稱呼他為<code>sequenceA</code>。</p><pre class="code">sequenceA :: (Applicative f) => [f a] -> f [a]  
sequenceA [] = pure []  
sequenceA (x:xs) = (:) <$> x <*> sequenceA xs</pre><p>居然用到了遞迴！首先我們來看一下他的型別。他將一串applicative的list轉換成一個applicative裝有一個list。從這個資訊我們可以推測出邊界條件。如果我們要將一個空的list變成一個裝有list的applicative。我們只要把這個空的list放進一個預設的context。現在來看一下我們怎麼用遞迴的。如果們有一個可以分成頭跟尾的list（<code>x</code>是一個applicative而<code>xs</code>是一串applicatve），我們可以對尾巴呼叫<code>sequenceA</code>，便會得到一個裝有list的applicative。然後我們只要將在<code>x</code>中的值把他接到裝有list的applicative前面就可以了。</p><p>所以如果我們做<code>sequenceA [Just 1, Just 2]</code>，也就是<code>(:) <$> Just 1 <*> sequenceA [Just 2]</code>。那會等價於<code>(:) <$> Just 1 <*> ((:) <$> Just 2 <*> sequenceA [])</code>。我們知道<code>sequenceA []</code>算出來會是<code>Just []</code>，所以運算式就變成<code>(:) <$> Just 1 <*> ((:) <$> Just 2 <*> Just [])</code>，也就是<code>(:) <$> Just 1 <*> Just [2]</code>，算出來就是<code>Just [1,2]</code>。</p><p>另一種實作<code>sequenceA</code>的方式是用fold。要記得幾乎任何需要走遍整個list並accumulate成一個結果的都可以用fold來實作。</p><pre class="code">sequenceA :: (Applicative f) => [f a] -> f [a]  
sequenceA = foldr (liftA2 (:)) (pure [])</pre><p>我們從右往左走，並且起始的acuumulator是用<code>pure []</code>。我們是用<code>liftA2 (:)</code>來結合accumulator跟list中最後的元素，而得到一個applicative，裡面裝有一個單一元素的一個list。然後我們再用<code>liftA2 (:)</code>來結合accumulator跟最後一個元素，最直到我們只剩下accumulator為止，而得到一個applicative，裡面裝有所有結果。</p><p>我們來試試看套用在不同applicative上。</p><pre class="code">ghci> sequenceA [Just 3, Just 2, Just 1]  
Just [3,2,1]  
ghci> sequenceA [Just 3, Nothing, Just 1]  
Nothing  
ghci> sequenceA [(+3),(+2),(+1)] 3  
[6,5,4]  
ghci> sequenceA [[1,2,3],[4,5,6]]  
[[1,4],[1,5],[1,6],[2,4],[2,5],[2,6],[3,4],[3,5],[3,6]]  
ghci> sequenceA [[1,2,3],[4,5,6],[3,4,4],[]]  
[]</pre><p>很酷吧。當我們套用在<code>Maybe</code>上時，<code>sequenceA</code>創造一個新的<code>Maybe</code>，他包含了一個list裝有所有結果。如果其中一個值是<code>Nothing</code>，那整個結果就會是<code>Nothing</code>。如果你有一串<code>Maybe</code>型別的值，但你只在乎當結果不包含任何<code>Nothing</code>的情況，這樣的特性就很方便。</p><p>當套用在函數時，<code>sequenceA</code>接受裝有一堆函數的list，並回傳一個回傳list的函數。在我們的範例中，我們寫了一個函數，他只接受一個數值作為參數，他會把他套用至list中的每一個函數，並回傳一個包含結果的list。<code>sequenceA [(+3),(+2),(+1)] 3</code>會將<code>3</code>餵給<code>(+3)</code>,<code>(+2)</code>跟<code>(+1)</code>，然後將所有結果裝在一個list中。</p><p>而<code>(+) <$> (+3) <*> (*2)</code>會創見一個接受單一參數的一函數，將他同時餵給<code>(+3)</code>跟<code>(*2)</code>，然後呼叫<code>+</code>來將兩者加起來。同樣的道理，<code>sequenceA [(+3),(*2)]</code>是製造一個接受單一參數的函數，他會將他餵給所有包含在list中的函數。但他最後不是呼叫<code>+</code>，而是呼叫<code>:</code>跟<code>pure []</code>來把結果接成一個list，得到最後的結果。</p><p>當我們有一串函數，我們想要將相同的輸入都餵給他們並檢視結果的時候，<code>sequenceA</code>非常好用。例如說，我們手上有一個數值，但不知道他是否滿足一串predicate。一種實作的方式是像這樣：</p><pre class="code">ghci> map (\f -> f 7) [(>4),(<10),odd]  
[True,True,True]  
ghci> and $ map (\f -> f 7) [(>4),(<10),odd]  
True</pre><p>記住<code>and</code>接受一串布林值，並只有在全部都是<code>True</code>的時候才回傳<code>True</code>。</p><p>另一種實作方式是用<code>sequenceA</code>：</p><pre class="code">ghci> sequenceA [(>4),(<10),odd] 7  
[True,True,True]  
ghci> and $ sequenceA [(>4),(<10),odd] 7  
True</pre><p><code>sequenceA [(>4),(<10),odd]</code>接受一個函數，他接受一個數值並將他餵給所有的predicate，包含<code>[(>4),(<10),odd]</code>。然後回傳一串布林值。他將一個型別為<code>(Num a) => [a -> Bool]</code>的list變成一個型別為<code>(Num a) => a -> [Bool]</code>的函數，很酷吧。</p><p>由於list要求裡面元素的型別要一致，所以包含在list中的所有函數都是同樣型別。你不能創造一個像是<code>[ord, (+3)]</code>這樣的list，因為<code>ord</code>接受一個字元並回傳一個數值，然而<code>(+3)</code>接受一個數值並回傳一個數值。</p><p>當跟<code>[]</code>一起使用的時候，<code>sequenceA</code>接受一串list，並回傳另一串list。他實際上是創見一個包含所有可能組合的list。為了方便說明，我們比較一下使用<code>sequenceA</code>跟list comprehension的差異：</p><pre class="code">ghci> sequenceA [[1,2,3],[4,5,6]]  
[[1,4],[1,5],[1,6],[2,4],[2,5],[2,6],[3,4],[3,5],[3,6]]  
ghci> [[x,y] | x <- [1,2,3], y <- [4,5,6]]  
[[1,4],[1,5],[1,6],[2,4],[2,5],[2,6],[3,4],[3,5],[3,6]]  
ghci> sequenceA [[1,2],[3,4]]  
[[1,3],[1,4],[2,3],[2,4]]  
ghci> [[x,y] | x <- [1,2], y <- [3,4]]  
[[1,3],[1,4],[2,3],[2,4]]  
ghci> sequenceA [[1,2],[3,4],[5,6]]  
[[1,3,5],[1,3,6],[1,4,5],[1,4,6],[2,3,5],[2,3,6],[2,4,5],[2,4,6]]  
ghci> [[x,y,z] | x <- [1,2], y <- [3,4], z <- [5,6]]  
[[1,3,5],[1,3,6],[1,4,5],[1,4,6],[2,3,5],[2,3,6],[2,4,5],[2,4,6]]</pre><p>這可能有點難以理解，但如果你多做點嘗試，你會比較能看出來些眉目。假設我們在做<code>sequenceA [[1,2],[3,4]]</code>。要知道這是怎麼回事，我們首先用<code>sequenceA</code>的定義<code>sequenceA (x:xs) = (:) <$> x <*> sequenceA xs</code>還有邊界條件<code>sequenceA [] = pure []</code>來看看。你不需要實際計算，但他可以幫助你理解<code>sequenceA</code>是怎麼運作在一串list上，畢竟這有點複雜。</p><ul><li><p>我們從<code>sequenceA [[1,2],[3,4]]</code>開始</p></li><li><p>那可以被計算成<code>(:) <$> [1,2] <*> sequenceA [[3,4]]</code></p></li><li><p>計算內層的<code>sequenceA</code>，會得到<code>(:) <$> [1,2] <*> ((:) <$> [3,4] <*> sequenceA [])</code></p></li><li><p>我們碰到了邊界條件，所以會是<code>(:) <$> [1,2] <*> ((:) <$> [3,4] <*> [[]])</code></p></li><li><p>現在我們計算<code>(:) <$> [3,4] <*> [[]]</code>的部份，我們會對左邊list中的每一個值 (也就是<code>3</code>跟<code>4</code>) 跟右邊的每一個值 (只有<code>[]</code>)套用<code>:</code>，而得到<code>[3:[], 4:[]]</code>，也就是<code>[[3],[4]]</code>。所以我們有<code>(:) <$> [1,2] <*> [[3],[4]]</code></p></li><li><p>而對於左邊的每一個值(<code>1</code>跟<code>2</code>)以及右邊可能的值（<code>[3]</code>跟<code>[4]</code>）我們套用<code>:</code>而得到<code>[1:[3], 1:[4], 2:[3], 2:[4]]</code>，他等於<code>[[1,3],[1,4],[2,3],[2,4]]</code></p></li></ul><p>計算<code>(+) <$> [1,2] <*> [4,5,6]</code>會得到一個non-deterministic的結果<code>x + y</code>，其中<code>x</code>代表<code>[1,2]</code>中的每一個值，而<code>y</code>代表<code>[4,5,6]</code>中的每一個值。我們用list來表示每一種可能的情形。同樣的，當我們在做<code>sequence [[1,2],[3,4],[5,6],[7,8]]</code>，他的結果會是non-deterministic的<code>[x,y,z,w]</code>，其中<code>x</code>代表<code>[1,2]</code>中的每一個值，而<code>y</code>代表<code>[3,4]</code>中的每一個值。以此類推。我們用list 代表non-deterministic的計算，每一個元素都是一個可能的情形。這也是為什麽會用到list of list。</p><p>當使用在I/O action上的時候，<code>sequenceA</code>跟<code>sequence</code>是等價的。他接受一串I/O action並回傳一個I/O action，這個I/O action會計算list中的每一個I/O action，並把結果放在一個list中。要將型別為<code>[IO a]</code>的值轉換成<code>IO [a]</code>的值，也就是會產生一串list的一個I/O action，那這些I/O action必須要一個一個地被計算，畢竟對於這些I/O action你沒辦法不計算就得到結果。</p><pre class="code">ghci> sequenceA [getLine, getLine, getLine]  
heyh  
ho  
woo  
["heyh","ho","woo"]</pre><p>就像普通的函數一樣，applicative functors也遵循一些定律。其中最重要的一個是我們之前提過的<code>pure f <*> x = fmap f x</code>。你可以證明一些我們之前介紹過的applicative functor遵守這個定律當作練習。其他的functors law有：</p><ul><li><p><code>pure id <*> v = v</code></p></li><li><p><code>pure (.) <*> u <*> v <*> w = u <*> (v <*> w)</code></p></li><li><p><code>pure f <*> pure x = pure (f x)</code></p></li><li><p><code>u <*> pure y = pure ($ y) <*> u</code></p></li></ul><p>我們不會一項一項地細看，那樣會花費很大的篇幅而且對讀者來說很無聊，但如果你有興趣，你可以針對某些instance看看他們會不會遵守。</p><p>結論就是applicative functor不只是有趣而且實用， 他允許我們結合不同種類的計算，像是I/O計算，non-deterministic的計算，有可能失敗的計算等等。而使用<code><$></code>跟<code><*></code>我們可以將普通的函數來運作在任意數量的applicative functors上。</p><a name="關鍵字"newtype""></a><h2>關鍵字"newtype"</h2><img src="img/maoi.png" style="float:left"></img><p>到目前為止，我們已經看過了如何用<code>data</code>關鍵字定義自己的algebraic data type。我們也學習到了如何用<code>type</code>來定義type synonyms。在這個章節中，我們會看一下如何使用<code>newtype</code>來從一個現有的型別中定義出新的型別，並說明我們為什麽會想要那麼做。</p><p>在之前的章節中，我們瞭解到其實list有很多種方式可以被視為一種applicative functor。一中方式是定義<code><*></code>將左邊的每一個值跟右邊的每一個值組合，而得到各種組合的結果。</p><pre class="code">ghci> [(+1),(*100),(*5)] <*> [1,2,3]  
[2,3,4,100,200,300,5,10,15]</pre><p>第二種方式是將<code><*></code>定義成將左邊的第一個函數套用至右邊的第一個值，然後將左邊第二個函數套用至右邊第二個值。以此類推。最終，這表現得有點像將兩個list用一個拉鍊拉起來一樣。但由於list已經被定義成<code>Applicaitive`的instance了，所以我們要怎麼要讓list可以被定義成第二種方式呢？如果你還記得我們說過我們是有很好的理由定義了</code>ZipList a<code>，其中他裡面只包含一個值構造子跟只包含一個欄位。其實他的理由就是要讓</code>ZipList<code>定義成用拉鍊的方式來表現applicative行為。我們只不過用</code>ZipList<code>這個構造子將他包起來，然後用</code>getZipList來解開來。</p><pre class="code">ghci> getZipList $ ZipList [(+1),(*100),(*5)] <*> ZipList [1,2,3]  
[2,200,15]</pre><p>所以這跟newtype這個關鍵字有什麽關係呢？想想看我們是怎麼宣告我們的<code>ZipList a</code>的，一種方式是像這樣：</p><pre class="code">data ZipList a = ZipList [a]</pre><p>也就是一個只有一個值構造子的型別而且那個構造子裡面只有一個欄位。我們也可以用record syntax來定義一個解開的函數：</p><pre class="code">data ZipList a = ZipList { getZipList :: [a] }</pre><p>這樣聽起來不錯。這樣我們就有兩種方式來讓一個型別來表現一個typeclass，我們可以用<code>data</code>關鍵自來把一個型別包在另一個裡面，然後再將他定義成第二種表現方式。</p><p>而在Haskell中<code>newtype</code>正是為了這種情形，我們想將一個型別包在另一個型別中。在實際的函式庫中<code>ZipList a</code>是這樣定義了：</p><pre class="code">newtype ZipList a = ZipList { getZipList :: [a] }</pre><p>這邊我們不用<code>data</code>關鍵字反而是用<code>newtype</code>關鍵字。這是為什麽呢？第一個理由是<code>newtype</code>比較快速。如果你用<code>data</code>關鍵字來包一個型別的話，在你執行的時候會有一些包起來跟解開來的成本。但如果你用<code>newtype</code>的話，Haskell會知道你只是要將一個現有的型別包成一個新的型別，你想要內部運作完全一樣但只是要一個全新的型別而已。有了這個概念，Haskell可以將包裹跟解開來的成本都去除掉。</p><p>那為什麽我們不是一直使用<code>newtype</code>呢？當你用<code>newtype</code>來製作一個新的型別時，你只能定義單一一個值構造子，而且那個構造子只能有一個欄位。但使用<code>data</code>的話，你可以讓那個型別友好幾個值構造子，並且每個構造子可以有零個或多個欄位。</p><pre class="code">data Profession = Fighter | Archer | Accountant  
  
data Race = Human | Elf | Orc | Goblin  

data PlayerCharacter = PlayerCharacter Race Profession</pre><p>當使用newtype的時候，你是被限制只能用一個值構造子跟單一欄位。</p><p>對於<code>newtype</code>我們也能使用<code>deriving</code>關鍵字。我們可以derive像是<code>Eq</code>,<code>Ord</code>,<code>Enum</code>,<code>Bounded</code>,<code>Show</code>跟<code>Read</code>的instance。如果我們想要對新的型別做derive，那原本的型別必須已經在那個typeclass中。這樣很合理，畢竟<code>newtype</code>就是要將現有的型別包起來。如果我們按照下面的方式定義的話，我們就能對我們的型別做印出以及比較相等性的操作：</p><pre class="code">newtype CharList = CharList { getCharList :: [Char] } deriving (Eq, Show)</pre><p>我們來跑跑看：</p><pre class="code">ghci> CharList "this will be shown!"  
CharList {getCharList = "this will be shown!"}  
ghci> CharList "benny" == CharList "benny"  
True  
ghci> CharList "benny" == CharList "oisters"  
False</pre><p>對於這個<code>newtype</code>，他的值構造子有下列型別：</p><pre class="code">CharList :: [Char] -> CharList</pre><p>他接受一個<code>[Char]</code>的值，例如<code>"my sharona"</code>並回傳一個<code>CharList</code>的值。從上面我們使用<code>CharList</code>的值構造子的範例中，我們可以看到的確是這樣。相反地，<code>getCharList</code>具有下列的型別。</p><pre class="code">getCharList :: CharList -> [Char]</pre><p>他接受一個<code>CharList</code>的值並將他轉成<code>[Char]</code>。你可以將這個想成包裝跟解開的動作，但你也可以將他想成從一個型別轉成另一個型別。</p><a name="Using newtype to make type class instances"></a><h3>Using newtype to make type class instances</h3><p>有好幾次我們想要讓我們的型別屬於某個typeclass，但型別變數並沒有符合我們想要的。要把<code>Maybe</code>定義成<code>Functor</code>的instnace很容易，因為<code>Functor</code>這個typeclass被定義如下：</p><pre class="code">class Functor f where  
    fmap :: (a -> b) -> f a -> f b</pre><p>我們先定義如下：</p><pre class="code">instance Functor Maybe where</pre><p>然後我們實做<code>fmap</code>。當所有的型別變數被填上時，由於<code>Maybe</code>取代了<code>Functor</code>中<code>f</code>的位置，所以如果我們看看<code>fmap</code>運作在<code>Maybe</code>上時是什麽樣，他會像這樣：</p><pre class="code">fmap :: (a -> b) -> Maybe a -> Maybe b</pre><img src="img/shamrock.png" style="float:right"></img><p>看起來不錯吧？現在我們想要tuple成為<code>Functor</code>的一個instance，所以當我們用<code>fmap</code>來map over一個tuple時，他會先套用到tuple中的第一個元素。這樣當我們做<code>fmap (+3) (1,1)</code>會得到<code>(4,1)</code>。不過要定義出這樣的instance有些困難。對於<code>Maybe</code>，我們只要寫<code>instance Functor Maybe where</code>，這是因為對於只吃一個參數的型別構造子我們很容易定義成<code>Functor</code>的instance。但對於<code>(a,b)</code>這樣的就沒辦法。要繞過這樣的困境，我們可以用<code>newtype</code>來重新定義我們的tuple，這樣第二個型別參數就代表了tuple中的第一個元素部份。</p><pre class="code">newtype Pair b a = Pair { getPair :: (a,b) }</pre><p>現在我們可以將他定義成<code>Functor</code>的instnace，所以函數被map over tuple中的第一個部份。</p><pre class="code">instance Functor (Pair c) where  
    fmap f (Pair (x,y)) = Pair (f x, y)</pre><p>正如你看到的，我們可以對newtype定義的型別做模式匹配。我們用模式匹配來拿到底層的tuple，然後我們將<code>f</code>來套用至tuple的第一個部份，然後我們用<code>Pair</code>這個值構造子來將tuple轉換成<code>Pair b a</code>。如果我們問<code>fmap</code>的型別究竟是什麽，他會是：</p><pre class="code">fmap :: (a -> b) -> Pair c a -> Pair c b</pre><p>我們說過<code>instance Functor (Pair c) where</code>跟<code>Pair c</code>取代了<code>Functor</code>中<code>f</code>的位置：</p><pre class="code">class Functor f where  
    fmap :: (a -> b) -> f a -> f b</pre><p>如果我們將一個tuple轉換成<code>Pair b a</code>，我們可以用<code>fmap</code>來map over第一個部份。</p><pre class="code">ghci> getPair $ fmap (*100) (Pair (2,3))  
(200,3)  
ghci> getPair $ fmap reverse (Pair ("london calling", 3))  
("gnillac nodnol",3)</pre><a name="On newtype laziness"></a><h3>On newtype laziness</h3><p>我們提到<code>newtype</code>一般來講比<code>data</code>來得有效率。<code>newtype</code>能做的唯一一件事就是將現有的型別包成新的型別。這樣Haskell在內部就能將新的型別的值用舊的方式來操作。只是要記住他們還是不同的型別。這代表<code>newtype</code>並不只是有效率，他也具備lazy的特性。我們來說明一下這是什麽意思。</p><p>就像我們之前說得，Haskell預設是具備lazy的特性，這代表只有當我們要將函數的結果印出來的時候計算才會發生。或者說，只有當我們真的需要結果的時候計算才會發生。在Haskell中<code>undefined</code>代表會造成錯誤的計算。如果我們試著計算他，也就是將他印到終端中，Haskell會丟出錯誤。</p><pre class="code">ghci> undefined  
*** Exception: Prelude.undefined</pre><p>然而，如果我們做一個list，其中包含一些<code>undefined</code>的值，但卻邀邱一個不是<code>undefined</code>的head，那一切都會順利地被計算，因為Haskell並不需要list中其他元素來得到結果。我們僅僅需要看道地一個元素而已。</p><pre class="code">ghci> head [3,4,5,undefined,2,undefined]  
3</pre><p>現在們考慮下面的型別：</p><pre class="code">data CoolBool = CoolBool { getCoolBool :: Bool }</pre><p>這是一個用<code>data</code>關鍵字定義的algebraic data type。他有一個值建構子並只有一個型別為<code>Bool</code>的欄位。我們寫一個函數來對<code>CoolBool</code>做模式匹配，並回傳一個<code>"hello"</code>的值。他並不會館<code>CoolBool</code>中裝的究竟是<code>True</code>或<code>False</code>。</p><pre class="code">helloMe :: CoolBool -> String  
helloMe (CoolBool _) = "hello"</pre><p>這次我們不餵給這個函數一個普通的<code>CoolBool</code>，而是丟給他一個<code>undefined</code>。</p><pre class="code">ghci> helloMe undefined  
"*** Exception: Prelude.undefined  "</pre><p>結果收到了一個Exception。是什麽造成這個Exception的呢？用<code>data</code>定義的型別可以有好幾個值構造子（儘管<code>CoolBool</code>只有一個）所以當我們要看看餵給函數的值是否是<code>(CoolBool _)</code>的形式，Haskell會需要做一些基本的計算來看看是哪個值構造子備用到。但當我們計算<code>undefined</code>的時候，就算是一點也會丟出Exception。</p><p>我們不用<code>data</code>來定義<code>CoolBool</code>而用<code>newtype</code>：</p><pre class="code">newtype CoolBool = CoolBool { getCoolBool :: Bool }</pre><p>我們不用修改<code>helloMe</code>函數，因為對於模式匹配使用<code>newtype</code>或<code>data</code>都是一樣。我們再來將<code>undefined</code>餵給<code>helloMe</code>。</p><pre class="code">ghci> helloMe undefined  
"hello"</pre><p>居然正常運作！為什麽呢？正如我們說過得，當我們使用<code>newtype</code>的時候，Haskell內部可以將新的型別用舊的型別來表示。他不必加入另一層box來包住舊有的型別。他只要注意他是不同的型別就好了。而且Haskell會知道<code>newtype</code>定義的型別一定只會有一個構造子，他不必計算餵給函數的值就能確定他是<code>(CoolBool _)</code>的形式，因為<code>newtype</code>只有一個可能的值跟單一欄位！</p><p>這樣行為的差異可能沒什麼關係，但實際上他非常重要。因為他讓我們認知到儘管從撰寫程式的觀點來看沒什麽差異，但他們的確是兩種不同的機制。儘管<code>data</code>可以讓你從無到有定義型別，<code>newtype</code>是從一個現有的型別做出來的。對<code>newtype</code>做模式匹配並不是像從盒子中取出東西，他比較像是將一個型別轉換成另一個型別。</p><a name="type vs newtype vs data"></a><h3>type vs newtype vs data</h3><p>到目前為止，你也許對於<code>type</code>,<code>data</code>跟<code>newtype</code>`之間的差異還不是很瞭解，讓我們快速複習一遍。</p><p><code>type</code>關鍵字是讓我們定義type synonyms。他代表我們只是要給一個現有的型別另一個名字，假設我們這樣做：</p><pre class="code">type IntList = [Int]</pre><p>這樣做可以允許我們用<code>IntList</code>的名稱來指稱<code>[Int]</code>。我們可以交換地使用他們。但我們並不會因此有一個<code>IntList</code>的值構造子。因為<code>[Int]</code>跟<code>IntList</code>只是兩種指稱同一個型別的方式。我們在指稱的時候用哪一個並無所謂。</p><pre class="code">ghci> ([1,2,3] :: IntList) ++ ([1,2,3] :: [Int])  
[1,2,3,1,2,3]</pre><p>當我們想要讓type signature更清楚一些，給予我們更瞭解函數的context的時候，我們會定義type synonyms。舉例來說，當我們用一個型別為<code>[(String,String)]</code>的association list來代表一個電話簿的時候，我們可以定義一個<code>PhoneBook1</code>的type synonym，這樣type signature會比較容易讀。</p><p><code>newtype</code>關鍵字將現有的型別包成一個新的型別，大部分是為了要讓他們可以是特定typeclass的instance而這樣做。當我們使用<code>newtype</code>來包裹一個現有的型別時，這個型別跟原有的型別是分開的。如果我們將下面的型別用<code>newtype</code>定義：</p><pre class="code">newtype CharList = CharList { getCharList :: [Char] }</pre><p>我們不能用<code>++</code>來將<code>CharList</code>跟<code>[Char]</code>接在一起。我們也不能用<code>++</code>來將兩個<code>CharList</code>接在一起，因為<code>++</code>只能套用在list上，而<code>CharList</code>並不是list，儘管你會說他包含一個list。但我們可以將兩個<code>CharList</code>轉成list，將他們<code>++</code>然後再轉回<code>CharList</code>。</p><p>當我們在<code>newtype</code>宣告中使用record syntax的時候，我們會得到將新的型別轉成舊的型別的函數，也就是我們<code>newtype</code>的值構造子，以及一個函數將他的欄位取出。新的型別並不會被自動定義成原有型別所屬的typeclass的一個instance，所以我們必須自己來derive他們。</p><p>實際上你可以將<code>newtype</code>想成是只能定義一個構造子跟一個欄位的<code>data</code>宣告。如果你碰到這種情形，可以考慮使用<code>newtype</code>。</p><p>使用<code>data</code>關鍵字是為了定義自己的型別。他們可以在algebraic data type中放任意數量的構造子跟欄位。可以定義的東西從list,<code>Maybe</code>到tree。</p><p>如果你只是希望你的type signature看起來比較乾淨，你可以只需要type synonym。如果你想要將現有的型別包起來並定義成一個type class的instance，你可以嘗試使用newtype。如果你想要定義完全新的型別，那你應該使用<code>data</code>關鍵字。</p><a name="Monoids"></a><h2>Monoids</h2><p>Haskell中typeclass是用來表示一個型別之間共有的行為，是一種interace。我們介紹過<code>Eq</code>，他定義型別是否可以比較相等性，以及<code>Ord</code>，他表示可以被排序的型別。還介紹了更有去的像是<code>Functor</code>跟<code>Applicative</code>。</p><p>當我們定義一個型別時，我們會想說他應該要支援的行為。也就是表現的行為是什麽，並且要讓他屬於哪些typeclass。如果希望他可以比較相等與否，那我們就應該定義他成為<code>Eq</code>的一個instance。如果我們想要看看型別是否是一種functor，我們可以定義他是<code>Functor</code>的一個instance。以此類推。</p><p>考慮<code>*</code>是一個將兩個數值相乘的一個函數。如果我們將一個數值乘上<code>1</code>，那就會得到自身的數值。我們實際上是做<code>1 * x</code>或<code>x * 1</code>並沒有差別。結果永遠會是<code>x</code>。同樣的，<code>++</code>是一個接受兩個參數並回傳新的值的一個函數。只是他不是相乘而是將兩個list接在一起。而類似<code>*</code>，他也有一個特定的值，當他跟其他值使用<code>++</code>時會得到同樣的值。那個值就是空的list<code>[]</code>。</p><pre class="code">ghci> 4 * 1  
4  
ghci> 1 * 9  
9  
ghci> [1,2,3] ++ []  
[1,2,3]  
ghci> [] ++ [0.5, 2.5]  
[0.5,2.5]</pre><p>看起來<code>*</code>之於<code>1</code>跟<code>++</code>之於<code>[]</code>有類似的性質：</p><ul><li><p>函數同樣接受兩個參數</p></li><li><p>參數跟回傳值是同樣的型別</p></li><li><p>同樣存在某些值當套用二元函數時並不會改變其他值</p></li></ul><p>關於這兩種操作還有另一個比較難察覺的性質就是，當我們對這個二元函數對三個以上的值操作並化見，函數套用的順序並不會影響到結果。不論是<code>(3 * 4) * 5</code>或是<code>3 * (4 * 5)</code>？兩種方式都會得到<code>60</code>。而<code>++</code>也是相同的。</p><pre class="code">ghci> (3 * 2) * (8 * 5)  
240  
ghci> 3 * (2 * (8 * 5))  
240  
ghci> "la" ++ ("di" ++ "da")  
"ladida"  
ghci> ("la" ++ "di") ++ "da"  
"ladida"</pre><p>我們稱呼這樣的性質為結合律(associativity)。<code>*</code>遵守結合律，<code>++</code>也是。但<code>-</code>就不遵守。<code>(5 - 3) - 4</code>跟<code>5 - (3 - 4)</code>得到的結果是不同的。</p><p>注意到這些性質並具體地寫下來，就可以得到monoid。一個monoid是你有一個遵守結合綠的二元函數還有一個可以相對於那個函數作為identity的值。當某個值相對於一個函數是一個identity，他表示當我們將這個值丟給函數時，結果永遠會是另外一邊的那個值本身。<code>1</code>是相對於<code>*</code>的identity，而<code>[]</code>是相對於<code>++</code>的identity。在Haskell中還有許多其他的monoid，這也是為什麽我們定義了<code>Monoid</code>這個typeclass。他描述了表現成monoid的那些型別。我們來看看這個typeclass是怎麼被定義的：</p><pre class="code">class Monoid m where  
    mempty :: m  
    mappend :: m -> m -> m  
    mconcat :: [m] -> m  
    mconcat = foldr mappend mempty</pre><img src="img/balloondog.png" style="float:right"></img><p><code>Monoid</code>typeclass被定義在<code>import Data.Monoid</code>中。我們來花些時間好好瞭解他。</p><p>首先我們看到只有具體型別才能定義成<code>Monoid</code>的instance。由於在typeclass定義中的<code>m</code>並不接受任何型別參數。這跟<code>Functor</code>以及<code>Applicative</code>不同，他們要求他們的instance必須是一個接受單一型別參數的型別構造子。</p><p>第一個函數是<code>mempty</code>，由於他不接受任何參數，所以他並不是一個函數，而是一個polymorphic的常數。有點像是<code>Bounded</code>中的<code>minBound</code>一樣。<code>mempty</code>表示一個特定monoid的identity。</p><p>再來我們看到<code>mappend</code>，你可能已經猜到，他是一個接受兩個相同型別的值的二元函數，並回傳同樣的型別。不過要注意的是他的名字不太符合他真正的意思，他的名字隱含了我們要將兩個東西接在一起。儘管在list的情況下<code>++</code>的確將兩個list接起來，但<code>*</code>則否。他只不過將兩個數值做相乘。當我們再看到其他<code>Monoid</code>的instance時，我們會看到他們大部分都沒有接起來的做，所以不要用接起來的概念來想像<code>mappend</code>，只要想像他們是接受兩個monoid的值並回傳另外一個就好了。</p><p>在typeclass定義中的最後一個函數是<code>mconcat</code>。他接受一串monoid值，並將他們用<code>mappend</code>簡化成單一的值。他有一個預設的實做，就是從<code>mempty</code>作為起始值，然後用<code>mappend</code>來fold。由於對於大部分的instance預設的實做就沒什麼問題，我們不會想要實做自己的<code>mconcat</code>。當我們定義一個型別屬於<code>Monoid</code>的時候，多半實做<code>mempty</code>跟<code>mappend</code>就可以了。而<code>mconcat</code>就是因為對於一些instance，有可能有比較有效率的方式來實做<code>mconcat</code>。不過大多數情況都不需要。</p><p>在我們繼續接下去看幾個<code>Monoid</code>的例子前，我們來看一下monoid law。我們提過必須有一個值作為identity以及一個遵守結合律的二元函數當作前提。我們是可以定義一個<code>Monoid</code>的instance卻不遵守這些定律的，但這樣寫出來的instance就沒有用了，因為我們在使用<code>Monoid</code>的時候都是依靠這些定律才可以稱作實質上的monoid。所以我們必須確保他們遵守：</p><ul><li><p><code>mempty `mappend` x = x</code></p></li><li><p><code>x `mappend` mempty = x</code></p></li><li><p><code>(x `mappend` y) `mappend` z = x `mappend` (y `mappend` z)</code></p></li></ul><p>前兩個描述了<code>mempty</code>相對於<code>mappend</code>必須要表現成identity。而第三個定律說了<code>mappend</code>必須要遵守結合律。也就是說我們做<code>mappend</code>順序並不重要。Haskell不會自己檢查這些定律是否有被遵守。所以你必須自己小心地檢查他們。</p><a name="Lists are monoids"></a><h3>Lists are monoids</h3><p>沒錯，list是一種monoid。正如我們先前看到的，<code>++</code>跟空的list<code>[]</code>共同形成了一個monoid。他的instance很簡單：</p><pre class="code">instance Monoid [a] where  
    mempty = []  
    mappend = (++)</pre><p>list是<code>Monoid</code>typeclass的一個instance，這跟他們裝的元素的型別無關。注意到我們寫<code>instance Monoid [a]</code>而非<code>instance Monoid []</code>，這是因為<code>Monoid</code>要求instance必須是具體型別。</p><p>我們試著跑跑看，得到我們預期中的結果：</p><pre class="code">ghci> [1,2,3] `mappend` [4,5,6]  
[1,2,3,4,5,6]  
ghci> ("one" `mappend` "two") `mappend` "tree"  
"onetwotree"  
ghci> "one" `mappend` ("two" `mappend` "tree")  
"onetwotree"  
ghci> "one" `mappend` "two" `mappend` "tree"  
"onetwotree"  
ghci> "pang" `mappend` mempty  
"pang"  
ghci> mconcat [[1,2],[3,6],[9]]  
[1,2,3,6,9]  
ghci> mempty :: [a]  
[]</pre><img src="img/smug.png" style="float:left"></img><p>注意到最後一行我們明白地標記出型別。這是因為如果只些<code>mempty</code>的話，GHCi不會知道他是哪一個instance的<code>mempty</code>，所以我們必須清楚說出他是list instance的mempty。我們可以使用一般化的型別<code>[a]</code>，因為空的list可以看作是屬於任何型別。</p><p>由於<code>mconcat</code>有一個預設的實做，我們將某個型別定義成<code>Monoid</code>的型別時就可以自動地得到預設的實做。但對於list而言，<code>mconcat</code>其實就是<code>concat</code>。他接受一個裝有list的list，並把他用<code>++</code>來扁平化他。</p><p>list的instnace也遵守monoid law。當我們有好幾個list並且用<code>mappend</code>來把他們串起來，先後順序並不是很重要，因為他們都是接在最後面。而且空的list也表現得如identity一樣。注意到monoid並不要求<code>a `mappend</code>b<code>等於</code>bmappenda。在list的情況下，他們明顯不相等。</p><pre class="code">ghci> "one" `mappend` "two"  
"onetwo"  
ghci> "two" `mappend` "one"  
"twoone"</pre><p>這樣並沒有關系。<code>3 * 5</code>跟<code>5 * 3</code>會相等只不過是乘法的性質而已，但沒有保證所有monoid都要遵守。</p><a name="Product and Sum"></a><h3>Product and Sum</h3><p>我們已經描述過將數值表現成一種monoid的方式。只要將<code>*</code>當作二元函數而<code>1</code>當作identity就好了。而且這不是唯一一種方式，另一種方式是將<code>+</code>作為二元函數而<code>0</code>作為identity。</p><pre class="code">ghci> 0 + 4  
4  
ghci> 5 + 0  
5  
ghci> (1 + 3) + 5  
9  
ghci> 1 + (3 + 5)  
9</pre><p>他也遵守monoid law，因為將0加上其他數值，都會是另外一者。而且加法也遵守結合律。所以現在我們有兩種方式來將數值表現成monoid，那要選哪一個呢？其實我們不必要強迫定下來，還記得當同一種型別有好幾種表現成某個typeclass的方式時，我們可以用<code>newtype</code>來包裹現有的型別，然後再定義新的instance。這樣就行了。</p><p><code>Data.Monoid</code>這個模組匯出了兩種型別，<code>Product</code>跟<code>Sum</code>。<code>Product</code>定義如下：</p><pre class="code">newtype Product a =  Product { getProduct :: a }  
    deriving (Eq, Ord, Read, Show, Bounded)</pre><p>簡單易懂，就是一個單一型別參數的<code>newtype</code>，並derive一些性質。他的<code>`Monoid</code>的instance長得像這樣：</p><pre class="code">instance Num a => Monoid (Product a) where  
    mempty = Product 1  
    Product x `mappend` Product y = Product (x * y)</pre><p><code>mempty</code>只不過是將<code>1</code>包在<code>Product</code>中。<code>mappend</code>則對<code>Product</code>的構造子做模式匹配，將兩個取出的數值相乘後再將結果放回去。就如擬看到的，typeclass定義前面有<code>Num a</code>的條件限制。所以他代表<code>Product a</code>對於所有屬於<code>Num</code>的<code>a</code>是一個<code>Monoid</code>。要將<code>Product a</code>作為一個monoid使用，我們需要用newtype來做包裹跟解開的動作。</p><pre class="code">ghci> getProduct $ Product 3 `mappend` Product 9  
27  
ghci> getProduct $ Product 3 `mappend` mempty  
3  
ghci> getProduct $ Product 3 `mappend` Product 4 `mappend` Product 2  
24  
ghci> getProduct . mconcat . map Product $ [3,4,2]  
24</pre><p>這當作<code>Monoid</code>的一個演練還不錯，但並不會有人覺得這會比<code>3 * 9</code>跟<code>3 * 1</code>這種方式來做乘法要好。但我們稍後會說明儘管像這種顯而易見的定義還是有他方便的地方。</p><p><code>Sum</code>跟<code>Product</code>定義的方式類似，我們也可以用類似的方式操作：</p><pre class="code">ghci> getSum $ Sum 2 `mappend` Sum 9  
11  
ghci> getSum $ mempty `mappend` Sum 3  
3  
ghci> getSum . mconcat . map Sum $ [1,2,3]  
6</pre><a name="Any and ALL"></a><h3>Any and ALL</h3><p>另一種可以有兩種表示成monoid方式的型別是<code>Bool</code>。第一種方式是將<code>||</code>當作二元樹，而<code>False</code>作為identity。這樣的意思是只要有任何一個參數是<code>True</code>他就回傳<code>True</code>，否則回傳<code>Falsse</code>。所以如果我們使用<code>False</code>作為identity，他會在跟<code>False</code>做OR時回傳<code>False</code>，跟<code>True</code>做OR時回傳<code>True</code>。<code>Any</code>這個newtype是<code>Monoid</code>的一個instance，並定義如下：</p><pre class="code">newtype Any = Any { getAny :: Bool }  
    deriving (Eq, Ord, Read, Show, Bounded)</pre><p>他的instance長得像這樣：</p><pre class="code">instance Monoid Any where  
    mempty = Any False  
    Any x `mappend` Any y = Any (x || y)</pre><p>他叫做<code>Any</code>的理由是<code>x `mappend` y</code>當有任何一個是<code>True</code>時就會是<code>True</code>。就算是更多個用<code>mappend</code>串起來的<code>Any</code>，他也會在任何一個是<code>True</code>回傳<code>True</code>。</p><pre class="code">ghci> getAny $ Any True `mappend` Any False  
True  
ghci> getAny $ mempty `mappend` Any True  
True  
ghci> getAny . mconcat . map Any $ [False, False, False, True]  
True  
ghci> getAny $ mempty `mappend` mempty  
False</pre><p>另一種<code>Bool</code>表現成<code>Monoid</code>的方式是用<code>&&</code>作為二元函數，而<code>True</code>作為identity。只有當所有都是<code>True</code>的時候才會回傳<code>True</code>。下面是他的newtype定義：</p><pre class="code">newtype All = All { getAll :: Bool }  
        deriving (Eq, Ord, Read, Show, Bounded)</pre><p>而這是他的instance：</p><pre class="code">instance Monoid All where  
        mempty = All True  
        All x `mappend` All y = All (x && y)</pre><p>當我們用<code>mappend</code>來串起<code>All</code>型別的值時，結果只有當所有<code>mappend</code>的值是<code>True</code>時才會是<code>True</code>：</p><pre class="code">ghci> getAll $ mempty `mappend` All True  
True  
ghci> getAll $ mempty `mappend` All False  
False  
ghci> getAll . mconcat . map All $ [True, True, True]  
True  
ghci> getAll . mconcat . map All $ [True, True, False]  
False</pre><p>就如乘法跟加法一樣，我們通常寧願用二元函數來操作他們也不會用newtype來將他們包起來。不會將他們包成<code>Any</code>或<code>All</code>然後用<code>mappend</code>，<code>mempty</code>或<code>mconcat</code>來操作。通常使用<code>or</code>跟<code>and</code>，他們接受一串<code>Bool</code>，並只有當任意一個或是所有都是<code>True</code>的時候才回傳<code>True</code>。</p><a name="The Ordering monoid"></a><h3>The Ordering monoid</h3><p>還記得<code>Ordering</code>型別嗎?他是比較運算之後得到的結果，包含三個值：<code>LT</code>，<code>EQ</code>跟<code>GT</code>，分別代表小於，等於跟大於：</p><pre class="code">ghci> 1 `compare` 2  
LT  
ghci> 2 `compare` 2  
EQ  
ghci> 3 `compare` 2  
GT</pre><p>針對list，數值跟布林值而言，要找出monoid的行為只要去檢視已經定義的函數，然後看看有沒有展現出monoid的特性就可以了，但對於<code>Ordering</code>，我們就必須要更仔細一點才能看出來是否是一個monoid，但其實他的<code>Monoid</code>instance還蠻直覺的：</p><pre class="code">instance Monoid Ordering where  
    mempty = EQ  
    LT `mappend` _ = LT  
    EQ `mappend` y = y  
    GT `mappend` _ = GT</pre><img src="img/bear.png" style="float:right"></img><p>這個instance定義如下：當我們用<code>mappend</code>兩個<code>Ordering</code>型別的值時，左邊的會被保留下來。除非左邊的值是<code>EQ</code>，那我們就會保留右邊的當作結果。而identity就是<code>EQ</code>。乍看之下有點隨便，但實際上他是我們比較兩個英文字時所用的方法。我們先比較兩個字母是否相等，如果他們不一樣，那我們就知道那一個字在字典中會在前面。而如果兩個字母相等，那我們就繼續比較下一個字母，以此類推。</p><p>舉例來說，如果我們字典順序地比較<code>"ox"</code>跟<code>"on"</code>的話。我們會先比較兩個字的首個字母，看看他們是否相等，然後繼續比較第二個字母。我們看到<code>'x'</code>是比<code>'n'</code>要來得大，所以我們就知道如何比較兩個字了。而要瞭解為何<code>EQ</code>是identity，我們可以注意到如果我們在兩個字中間的同樣位置塞入同樣的字母，那他們之間的字典順序並不會改變。<code>"oix"</code>仍然比<code>"oin"</code>要大。</p><p>很重要的一件事是在<code>Ordering</code>的<code>Monoid</code>定義裡<code>x `mappend` y</code>並不等於<code>y `mappend` x</code>。因為除非第一個參數是<code>EQ</code>，不然結果就會是第一個參數。所以<code>LT `mappend` GT</code>等於<code>LT</code>，然而<code>GT `mappend` LT</code>等於<code>GT</code>。</p><pre class="code">ghci> LT `mappend` GT  
LT  
ghci> GT `mappend` LT  
GT  
ghci> mempty `mappend` LT  
LT  
ghci> mempty `mappend` GT  
GT</pre><p>所以這個monoid在什麽情況下會有用呢？假設你要寫一個比較兩個字串長度的函數，並回傳<code>Ordering</code>。而且當字串一樣長的時候，我們不直接回傳<code>EQ</code>，反而繼續用字典順序比較他們。一種實做的方式如下：</p><pre class="code">lengthCompare :: String -> String -> Ordering  
lengthCompare x y = let a = length x `compare` length y   
                        b = x `compare` y  
                    in  if a == EQ then b else a</pre><p>我們稱呼比較長度的結果為<code>a</code>，而比較字典順序的結果為<code>b</code>，而當長度一樣時，我們就回傳字典順序。</p><p>如果善用我們<code>Ordering</code>是一種monoid這項知識，我們可以把我們的函數寫得更簡單些：</p><pre class="code">import Data.Monoid

lengthCompare :: String -> String -> Ordering  
lengthCompare x y = (length x `compare` length y) `mappend`  
                    (x `compare` y)</pre><p>我們可以試著跑跑看：</p><pre class="code">ghci> lengthCompare "zen" "ants"  
LT  
ghci> lengthCompare "zen" "ant"  
GT</pre><p>要記住當我們使用<code>mappend</code>。他在左邊不等於<code>EQ</code>的情況下都會回傳左邊的值。相反地則回傳右邊的值。這也是為什麽我們將我們認為比較重要的順序放在左邊的參數。如果我們要繼續延展這個函數，要讓他們比較母音的順序，並把這順序列為第二重要，那我們可以這樣修改他：</p><pre class="code">import Data.Monoid  
  
lengthCompare :: String -> String -> Ordering  
lengthCompare x y = (length x `compare` length y) `mappend`  
                    (vowels x `compare` vowels y) `mappend`  
                    (x `compare` y)  
    where vowels = length . filter (`elem` "aeiou")</pre><p>我們寫了一個輔助函數，他接受一個字串並回傳他有多少母音。他是先用filter來把字母濾到剩下<code>"aeiou"</code>，然後再用<code>length</code>計算長度。</p><pre class="code">ghci> lengthCompare "zen" "anna"  
LT  
ghci> lengthCompare "zen" "ana"  
LT  
ghci> lengthCompare "zen" "ann"  
GT</pre><p>在第一個例子中我們看到長度不同所以回傳<code>LT</code>，明顯地<code>"zen"</code>要短於<code>"anna"</code>。在第二個例子中，長度是一樣的，但第二個字串有比較多的母音，所以結果仍然是<code>LT</code>。在第三個範例中，兩個長度都相等，他們也有相同個數的母音，經由字典順序比較後得到<code>"zen"</code>比較大。</p><p><code>Ordering</code>的monoid允許我們用不同方式比較事物，並將這些順序也定義了依重要度不同的一個順序。</p><a name="Maybe the monoid"></a><h3>Maybe the monoid</h3><p>我們來看一下<code>Maybe a</code>是怎樣有多種方式來表現成<code>Monoid</code>的，並且說明哪些是比較有用的。一種將<code>Maybe a</code>當作monoid的方式就是他的<code>a</code>也是一個monoid，而我們將<code>mappend</code>實做成使用包在<code>Just</code>裡面的值對應的<code>mappend</code>。並且用<code>Nothing</code>當作identity。所以如果我<code>mappend</code>兩個參數中有一個是<code>Nothing</code>。那結果就會是另一邊的值。他的instance定義如下：</p><pre class="code">instance Monoid a => Monoid (Maybe a) where  
    mempty = Nothing  
    Nothing `mappend` m = m  
    m `mappend` Nothing = m  
    Just m1 `mappend` Just m2 = Just (m1 `mappend` m2)</pre><p>留意到class constraint。他說明<code>Maybe a</code>只有在<code>a</code>是<code>Monoid</code>的情況下才會是一個<code>Monoid</code>。如果我們<code>mappend</code>某個東西跟<code>Nothing</code>。那結果就會是某個東西。如果我們<code>mappend</code>兩個<code>Just</code>，那<code>Just</code>包住的結果就會<code>mappended</code>在一起並放回<code>Just</code>。我們能這麼做是因為class constraint保證了在<code>Just</code>中的值是<code>Monoid</code>。</p><pre class="code">ghci> Nothing `mappend` Just "andy"  
Just "andy"  
ghci> Just LT `mappend` Nothing  
Just LT  
ghci> Just (Sum 3) `mappend` Just (Sum 4)  
Just (Sum {getSum = 7})</pre><p>這當你在處理有可能失敗的monoid的時候比較有用。有了這個instance，我們就不必一一去檢查他們是否失敗，是否是<code>Nothing</code>或是<code>Just</code>，我們可以直接將他們當作普通的monoid。</p><p>但如果在<code>Maybe</code>中的型別不是<code>Monoid</code>呢？注意到在先前的instance定義中，唯一有依賴於monoid限制的情況就是在<code>mappend</code>兩個<code>Just</code>的時候。但如果我們不知道包在<code>Just</code>裡面的值究竟是不是monoid，我們根本無法用<code>mappend</code>操作他們，所以該怎麼辦呢？一種方式就是直接丟掉第二個值而留下第一個值。這就是<code>First a</code>存在的目的，而這是他的定義：</p><pre class="code">newtype First a = First { getFirst :: Maybe a }  
    deriving (Eq, Ord, Read, Show)</pre><p>我們接受一個<code>Maybe a</code>並把他包成newtype，<code>Monoid</code>的定義如下：</p><pre class="code">instance Monoid (First a) where  
    mempty = First Nothing  
    First (Just x) `mappend` _ = First (Just x)  
    First Nothing `mappend` x = x</pre><p>正如我們說過得，<code>mempty</code>就是包在<code>First</code>中的<code>Nothing</code>。如果<code>mappend</code>的第一個參數是<code>Just</code>，我們就直接忽略第二個參數。如果第一個參數是<code>Nothing</code>，那我們就將第二個參數當作結果。並不管他究竟是<code>Just</code>或是<code>Nothing</code>：</p><pre class="code">ghci> getFirst $ First (Just 'a') `mappend` First (Just 'b')  
Just 'a'  
ghci> getFirst $ First Nothing `mappend` First (Just 'b')  
Just 'b'  
ghci> getFirst $ First (Just 'a') `mappend` First Nothing  
Just 'a'</pre><p><code>First</code>在我們有一大串<code>Maybe</code>而且想知道他們之中就竟有沒有<code>Just</code>的時候很有用。可以利用<code>mconcat</code>：</p><pre class="code">ghci> getFirst . mconcat . map First $ [Nothing, Just 9, Just 10]  
Just 9</pre><p>如果我們希望定義一個<code>Maybe a</code>的monoid，讓他當<code>mappend</code>的兩個參數都是<code>Just</code>的時候將第二個參數當作結果。<code>Data.Monoid</code>中有一個現成的<code>Last a</code>，他很像是<code>First a</code>，只差在<code>mappend</code>跟<code>mconcat</code>會保留最後一個非<code>Nothing</code>的值。</p><pre class="code">ghci> getLast . mconcat . map Last $ [Nothing, Just 9, Just 10]  
Just 10  
ghci> getLast $ Last (Just "one") `mappend` Last (Just "two")  
Just "two"</pre><a name="Using monoids to fold data structures"></a><h3>Using monoids to fold data structures</h3><p>另一種有趣的monoid使用方式就是讓他來幫助我們fold一些資料結構。到目前為止我們只有fold list。但list並不是唯一一種可以fold的資料結構。我們幾乎可以fold任何一種資料結構。像是tree也是一種常見的可以fold的資料結構。</p><p>由於有太多種資料結構可以fold了，所以我們定義了<code>Foldable</code>這個typeclass。就像<code>Functor</code>是定義可以map over的結構。<code>Foldable</code>是定義可以fold的結構。在<code>Data.Foldable</code>中有定義了一些有用的函數，但他們名稱跟<code>Prelude</code>中的名稱衝突。所以最好是用qualified的方式import他們：</p><pre class="code">import qualified Foldable as F</pre><p>為了少打一些字，我們將他們import qualified成<code>F</code>。所以這個typeclass中定義了哪些函數呢？有<code>foldr</code>，<code>foldl</code>，<code>foldr1</code>跟<code>foldl1</code>。你會說我們已經知道這些函數了，他們有什麽不一樣的地方嗎？我們來比較一下<code>Foldable</code>中的<code>foldr</code>跟<code>Prelude</code>中的<code>foldr</code>的型別異同：</p><pre class="code">ghci> :t foldr  
foldr :: (a -> b -> b) -> b -> [a] -> b  
ghci> :t F.foldr  
F.foldr :: (F.Foldable t) => (a -> b -> b) -> b -> t a -> b</pre><p>儘管<code>foldr</code>接受一個list並將他fold起來，<code>Data.Foldable</code>中的<code>foldr</code>接受任何可以fold的型別。並不只是list。</p><p>而兩個<code>foldr</code>對於list的結果是相同的：</p><pre class="code">ghci> foldr (*) 1 [1,2,3]  
6  
ghci> F.foldr (*) 1 [1,2,3]  
6</pre><p>那有哪些資料結構支援fold呢？首先我們有<code>Maybe</code>：</p><pre class="code">ghci> F.foldl (+) 2 (Just 9)  
11  
ghci> F.foldr (||) False (Just True)  
True</pre><p>但fold一個<code>Maybe</code>並沒什麽新意。畢竟當他是<code>Just</code>的時候表現得像是只有單一元素的list，而當他是<code>Nothing</code>的時候就像是空的list一樣。所以我們來看一些比較複雜的資料結構。</p><p>還記得Making Our Own Types and Typeclass章節中的樹狀的資料結構嗎？我們是這樣定義的：</p><pre class="code">data Tree a = Empty | Node a (Tree a) (Tree a) deriving (Show, Read, Eq)</pre><p>我們說一棵樹要不就是一棵空的樹要不然就是一個包含值的節點，並且還指向另外兩棵樹。定義他之後，我們將他定義成<code>Functor</code>的instance，因此可以<code>fmap</code>他。現在我們要將他定義成<code>Foldable</code>的instance，這樣我們就可以fold他。要定義成<code>Foldable</code>的一種方式就是實做<code>foldr</code>。但另一種比較簡單的方式就是實做<code>foldMap</code>，他也屬於<code>Foldable</code>typeclass。<code>foldMap</code>的型別如下：</p><pre class="code">foldMap :: (Monoid m, Foldable t) => (a -> m) -> t a -> m</pre><p>第一個參數是一個函數，這個函數接受foldable資料結構中包含的元素的型別，並回傳一個monoid。他第二個參數是一個foldable的結構，並包含型別<code>a</code>的元素。他將第一個函數來map over這個foldable的結構，因此得到一個包含monoid的foldable結構。然後用<code>mappend</code>來簡化這些monoid，最後得到單一的一個monoid。這個函數聽起來不太容易理解，但我們下面會看到他其實很容易實做。而且好消息是只要實做了這個函數就可以讓我們的函數成為<code>Foldable</code>。所以我們只要實做某個型別的<code>foldMap</code>，我們就可以得到那個型別的<code>foldr</code>跟<code>foldl</code>。</p><p>這就是我們如何定義<code>Tree</code>成為<code>Foldable</code>的：</p><pre class="code">instance F.Foldable Tree where  
    foldMap f Empty = mempty  
    foldMap f (Node x l r) = F.foldMap f l `mappend`  
                                f x           `mappend`  
                                F.foldMap f r</pre><img src="img/accordion.png" style="float:right"></img><p>我們是這樣思考的：如果我們寫一個函數，他接受樹中的一個元素並回傳一個monoid，那我們要怎麼簡化整棵樹到只有單一一個monoid？當我們在對樹做<code>fmap</code>的時候，我們將那函數套用至節點上，並遞迴地套用至左子樹以及右子樹。這邊我們不只是map一個函數而已，我們還要求要把結果用<code>mappend</code>簡化成只有單一一個monoid值。首先我們考慮樹為空的情形，一棵沒有值也沒有子樹的情形。由於沒有值我們也沒辦法將他套用上面轉換成monoid的函數，所以當樹為空的時候，結果應該要是<code>mempty</code>。</p><p>在非空節點的情形下比較有趣，他包含一個值跟兩棵子樹。在這種情況下，我們遞迴地做<code>foldMap</code>，用<code>f</code>來套用到左子樹跟右子樹上。藥劑祝我們的<code>foldMap</code>只會得到單一的monoid值。我們也會套用<code>f</code>到節點中的值。這樣我們就得到三個monoid值，有兩個來自簡化子樹的結果，還有一個是套用<code>f</code>到節點中的值的結果。而我們需要將這三個值整合成單一個值。要達成這個目的我們使用<code>mappend</code>，而且自然地會想到照左子樹，節點值以及右子樹的順序來簡化。</p><p>注意到我們並不一定要提供一個將普通值轉成monoid的函數。我們只是把他當作是<code>foldMap</code>的參數，我們要決定的只是如何套用那個函數，來把得到的monoid們簡化成單一結果。</p><p>現在我們有樹的<code>Foldable</code>instance，而<code>foldr</code>跟<code>foldl</code>也有預設的實做了。考慮下面這棵樹：</p><pre class="code">testTree = Node 5  
            (Node 3  
             (Node 1 Empty Empty)  
             (Node 6 Empty Empty)  
            )  
            (Node 9  
             (Node 8 Empty Empty)  
             (Node 10 Empty Empty)  
            )</pre><p>他的root是<code>5</code>，而他左邊下來分別是<code>3</code>，再來是<code>1</code>跟<code>6</code>。而右邊下來是<code>9</code>，再來是<code>8</code>跟<code>10</code>。有了<code>Foldable</code>的定義，我們就能像對list做fold一樣對樹做fold：</p><pre class="code">ghci> F.foldl (+) 0 testTree  
42  
ghci> F.foldl (*) 1 testTree  
64800</pre><p><code>foldMap</code>不只是定義<code>Foldable</code>新的instance有用。他也對簡化我們的結構至單一monoid值有用。舉例來說，如果我們想要知道我們的樹中有沒有<code>3</code>，我們可以這樣做：</p><pre class="code">ghci> getAny $ F.foldMap (\x -> Any $ x == 3) testTree  
True</pre><p>這邊<code>\x -> Any $ x == 3</code>是一個接受一個數值並回傳一個monoid的函數，也就是一個包在<code>Any</code>中的<code>Bool</code>。<code>foldMap</code>將這個函數套用至樹的每一個節點，並把結果用<code>mappend</code>簡化成單一monoid。如果我們這樣做：</p><pre class="code">ghci> getAny $ F.foldMap (\x -> Any $ x > 15) testTree  
False</pre><p>經過套用lambda之後我們所有的節點都會是<code>Any False</code>。但<code>mappend</code>必須要至少吃到一個<code>True</code>才能讓最後的結果變成<code>True</code>。這也是為什麽結果會是<code>False</code>，因為我們樹中所有的值都大於<code>15</code>。</p><p>我們也能將<code>foldMap</code>配合<code>\x -> [x]</code>使用來將我們的樹轉成list。經過套用那個函數後，所有節點都變成包含單一元素的list。最後用<code>mappend</code>將這些單一元素的list轉成一個裝有全部元素的list：</p><pre class="code">ghci> F.foldMap (\x -> [x]) testTree  
[1,3,6,5,8,9,10]</pre><p>這個小技巧並不限於樹而已，他可以被套用在任何<code>Foldable</code>上。</p>
            <ul class="nav">
                <li class="left">  <img src="img/prv.png"></img><a href="functionally-solving-problems.html">函數式地思考來解決問題</a></li>
                <li class="center"><a href="chapters.html">Index</a></li>
                <li class="right"> <a href="a-fistful-of-monads.html">來看看幾種Monad</a><img src="img/nxt.png"></img></li>
            </ul>
        </div>
        <div id="footer">
        </div>
        <div id="feedback">Send feedback</div>
    </body>
</html>
