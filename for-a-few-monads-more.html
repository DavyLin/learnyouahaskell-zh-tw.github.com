<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
        <style>
            @import url(css/style.css);
        </style>
        <script src="js/jquery.js"></script>
        <script src="js/jquery.chili-2.2.js"></script>
        <script src="js/script.js"></script>
        <script>
             ChiliBook.recipeFolder = "js/chili/";  
             ChiliBook.automaticSelector = "pre";
        </script>
        <title>再來看看更多Monad</title>
    </head>
    <body>
        <div id="header">
            <img id="beta" alt="beta" src="img/beta.png" />
        </div>

        <div id="main">
            <ul class="nav">
                <li class="left">  <img src="img/prv.png"></img><a href="a-fistful-of-monads.html">來看看幾種Moand</a></li>
                <li class="center"><a href="chapters.html">Index</a></li>
                <li class="right"> <a href="zippers.html">Zippers資料結構</a><img src="img/nxt.png"></img></li>
            </ul>
            <a name="再來看看更多Monad"></a><h1>再來看看更多Monad</h1><p>我們已經看過Monad是如何接受具有context的值，並如何用函數操作他們。</p><p>還有如何用<code>>>=</code>跟<code>do</code>來減輕我們對context的關注，集中精神在value本身。</p><p>我們也看過了<code>Maybe</code>是如何把值加上一個可能會失敗的context。</p><p>我們學習到List Monad是如何加進多重結果的context。</p><p>我們也了解<code>IO</code>Monad如何運作，而且我們在知道什麼是Monad之前就已經知道他了。</p><p>在這個章節，我們會介紹一些其他的Monad。</p><p>他們可以把值變成monadiv value，因此可以讓我們的程式更簡潔清晰。</p><p>多見識幾個Monad也可以敏銳我們對Monad的直覺。</p><p>我們即將要介紹的Monad都包含在<code>mtl</code>這個套建中。</p><p>一個Haskell package包含了一堆模組。</p><p>而<code>mtl</code>已經包含在Haskell Platform中，所以你可能不用另外安裝。</p><p>要檢查你有沒有這套件，你可以下<code>ghc-pkg list</code>。</p><p>這會列出你已經安裝的套件，其中應該包含<code>mtl</code>後面接著對應的版號。</p><a name="你所不知道的Writer Monad"></a><h2>你所不知道的Writer Monad</h2><p>我們已經看過<code>Maybe</code>, list以及<code>IO</code>Monad。</p><p>現在我們要來看看<code>Writer</code>Monad。</p><p>相對於<code>Maybe</code>是加入可能失敗的context，list是加入non-deterministic的context，</p><p><code>Writer</code>則是加進一個附加值的context，好比log一般。</p><p><code>Writer</code>可以讓我們在計算的同時蒐集所有log紀錄，並匯集成一個log並附加在結果上。</p><p>例如我們想要附加一個String好說明我們的值在幹麼（有可能是為了除錯）。</p><p>想像有一個函數接受一個代表幫派人數的數字，然後會回傳值告訴我們這是否算是一個龐大的幫派：</p><pre class="code">isBigGang :: Int -> Bool  
isBigGang x = x > 9</pre><p>現在我們希望他不只是回傳<code>True</code>或<code>False</code>，我們還希望他能夠多回傳一個字串代表log。</p><p>這很容易，只要多加一個<code>String</code>在<code>Bool</code>旁邊就好了。</p><pre class="code">isBigGang :: Int -> (Bool, String)  
isBigGang x = (x > 9, "Compared gang size to 9.")</pre><p>我們現在回傳了一個Tuple，第一個元素是原來的布林值，第二個元素是一個String。</p><p>現在我們的值有了一個context。</p><pre class="code">ghci> isBigGang 3  
(False,"Compared gang size to 9.")  
ghci> isBigGang 30  
(True,"Compared gang size to 9.")</pre><p>到目前為止都還不錯，<code>isBigGang</code>回傳一個值跟他的context。</p><p>對於正常的數值來說這樣的寫法都能運作良好。</p><p>但如果我們想要把一個已經具有context的值，像是<code>(3, "Smallish gang.")</code>，餵給<code>isBigGang</code>呢？</p><p>我們又面對了同樣的問題：</p><p>如果我們有一個能接受正常數值並回傳一個具有context值的function，</p><p>那我們要如何餵給他一個具有context的值？</p><p>當我們在研究<code>Maybe</code>monad的時候，我們寫了一個<code>applyMaybe</code>。</p><p>他接受一個<code>Maybe a</code>值跟一個<code>a -> Maybe b</code>型態的函數，</p><p>他會把<code>Maybe a</code>餵給這個function，即便這個function其實是接受<code>a</code>而非<code>Maybe a</code>。</p><p><code>applyMaybe</code>有針對這樣的context做處裡，也就是會留意有可能發生的失敗情況。</p><p>但在<code>a -> Maybe b</code>裡面，我們可以只專心處裡正常數值即可。</p><p>因為<code>applyMaybe</code>(之後變成了<code>>>=</code>)會幫我們處裡需要檢查<code>Nothing</code>或<code>Just</code>的情況。</p><p>我們再來寫一個接受附加log值的函數，</p><p>也就是<code>(a, String)</code>型態的值跟<code>a -> (b, String)</code>型態的函數。</p><p>我們稱呼這個函數為<code>applyLog</code>。</p><p>這個函數有的context是附加log值，而不是一個可能會失敗的context，</p><p>因此<code>applyLog</code>會確保原有的log被保留，並附上從函數產生出的新的log。</p><p>這邊我們來看一下實做：</p><pre class="code">applyLog :: (a,String) -> (a -> (b,String)) -> (b,String)  
applyLog (x,log) f = let (y,newLog) = f x in (y,log ++ newLog)</pre><p>當我們想把一個具有context的值餵給一個函數的時候，</p><p>我們會嘗試把值跟他的context分開，然後把值餵給函數再重新接回context。</p><p>在<code>Maybe</code>monad的情況，我們檢查值是否為<code>Just x</code>，如果是，便將<code>x</code>餵給函數。</p><p>而在log的情況，我們知道pair的其中一個component是log而另一個是值。</p><p>所以我們先取出值<code>x</code>，將<code>f</code>apply到<code>x</code>，便獲取<code>(y,newLog)</code>，</p><p>其中<code>y</code>是新的值而<code>newLog</code>則是新的log。</p><p>但如果我們回傳<code>newLog</code>，舊的log便不會包含進去，</p><p>所以我們要回傳的是<code>(y, log ++ newLog)</code>。</p><p>我們用<code>++</code>來把新的log接到舊的上面。</p><p>來看看<code>applyLog</code>運作的情形：</p><pre class="code">ghci> (3, "Smallish gang.") `applyLog` isBigGang  
(False,"Smallish gang.Compared gang size to 9")  
ghci> (30, "A freaking platoon.") `applyLog` isBigGang  
(True,"A freaking platoon.Compared gang size to 9")</pre><p>跟之前的結果很像，只差在我們多了伴隨產生的log。</p><p>再來多看幾個例子：</p><pre class="code">ghci> ("Tobin","Got outlaw name.") `applyLog` (\x -> (length x, "Applied length."))  
(5,"Got outlaw name.Applied length.")  
ghci> ("Bathcat","Got outlaw name.") `applyLog` (\x -> (length x, "Applied length"))  
(7,"Got outlaw name.Applied length")</pre><p>可以看到在lambda裡面<code>x</code>只是個正常的字串而不是tuple，且<code>applyLog</code>幫我們處裡掉附加log的動作。</p><p><b>Monoids的好處</b></p><blockquote><p>請確定你了解什麼是Monoids。</p></blockquote><p>到目前為止<code>applyLog</code>接受<code>(a,String)</code>型態的值，</p><p>但為什麼log一定要是<code>String</code>呢？</p><p>我們使用<code>++</code>來附加新的log，</p><p>難道<code>++</code>並不能運作在任何形式的list，而一定要限制我們在<code>String</code>上呢？</p><p>我們當然可以擺脫<code>String</code>，</p><p>我們可以如下改變他的型態：</p><pre class="code">applyLog :: (a,[c]) -> (a -> (b,[c])) -> (b,[c])</pre><p>我們用一個List來代表Log。</p><p>包含在List中的元素型態必須跟原有的List跟回傳的List型態相同，</p><p>否則我們沒辦法用<code>++</code>來把他們接起來。</p><p>這能夠運作在bytestring上嗎？絕對沒問題。</p><p>只是我們現在的型態只對List有效。</p><p>我們必須要另外做一個bytestring版本的<code>applyLog</code>。</p><p>但我們注意到List跟bytestring都是monoids。</p><p>因此他們都是<code>Monoid</code>type class的instance，</p><p>那代表他們都有實做<code>mappend</code>。</p><p>對List以及bytestring而言，<code>mappend</code>都是拿來串接的。</p><pre class="code">ghci> [1,2,3] `mappend` [4,5,6]  
[1,2,3,4,5,6]  
ghci> B.pack [99,104,105] `mappend` B.pack [104,117,97,104,117,97]  
Chunk "chi" (Chunk "huahua" Empty)</pre><p>修改後我們的<code>applyLog</code>可以運作在任何monoid上。</p><p>我們必須要修改型態宣告來表示這件事，同時也要在實做中把<code>++</code>改成<code>mappend</code>：</p><pre class="code">applyLog :: (Monoid m) => (a,m) -> (a -> (b,m)) -> (b,m)  
applyLog (x,log) f = let (y,newLog) = f x in (y,log `mappend` newLog)</pre><p>由於現在包含的值可以是任何monoid，</p><p>我們不再需要把tuple想成包含一個值跟對應的log，</p><p>我們可以想成他包含一個值跟一個對應的monoid。</p><p>舉例來說，</p><p>可以說我們有一個tuple包含一個產品名稱跟一個符合monoid特性的產品價格。</p><p>我們可以定義一個<code>Sum</code>的newtype來保證我們在操作產品的時候也會把價錢跟著加起來。</p><pre class="code">import Data.Monoid  
  
type Food = String  
type Price = Sum Int  

addDrink :: Food -> (Food,Price)  
addDrink "beans" = ("milk", Sum 25)  
addDrink "jerky" = ("whiskey", Sum 99)  
addDrink _ = ("beer", Sum 30)</pre><p>我們用string來代表食物，用<code>newtype</code>重新定義<code>nInt</code>為<code>Sum</code>，</p><p>來追蹤總共需要花多少錢。</p><p>可以注意到我們用<code>mappend</code>來操作<code>Sum</code>的時候，價錢會被一起加起來。</p><pre class="code">ghci> Sum 3 `mappend` Sum 9  
Sum {getSum = 12}</pre><p><code>addDrink</code>的實做很簡單，</p><p>如果我們想吃豆子，他會回傳<code>"milk"</code>以及伴隨的<code>Sum 25</code>，</p><p>同樣的如果我們要吃"jerky"，他就會回傳"whiskey"，</p><p>要吃其他東西的話，就會回傳"beer"。</p><p>乍看之下這個函數沒什麼特別，</p><p>但如果用<code>applyLog</code>的話就會有趣些。</p><pre class="code">ghci> ("beans", Sum 10) `applyLog` addDrink  
("milk",Sum {getSum = 35})  
ghci> ("jerky", Sum 25) `applyLog` addDrink  
("whiskey",Sum {getSum = 124})  
ghci> ("dogmeat", Sum 5) `applyLog` addDrink  
("beer",Sum {getSum = 35})</pre><p>牛奶價值<code>25</code>美分，但如果我們也吃了價值<code>10</code>美分的豆子的話，</p><p>總共需要付<code>35</code>美分。</p><p>這樣很清楚地展示了伴隨的值不一定需要是log，他可以是任何monoid。</p><p>至於兩個值要如何結合，那要看monoid中怎麼定義。</p><p>當我們需要的是log的時候，他們是串接，</p><p>但這個case裡面，數字是被加起來。</p><p>由於<code>addDrink</code>回傳一個<code>(Food,Price)</code>，</p><p>我們可以再把結果重新餵給<code>addDrink</code>，</p><p>這可以很容易告訴我們總共喝了多少錢：</p><pre class="code">ghci> ("dogmeat", Sum 5) `applyLog` addDrink `applyLog` addDrink  
("beer",Sum {getSum = 65})</pre><p>將狗食跟30美分的啤酒加在一起會得到<code>("beer", Sum 35)</code>。</p><p>如果我們用<code>applyLog</code>將上面的結果再餵給<code>addDrink</code>，</p><p>我們會得到<code>("beer", Sum 65)</code>這樣的結果。</p><p><b>The Writer type</b></p><p>我們認識了一個附加monoid的值其實表現出來的是一個monad，</p><p>我們來再來看看其他類似的<code>Monad</code>instance。</p><p><code>Control.Monad.Writer</code>這模組含有<code>Writer w a</code>的一個型態，</p><p>裏面定義了他<code>Monad</code>的instance，</p><p>還有一些操作這些值的函數。</p><p>首先，我們來看一下型態。</p><p>要把一個monoid附加給一個值，只需要定義一個tuple就好了。</p><p><code>Writer w a</code>這型態其實是一個<code>newtype</code>wrapper。</p><p>他的定義很簡單：</p><pre class="code">newtype Writer w a = Writer { runWriter :: (a, w) }</pre><p>他包在一個<code>newtype</code>裏面，並且可以是一個<code>Monad</code>的instance，</p><p>而且這樣定義的好處是可以跟單純tuple的型態區分開來。</p><p><code>a</code>這個型態參數代表是包含的值的型態，而<code>w</code>則是附加的monoid的型態。</p><p>他<code>Monad</code>instance的定義如下：</p><pre class="code">instance (Monoid w) => Monad (Writer w) where  
    return x = Writer (x, mempty)  
    (Writer (x,v)) >>= f = let (Writer (y, v')) = f x in Writer (y, v `mappend` v')</pre><p>首先，我們來看看<code>>>=</code>。</p><p>他的實作基本上就是<code>applyLog</code>，</p><p>只是我們的tuple現在是包在一個<code>Writer</code>的<code>newtype</code>中，</p><p>我們可以用pattern matching的方式把他給unwrap。</p><p>我們將<code>x</code>餵給<code>f</code>。</p><p>這會回給我們<code>Writer w a</code>。</p><p>接著可以用<code>let</code>expression來做pattern matching。</p><p>把結果綁定到<code>y</code>這個名字上，</p><p>然後用<code>mappend</code>來結合舊的monoid值跟新的monoid值。</p><p>最後把結果跟monoid值用<code>Writer</code>constructor包起來，</p><p>形成我們最後的<code>Writer</code>value。</p><p>那<code>return</code>呢？</p><p>回想<code>return</code>的作用是接受一個值，並回傳一個具有意義的最小context來裝我們的值。</p><p>那究竟什麼樣的context可以代表我們的<code>Writer</code>呢？</p><p>如果我們希望monoid值所造成的影響愈小愈好，</p><p>那<code>mempty</code>是個合理的選擇。</p><p><code>mempty</code>是被當作identity monoid value，</p><p>像是<code>""</code>或<code>Sum 0</code>，或是空的bytestring。</p><p>當我們對<code>mempty</code>用<code>mappend</code>跟其他monoid值結合，結果會是其他的monoid值。</p><p>所以如果我們用<code>return</code>來做一個<code>Writer</code>，然後用<code>>>=</code>來餵給其他的函數，</p><p>那函數回傳的便是算出來的monoid。</p><p>下面我們試著用<code>return</code>搭配不同context來回傳<code>3</code>：</p><pre class="code">ghci> runWriter (return 3 :: Writer String Int)  
(3,"")  
ghci> runWriter (return 3 :: Writer (Sum Int) Int)  
(3,Sum {getSum = 0})  
ghci> runWriter (return 3 :: Writer (Product Int) Int)  
(3,Product {getProduct = 1})</pre><p>因為<code>Writer</code>並沒有定義成<code>Show</code>的instance，</p><p>我們必須用<code>runWriter</code>來把我們的<code>Writer</code>轉成正常的tuple。</p><p>對於<code>String</code>，monoid的值就是空字串。</p><p>而對於<code>Sum</code>來說則是<code>0</code>，因為<code>0</code>加上其他任何值都會是對方。</p><p>而對<code>Product</code>來說，則是<code>1</code>。</p><p>這裡的<code>Writer</code>instance並沒有定義<code>fail</code>，</p><p>所以如果pattern matching失敗的話，</p><p>就會呼叫<code>error</code>。</p><p><b>Using do notation with Writer</b></p><a name="Reader Monad"></a><h2>Reader Monad</h2><p>在講Applicative的章節中，我們說過了<code>(->) r</code>的型態只是<code>Functor</code>的一個instance。</p><p>要將一個函數<code>f</code>map over一個函數<code>g</code>，</p><p>基本上等價於一個函數，他可以接受原本<code>g</code>接受的參數，</p><p>先套用<code>g</code>然後再把其結果丟給<code>f</code>。</p><pre class="code">ghci> let f = (*5)  
ghci> let g = (+3)
ghci> (fmap f g) 8</pre><p>我們已經見識過函數當作applicative functors的例子。</p><p>這樣能讓我們對函數的結果直接進行操作。</p><pre class="code">ghci> let f = (+) <$> (*2) <*> (+10)
ghci> f 3
19</pre><p><code>(+) <$> (*2) <*> (+10)</code>代表一個函數，</p><p>他接受一個數值，</p><p>分別把這數值交給<code>(*2)</code>跟<code>(+10)</code>。</p><p>然後把結果加起來。</p><p>例如說，如果我們餵<code>3</code>給這個函數，</p><p>他會分別對<code>3</code>做<code>(*2)</code>跟<code>(+10)</code>的動作。</p><p>而得到<code>6</code>跟<code>13</code>。</p><p>然後呼叫<code>(+)</code>，</p><p>而得到<code>19</code>。</p><a name="State Monad"></a><h2>State Monad</h2><a name="Error Monad"></a><h2>Error Monad</h2><a name="一些實用的Moandic functions"></a><h2>一些實用的Moandic functions</h2><a name="定義自己的Monad"></a><h2>定義自己的Monad</h2>
            <ul class="nav">
                <li class="left">  <img src="img/prv.png"></img><a href="a-fistful-of-monads.html">來看看幾種Moand</a></li>
                <li class="center"><a href="chapters.html">Index</a></li>
                <li class="right"> <a href="zippers.html">Zippers資料結構</a><img src="img/nxt.png"></img></li>
            </ul>
        </div>
        <div id="footer">
        </div>
    </body>
</html>
