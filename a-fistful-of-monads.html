<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
        <style>
            @import url(css/style.css);
            @import url(css/feedback.css);
        </style>
        <script src="js/jquery.js"></script>
        <script src="js/jquery.chili-2.2.js"></script>
        <script src="js/script.js"></script>
        <script src="js/html2canvas.js"></script>
        <script src="js/jsfeedback.js"></script>
        <script>
             ChiliBook.recipeFolder = "js/chili/";  
             ChiliBook.automaticSelector = "pre";
        </script>
        <script>
            $(function(){
                $('#feedback').click(function(){
                    $('body').feedback();
                })
            });
        </script>
        <script type="text/javascript">
            var _gaq = _gaq || [];
            _gaq.push(['_setAccount', 'UA-32830659-1']);
            _gaq.push(['_trackPageview']);

            (function() {
                var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
                ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
                    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
            })();
        </script>
        <title>來看看幾種Monad</title>
    </head>
    <body>
        <div id="header">
            <img id="beta" alt="beta" src="img/beta.png" />
        </div>

        <div id="main">
            <ul class="nav">
                <li class="left">  <img src="img/prv.png"></img><a href="functors-applicative-functors-and-monoids.html">Functors, Applicative Functors與Monoids</a></li>
                <li class="center"><a href="chapters.html">Index</a></li>
                <li class="right"> <a href="for-a-few-monads-more.html">再來看看更多Monad</a><img src="img/nxt.png"></img></li>
            </ul>
            <a name="來看看幾種Monad"></a><h1>來看看幾種Monad</h1><p>當我們第一次談到Functor的時候，我們了解到他是一個抽象概念，代表是一種可以被map over的值。然後我們再將其概念提升到Applicative Functor，他代表一種帶有context的型態，我們可以用函數操作他而且同時還保有他的context。</p><p>在這一章，我們會學到Monad，基本上他是一種加強版的Applicative Functor，正如Applicative Functor是Functor的加強版一樣。</p><p>我們介紹到Functor是因為我們觀察到有許多型態都可以被function給map over，了解到這個目的，便抽象化了<code>Functor</code>這個typeclass出來。但這讓我們想問：如果給定一個<code>a -> b</code>的函數以及<code>f a</code>的型態，我們要如何將函數map over這個型態而得到<code>f b</code>？我們知道要如何map over<code>Maybe a</code>，<code>[a]</code>以及<code>IO a</code>。我們甚至還知道如何用<code>a -> b</code>map over<code>r -> a</code>，並且會得到<code>r -> b</code>。要回答這個問題，我們只需要看<code>fmap</code>的型態就好了：</p><pre class="code">fmap :: (Functor f) => (a -> b) -> f a -> f b</pre><p>然後只要針對<code>Functor</code>instance撰寫對應的實做。</p><p>之後我們又看到一些可以針對Functor改進的地方，例如<code>a -> b</code>也被包在一個Functor value裡面呢？像是<code>Just (*3)</code>，我們要如何apply<code>Just 5</code>給他？如果我們不要apply<code>Just 5</code>而是<code>Nothing</code>呢？甚至給定<code>[(*2),(+4)]</code>，我們要如何apply他們到<code>[1,2,3]</code>呢？對於此，我們抽象出<code>Applicative</code>typeclass，這就是我們想要問的問題：</p><pre class="code">(<*>) :: (Applicative f) => f (a -> b) -> f a -> f b</pre><p>我們也看到我們可以將一個正常的值包在一個資料型態中。例如說我們可以拿一個<code>1</code>然後把他包成<code>Just 1</code>。或是把他包成<code>[1]</code>。也可以是一個I/O action會產生一個<code>1</code>。這樣包裝的function我們叫他做<code>pure</code>。</p><p>如我們說得，一個applicative value可以被看作一個有附加context的值。例如說，<code>'a'</code>只是一個普通的字元，但<code>Just 'a'</code>是一個附加了context的字元。他不是<code>Char</code>而是<code>Maybe Char</code>，這型態告訴我們這個值可能是一個字元，也可能什麼都沒有。</p><p>來看看<code>Applicative</code>typeclass怎樣讓我們用普通的function操作他們，同時還保有context：</p><pre class="code">ghci> (*) <$> Just 2 <*> Just 8  
Just 16  
ghci> (++) <$> Just "klingon" <*> Nothing  
Nothing  
ghci> (-) <$> [3,4] <*> [1,2,3]  
[2,1,0,3,2,1]</pre><p>所以我們可以視他們為aaplicative values，<code>Maybe a</code>代表可能會失敗的computation，<code>[a]</code>代表同時有好多結果的computation (non-deterministic computation)，而<code>IO a</code>代表會有side-effects的computation。</p><p>Monad是一個從Applicative functors很自然的一個演進結果。對於他們我們主要考量的點是：如果你有一個具有context的值<code>m a</code>，你能如何把他丟進一個只接受普通值<code>a</code>的函數中，並回傳一個具有context的值？也就是說，你如何套用一個型態為<code>a -> m b</code>的函數至<code>m a</code>？基本上，我們要求的函數是：</p><pre class="code">(>>=) :: (Monad m) => m a -> (a -> m b) -> m b</pre><p>如果我們有一個漂亮的值跟一個函數接受普通的值但回傳漂亮的值，那我們要如何要把漂亮的值丟進函數中？這就是我們使用Monad時所要考量的事情。我們不寫成<code>f a</code>而寫成<code>m a</code>是因為<code>m</code>代表的是<code>Monad</code>，但monad不過就是支援<code>>>=</code>操作的applicative functors。<code>>>=</code>我們稱呼他為bind。</p><p>當我們有一個普通值<code>a</code>跟一個普通函數<code>a -> b</code>，要套用函數是一件很簡單的事。但當你在處理具有context的值時，就需要多考慮些東西，要如何把漂亮的值餵進函數中，並如何考慮他們的行為，但你將會了解到他們其實不難。</p><a name="動手做做看: Maybe Monad"></a><h2>動手做做看: Maybe Monad</h2><p>現在對於什麼是Monad已經有了些模糊的概念，</p><p>我們來看看要如何讓這概念更具體一些。</p><p>不意外地，<code>Maybe</code>是一個Monad，</p><p>所以讓我們對於他多探討些，看看是否能跟我們所知的Monad概念結合起來。</p><blockquote><p>到這邊要確定你了解什麼是Applicatives。如果你知道好幾種<code>Applicative</code>的instance還有他們代表的意含就更好了，因為monad不過就是對applicative的概念進行一次升級。</p></blockquote><p>一個<code>Maybe a</code>型態的值代表型態為<code>a</code>的值而且具備一個可能造成錯誤的context。而<code>Just "dharma"</code>的值代表他不是一個<code>"dharma"</code>的字串就是字串不見時的<code>Nothing</code>。如果你把字串當作計算的結果，<code>Nothing</code>就代表計算失敗了。</p><p>當我們把<code>Maybe</code>視作functor，我們其實要的是一個<code>fmap</code>來把一個函數針對其中的元素做套用。他會對<code>Just</code>中的元素進行套用，要不然就是保留<code>Nothing</code>的狀態，其代表裡面根本沒有元素。</p><pre class="code">ghci> fmap (++"!") (Just "wisdom")  
Just "wisdom!"  
ghci> fmap (++"!") Nothing  
Nothing</pre><p>或者視為一個applicative functor，他也有類似的作用。只是applicative也把函數包了起來。<code>Maybe</code>作為一個applicative functor，我們能用<code><*></code>來套用一個存在<code>Maybe</code>中的函數至包在另外一個<code>Maybe</code>中的值。他們都必須是包在<code>Just</code>來代表值存在，要不然其實就是<code>Nothing</code>。當你在想套用函數到值上面的時候，缺少了函數或是值都會造成錯誤，所以這樣做是很合理的。</p><pre class="code">ghci> Just (+3) <*> Just 3  
Just 6  
ghci> Nothing <*> Just "greed"  
Nothing  
ghci> Just ord <*> Nothing  
Nothing</pre><p>當我們用applicative的方式套用函數至<code>Maybe</code>型態的值時，就跟上面描述的差不多。過程中所有值都必須是<code>Just</code>，要不然結果一定會是<code>Nothing</code>。</p><pre class="code">ghci> max <$> Just 3 <*> Just 6  
Just 6  
ghci> max <$> Just 3 <*> Nothing  
Nothing</pre><p>我們來思考一下要怎麼為<code>Maybe</code>實作<code>>>=</code>。正如我們之前提到的，<code>>>=</code>接受一個monadic value，以及一個接受普通值的函數，這函數會回傳一個monadic value。<code>>>=</code>會幫我們套用這個函數到這個monadic value。在函數只接受普通值的情況俠，函數是如何作到這件事的呢？要作到這件事，他必須要考慮到monadic value的context。</p><p>在這個案例中，<code>>>=</code>會接受一個<code>Maybe a</code>以及一個型態為<code>a -> Maybe b</code>的函數。他會套用函數到<code>Maybe a</code>。要釐清他怎麼作到的，首先我們注意到<code>Maybe</code>的applicative functor特性。假設我們有一個函數<code>\x -> Just (x+1)</code>。他接受一個數字，把他加<code>1</code>後再包回<code>Just</code>。</p><pre class="code">ghci> (\x -> Just (x+1)) 1  
Just 2  
ghci> (\x -> Just (x+1)) 100  
Just 101</pre><p>如果我們餵給函數<code>1</code>，他會計算成<code>Just 2</code>。如果我們餵給函數<code>100</code>，那結果便是<code>Just 101</code>。但假如我們餵一個<code>Maybe</code>的值給函數呢？如果我們把<code>Maybe</code>想成一個applicative functor，那答案便很清楚。如果我們拿到一個<code>Just</code>，就把包在<code>Just</code>裡面的值餵給函數。如果我們拿到一個<code>Nothing</code>，我們就說結果是<code>Nothing</code>。</p><p>我們呼叫<code>applyMaybe</code>而不呼叫<code>>>=</code>。他接受<code>Maybe a</code>跟一個回傳<code>Maybe b</code>的函數，並套用函數至<code>Maybe a</code>。</p><pre class="code">applyMaybe :: Maybe a -> (a -> Maybe b) -> Maybe b  
applyMaybe Nothing f  = Nothing  
applyMaybe (Just x) f = f x</pre><p>我們套用一個infix函數，這樣<code>Maybe</code>的值可以寫在左邊且函數是在右邊：</p><pre class="code">ghci> Just 3 `applyMaybe` \x -> Just (x+1)  
Just 4  
ghci> Just "smile" `applyMaybe` \x -> Just (x ++ " :")""  
Just "smile :""  
ghci> Nothing `applyMaybe` \x -> Just (x+1)  
Nothing  
ghci> Nothing `applyMaybe` \x -> Just (x ++ " :")")  
Nothing</pre><p>在上述的範例中，我們看到在套用<code>applyMaybe</code>的時候，函數是套用在<code>Just</code>裡面的值。當我們試圖套用到<code>Nothing</code>，那整個結果便是<code>Nothing</code>。假如函數回傳<code>Nothing</code>呢？</p><pre class="code">ghci> Just 3 `applyMaybe` \x -> if x > 2 then Just x else Nothing  
Just 3  
ghci> Just 1 `applyMaybe` \x -> if x > 2 then Just x else Nothing  
Nothing</pre><p>這正是我們期待的結果。如果左邊的monadic value是<code>Nothing</code>，那整個結果就是<code>Nothing</code>。如果右邊的函數是<code>Nothing</code>，那結果也會是<code>Nothing</code>。這跟我們之前把<code>Maybe</code>當作aaplicative時，過程中有任何一個<code>Nothing</code>整個結果就會是<code>Nothing</code>一樣。</p><p>對於<code>Maybe</code>而言，我們已經找到一個方法處理漂亮值的方式。我們作到這件事的同時，也保留了<code>Maybe</code>代表可能造成錯誤的計算的意義。</p><p>你可能會問，這樣的結果有用嗎？由於applicative functors讓我們可以拿一個接受普通值的函數，並讓他可以操作具有context的值，這樣看起來applicative functors好像比monad強。但我們會看到monad也能作到，因為他只是applicative functors的升級版。他們同時也能作到applicative functors不能作到的事情。</p><p>稍候我們會再繼續探討<code>Maybe</code>，但我們先來看看monad的type class。</p><a name="Monad type class"></a><h2>Monad type class</h2><p>正如functors有<code>Functor</code>這個type class，而applicative functors有一個<code>Applicative</code>這個type class，monad也有他自己的type class：<code>Monad</code>他看起來像這樣：</p><pre class="code">class Monad m where  
    return :: a -> m a  

    (>>=) :: m a -> (a -> m b) -> m b  

    (>>) :: m a -> m b -> m b  
    x >> y = x >>= \_ -> y  

    fail :: String -> m a  
    fail msg = error msg</pre><p>我們從第一行開始看。他說<code>class Monad m where</code>。但我們之前不是提到monad是applicative functors的加強版嗎？不是應該有一個限制說一個型態必須先是一個applicative functor才可能是一個monad嗎？像是<code>class (Applicative m) = > Monad m where</code>。他的確應該要有，但當Haskell被創造的早期，人們沒有想到applicative functor適合被放進語言中，所以最後沒有這個限制。但的確每個monad都是applicative functor，即使<code>Monad</code>並沒有這麼宣告。</p><p>在<code>Monad</code>typeclass中定義的第一個函數是<code>return</code>。</p><p>他其實等價於<code>pure</code>，只是名字不同罷了。</p><p>他的型態是<code>(Monad m) => a -> m a</code>。</p><p>他接受一個普通值並把他放進一個最小的context中。</p><p>也就是說他把普通值包進一個monad裡面。</p><p>他跟<code>Applicative</code>裡面<code>pure</code>函數做的事情一樣，</p><p>所以說其實我們已經認識了<code>return</code>。</p><p>我們已經用過<code>return</code>來處理一些I/O。</p><p>我們用他來做一些假的I/O，印出一些值。</p><p>對於<code>Maybe</code>來說他就是接受一個普通值然後包進<code>Just</code>。</p><blockquote><p>提醒一下：<code>return</code>跟其他語言中的<code>return</code>是完全不一樣的。他並不是結束一個函數的執行，他只不過是把一個普通值包進一個context裡面。</p></blockquote><p>接下來定義的函數是bind:<code>>>=</code>。他就像是函數套用一樣，只差在他不接受普通值，他是接受一個monadic value（也就是具有context的值）並且把他餵給一個接受普通值得函數，並回傳一個monadic value。</p><p>接下來，我們定義了<code>>></code>。我們不會介紹他，因為他有一個事先定義好的實作，基本上我們在實作<code>Monad</code>typeclass的時候都不會去理他。</p><p>最後一個函數是<code>fail</code>。我們通常在我們程式中不會具體寫出來。他是被Haskell用在處理語法錯誤的情況。我們目前不需要太在意<code>fail</code>。</p><p>我們知道了<code>Monad</code>typeclass長什麼樣子，我們來看一下<code>Maybe</code>的<code>Monad</code>instance。</p><pre class="code">ghci> return "WHAT" :: Maybe String  
Just "WHAT"  
ghci> Just 9 >>= \x -> return (x*10)  
Just 90  
ghci> Nothing >>= \x -> return (x*10)  
Nothing</pre><p>第一行沒什麼了不起，我們已經知道<code>return</code>就是<code>pure</code>而我們又對<code>Maybe</code>操作過<code>pure</code>了。至於下兩行就比較有趣點。</p><p>留意我們是如何把<code>Just 9</code>餵給<code>\x -> return (x*10)</code>。在函數中<code>x</code>綁定到<code>9</code>。他看起好像我們能不用pattern matching的方式就從<code>Maybe</code>中抽取出值。但我們並沒有喪失掉<code>Maybe</code>的context，當他是<code>Nothing</code>的時候，<code>>>=</code>的結果也會是<code>Nothing</code>。</p><a name="走鋼索"></a><h2>走鋼索</h2><p>我們已經知道要如何把<code>Maybe a</code>餵進<code>a -> Maybe b</code>這樣的函數。我們可以看看我們如何重複使用<code>>>=</code>來處理多個<code>Maybe a</code>的值。</p><p>首先來說個小故事。</p><p>皮爾斯決定要辭掉他的工作改行試著走鋼索。</p><p>他對走鋼索蠻在行的，不過仍有個小問題。</p><p>就是鳥會停在他拿的平衡竿上。</p><p>他們會飛過來停一小會兒，然後再飛走。</p><p>這樣的情況在兩邊的鳥的數量一樣時並不是個太大的問題。</p><p>但有時候，所有的鳥都會想要停在同一邊，皮爾斯就失去了平衡，</p><p>就會讓他從鋼索上掉下去。</p><p>我們這邊假設兩邊的鳥差異在三個之內的時候，皮爾斯仍能保持平衡。</p><p>所以如果是右邊有一隻，左邊有四隻的話，那還撐得住。</p><p>但如果左邊有五隻，那就會失去平衡。</p><p>我們要寫個程式來模擬整個情況。</p><p>我們想看看皮爾斯究竟在好幾隻鳥來來去去後是否還能撐住。</p><p>例如說，我們想看看先來了一隻鳥停在左邊，然後來了四隻停在右邊，</p><p>然後左邊那隻飛走了。之後會是什麼情形。</p><p>我們用一對整數來代表我們的平衡竿狀態。</p><p>頭一個位置代表左邊的鳥的數量，第二個位置代表右邊的鳥的數量。</p><pre class="code">{
type Birds = Int  
type Pole = (Birds,Birds)  
}</pre><p>由於我們用整數來代表有多少隻鳥，我們便先來定義<code>Int</code>的同義型態，叫做<code>Birds</code>。</p><p>然後我們把<code>(Birds, Birds)</code>定義成<code>Pole</code>。</p><p>接下來，我們定義一個函數他接受一個數字，然後把他放在竿子的左邊，</p><p>還有另外一個函數放在右邊。</p><pre class="code">{
landLeft :: Birds -> Pole -> Pole  
landLeft n (left,right) = (left + n,right)  
  
landRight :: Birds -> Pole -> Pole  
landRight n (left,right) = (left,right + n)  
}</pre><p>我們來試著執行看看：</p><pre class="code">{
ghci> landLeft 2 (0,0)  
(2,0)  
ghci> landRight 1 (1,2)  
(1,3)  
ghci> landRight (-1) (1,2)  
(1,1)  
}</pre><p>要模擬鳥飛走的話我們只要給定一個負數就好了。</p><p>由於這些操作是接受<code>Pole</code>並回傳<code>Pole</code>，</p><p>所以我們可以把函數串在一起。</p><pre class="code">{
ghci> landLeft 2 (landRight 1 (landLeft 1 (0,0)))  
(3,1)
}</pre><p>當我們餵<code>(0,0)</code>給<code>landLeft 1</code>時，我們會得到<code>(1,0)</code>。</p><p>接著我們模擬右邊又停了一隻鳥，狀態就變成<code>(1,1)</code>。</p><p>最後又有兩隻鳥停在左邊，狀態變成<code>(3,1)</code>。</p><p>我們這邊的寫法是先寫函數名稱，然後再套用參數。</p><p>但如果先寫pole再寫函數名稱會比較清楚，</p><p>所以我們會想定義一個函數</p><pre class="code">{
x -: f = f x
}</pre><p>我們能先套用參數然後再寫函數名稱：</p><pre class="code">{
ghci> 100 -: (*3)  
300  
ghci> True -: not  
False  
ghci> (0,0) -: landLeft 2  
(2,0)  
}</pre><p>有了這個函數，我們便能寫得比較好讀一些：</p><pre class="code">{
ghci> (0,0) -: landLeft 1 -: landRight 1 -: landLeft 2  
(3,1)  
}</pre><p>這個範例跟先前的範例是等價的，只不過好讀許多。</p><p>很清楚的看出我們是從<code>(0,0)</code>開始，然後停了一隻在左邊，接著右邊又有一隻，</p><p>最後左邊多了兩隻。</p><p>到目前為止沒什麼問題，</p><p>但如果我們要停10隻在左邊呢？</p><pre class="code">{ 
ghci> landLeft 10 (0,3)  
(10,3)  
}</pre><p>你說左邊有10隻右邊卻只有3隻？那不是早就應該掉下去了？</p><p>這個例子太明顯了，如果換個比較不明顯的例子。</p><pre class="code">{
ghci> (0,0) -: landLeft 1 -: landRight 4 -: landLeft (-1) -: landRight (-2)  
(0,2)  
}</pre><p>表面看起來沒什麼問題，但如果你仔細看的話，有一瞬間是右邊有四隻，但左邊沒有鳥。</p><p>要修正這個錯誤，我們要重新檢視<code>landLeft</code>跟<code>landRight</code>。</p><p>我們其實是希望這些函數產生失敗的情況。</p><p>那就是在維持平衡的時候回傳新的pole，但失敗的時候告訴我們失敗了。</p><p>這時候<code>Maybe</code>就剛剛好是我們要的context了。</p><p>我們用<code>Maybe</code>重新寫一次：</p><pre class="code">{
landLeft :: Birds -> Pole -> Maybe Pole  
landLeft n (left,right)  
    | abs ((left + n) - right) < 4 = Just (left + n, right)  
    | otherwise                    = Nothing  
          
landRight :: Birds -> Pole -> Maybe Pole  
landRight n (left,right)  
    | abs (left - (right + n)) < 4 = Just (left, right + n)  
    | otherwise                    = Nothing  
}</pre><p>現在這些函數不回傳<code>Pole</code>而回傳<code>Maybe Pole</code>了。</p><p>他們仍接受鳥的數量跟舊的的pole，</p><p>但他們現在會檢查是否有太多鳥會造成皮爾斯失去平衡。</p><p>我們用guards來檢查是否有差異超過三的情況。</p><p>如果沒有，那就包一個在<code>Just</code>中的新的pole，</p><p>如果是，那就回傳<code>Nothing</code>。</p><p>再來執行看看：</p><pre class="code">{
ghci> landLeft 2 (0,0)  
Just (2,0)  
ghci> landLeft 10 (0,3)  
Nothing  
}</pre><p>一如預期，當皮爾斯不會掉下去的時候，我們就得到一個包在<code>Just</code>中的新pole。</p><p>當太多鳥停在同一邊的時候，我們就會拿到<code>Nothing</code>。</p><p>這樣很棒，但我們卻不知道怎麼把東西串在一起了。</p><p>我們不能做<code>landLeft 1 (landRight 1 (0,0))</code>，</p><p>因為當我們對<code>(0,0)</code>使用<code>landRight 1</code>時，我們不是拿到<code>Pole</code>而是拿到<code>Maybe Pole</code>。</p><p><code>landLeft 1</code>會拿到<code>Pole</code>而不是拿到<code>Maybe Pole</code>。</p><p>我們需要一種方法可以把拿到的<code>Maybe Pole</code>塞到拿<code>Pole</code>的函數中，然後回傳<code>Maybe Pole</code>。</p><p>而我們有<code>>>=</code>，他對<code>Maybe</code>做的事就是我們要的</p><pre class="code">{
ghci> landRight 1 (0,0) >>= landLeft 2  
Just (2,1)  
}</pre><p><code>landLeft 2的型態是</code>Pole -> Maybe Pole。</p><p>我們不能餵給他<code>Maybe Pole</code>的東西。</p><p>而<code>landRight 1 (0,0)</code>的結果就是<code>Maybe Pole</code>，</p><p>所以我們用<code>>>=</code>來接受一個有context的值然後拿給<code>landLeft 2</code>。</p><p><code>>>=</code>的確讓我們把<code>Maybe</code>當作有context的值，</p><p>因為當我們丟<code>Nothing</code>給<code>landLeft 2</code>的時候，結果會是<code>Nothing</code>。</p><pre class="code">{ 
ghci> Nothing >>= landLeft 2  
Nothing  
}</pre><p>這樣我們可以把這些新寫的用<code>>>=</code>串在一起。</p><p>讓monadic value可以餵進只吃普通值的函數。</p><p>來看看些例子：</p><pre class="code">{
ghci> return (0,0) >>= landRight 2 >>= landLeft 2 >>= landRight 2  
Just (2,4)  
}</pre><a name="do表示法"></a><h2>do表示法</h2><a name="List Monad"></a><h2>List Monad</h2><a name="Monad laws (單子律)"></a><h2>Monad laws (單子律)</h2>
            <ul class="nav">
                <li class="left">  <img src="img/prv.png"></img><a href="functors-applicative-functors-and-monoids.html">Functors, Applicative Functors與Monoids</a></li>
                <li class="center"><a href="chapters.html">Index</a></li>
                <li class="right"> <a href="for-a-few-monads-more.html">再來看看更多Monad</a><img src="img/nxt.png"></img></li>
            </ul>
        </div>
        <div id="footer">
        </div>
        <div id="feedback">Send feedback</div>
    </body>
</html>
