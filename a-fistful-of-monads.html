<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
        <style>
            @import url(css/style.css);
            @import url(css/feedback.css);
        </style>
        <script src="js/jquery.js"></script>
        <script src="js/jquery.chili-2.2.js"></script>
        <script src="js/script.js"></script>
        <script src="js/html2canvas.js"></script>
        <script src="js/jsfeedback.js"></script>
        <script>
             ChiliBook.recipeFolder = "js/chili/";  
             ChiliBook.automaticSelector = "pre";
        </script>
        <script>
            $(function(){
                $('#feedback').click(function(){
                    $('body').feedback();
                })
            });
        </script>
        <script type="text/javascript">
            var _gaq = _gaq || [];
            _gaq.push(['_setAccount', 'UA-32830659-1']);
            _gaq.push(['_trackPageview']);

            (function() {
                var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
                ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
                    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
            })();
        </script>
        <title>來看看幾種Monad</title>
    </head>
    <body>
        <div id="header">
            <img id="beta" alt="beta" src="img/beta.png" />
        </div>

        <div id="main">
            <ul class="nav">
                <li class="left">  <img src="img/prv.png"></img><a href="functors-applicative-functors-and-monoids.html">Functors, Applicative Functors與Monoids</a></li>
                <li class="center"><a href="chapters.html">Index</a></li>
                <li class="right"> <a href="for-a-few-monads-more.html">再來看看更多Monad</a><img src="img/nxt.png"></img></li>
            </ul>
            <a name="來看看幾種Monad"></a><h1>來看看幾種Monad</h1><p>當我們第一次談到Functor的時候，我們了解到他是一個抽象概念，代表是一種可以被map over的值。然後我們再將其概念提升到Applicative Functor，他代表一種帶有context的型態，我們可以用函數操作他而且同時還保有他的context。</p><p>在這一章，我們會學到Monad，基本上他是一種加強版的Applicative Functor，正如Applicative Functor是Functor的加強版一樣。</p><p>我們介紹到Functor是因為我們觀察到有許多型態都可以被function給map over，了解到這個目的，便抽象化了<code>Functor</code>這個typeclass出來。但這讓我們想問：如果給定一個<code>a -> b</code>的函數以及<code>f a</code>的型態，我們要如何將函數map over這個型態而得到<code>f b</code>？我們知道要如何map over<code>Maybe a</code>，<code>[a]</code>以及<code>IO a</code>。我們甚至還知道如何用<code>a -> b</code>map over<code>r -> a</code>，並且會得到<code>r -> b</code>。要回答這個問題，我們只需要看<code>fmap</code>的型態就好了：</p><pre class="code">fmap :: (Functor f) => (a -> b) -> f a -> f b</pre><p>然後只要針對<code>Functor</code>instance撰寫對應的實做。</p><p>之後我們又看到一些可以針對Functor改進的地方，例如<code>a -> b</code>也被包在一個Functor value裡面呢？像是<code>Just (*3)</code>，我們要如何apply<code>Just 5</code>給他？如果我們不要apply<code>Just 5</code>而是<code>Nothing</code>呢？甚至給定<code>[(*2),(+4)]</code>，我們要如何apply他們到<code>[1,2,3]</code>呢？對於此，我們抽象出<code>Applicative</code>typeclass，這就是我們想要問的問題：</p><pre class="code">(<*>) :: (Applicative f) => f (a -> b) -> f a -> f b</pre><p>我們也看到我們可以將一個正常的值包在一個資料型態中。例如說我們可以拿一個<code>1</code>然後把他包成<code>Just 1</code>。或是把他包成<code>[1]</code>。也可以是一個I/O action會產生一個<code>1</code>。這樣包裝的function我們叫他做<code>pure</code>。</p><p>如我們說得，一個applicative value可以被看作一個有附加context的值。例如說，<code>'a'</code>只是一個普通的字元，但<code>Just 'a'</code>是一個附加了context的字元。他不是<code>Char</code>而是<code>Maybe Char</code>，這型態告訴我們這個值可能是一個字元，也可能什麼都沒有。</p><p>來看看<code>Applicative</code>typeclass怎樣讓我們用普通的function操作他們，同時還保有context：</p><pre class="code">ghci> (*) <$> Just 2 <*> Just 8  
Just 16  
ghci> (++) <$> Just "klingon" <*> Nothing  
Nothing  
ghci> (-) <$> [3,4] <*> [1,2,3]  
[2,1,0,3,2,1]</pre><p>所以我們可以視他們為aaplicative values，<code>Maybe a</code>代表可能會失敗的computation，<code>[a]</code>代表同時有好多結果的computation (non-deterministic computation)，而<code>IO a</code>代表會有side-effects的computation。</p><p>Monad是一個從Applicative functors很自然的一個演進結果。對於他們我們主要考量的點是：如果你有一個具有context的值<code>m a</code>，你能如何把他丟進一個只接受普通值<code>a</code>的函數中，並回傳一個具有context的值？也就是說，你如何套用一個型態為<code>a -> m b</code>的函數至<code>m a</code>？基本上，我們要求的函數是：</p><pre class="code">(>>=) :: (Monad m) => m a -> (a -> m b) -> m b</pre><p>如果我們有一個漂亮的值跟一個函數接受普通的值但回傳漂亮的值，那我們要如何要把漂亮的值丟進函數中？這就是我們使用Monad時所要考量的事情。我們不寫成<code>f a</code>而寫成<code>m a</code>是因為<code>m</code>代表的是<code>Monad</code>，但monad不過就是支援<code>>>=</code>操作的applicative functors。<code>>>=</code>我們稱呼他為bind。</p><p>當我們有一個普通值<code>a</code>跟一個普通函數<code>a -> b</code>，要套用函數是一件很簡單的事。但當你在處理具有context的值時，就需要多考慮些東西，要如何把漂亮的值餵進函數中，並如何考慮他們的行為，但你將會了解到他們其實不難。</p><a name="動手做做看: Maybe Monad"></a><h2>動手做做看: Maybe Monad</h2><p>現在對於什麼是Monad已經有了些模糊的概念，</p><p>我們來看看要如何讓這概念更具體一些。</p><p>不意外地，<code>Maybe</code>是一個Monad，</p><p>所以讓我們對於他多探討些，看看是否能跟我們所知的Monad概念結合起來。</p><blockquote><p>到這邊要確定你了解什麼是Applicatives。如果你知道好幾種<code>Applicative</code>的instance還有他們代表的意含就更好了，因為monad不過就是對applicative的概念進行一次升級。</p></blockquote><p>一個<code>Maybe a</code>型態的值代表型態為<code>a</code>的值而且具備一個可能造成錯誤的context。而<code>Just "dharma"</code>的值代表他不是一個<code>"dharma"</code>的字串就是字串不見時的<code>Nothing</code>。如果你把字串當作計算的結果，<code>Nothing</code>就代表計算失敗了。</p><p>當我們把<code>Maybe</code>視作functor，我們其實要的是一個<code>fmap</code>來把一個函數針對其中的元素做套用。他會對<code>Just</code>中的元素進行套用，要不然就是保留<code>Nothing</code>的狀態，其代表裡面根本沒有元素。</p><pre class="code">ghci> fmap (++"!") (Just "wisdom")  
Just "wisdom!"  
ghci> fmap (++"!") Nothing  
Nothing</pre><p>或者視為一個applicative functor，他也有類似的作用。只是applicative也把函數包了起來。<code>Maybe</code>作為一個applicative functor，我們能用<code><*></code>來套用一個存在<code>Maybe</code>中的函數至包在另外一個<code>Maybe</code>中的值。他們都必須是包在<code>Just</code>來代表值存在，要不然其實就是<code>Nothing</code>。當你在想套用函數到值上面的時候，缺少了函數或是值都會造成錯誤，所以這樣做是很合理的。</p><pre class="code">ghci> Just (+3) <*> Just 3  
Just 6  
ghci> Nothing <*> Just "greed"  
Nothing  
ghci> Just ord <*> Nothing  
Nothing</pre><p>當我們用applicative的方式套用函數至<code>Maybe</code>型態的值時，就跟上面描述的差不多。過程中所有值都必須是<code>Just</code>，要不然結果一定會是<code>Nothing</code>。</p><pre class="code">ghci> max <$> Just 3 <*> Just 6  
Just 6  
ghci> max <$> Just 3 <*> Nothing  
Nothing</pre><p>我們來思考一下要怎麼為<code>Maybe</code>實作<code>>>=</code>。正如我們之前提到的，<code>>>=</code>接受一個monadic value，以及一個接受普通值的函數，這函數會回傳一個monadic value。<code>>>=</code>會幫我們套用這個函數到這個monadic value。在函數只接受普通值的情況俠，函數是如何作到這件事的呢？要作到這件事，他必須要考慮到monadic value的context。</p><p>在這個案例中，<code>>>=</code>會接受一個<code>Maybe a</code>以及一個型態為<code>a -> Maybe b</code>的函數。他會套用函數到<code>Maybe a</code>。要釐清他怎麼作到的，首先我們注意到<code>Maybe</code>的applicative functor特性。假設我們有一個函數<code>\x -> Just (x+1)</code>。他接受一個數字，把他加<code>1</code>後再包回<code>Just</code>。</p><pre class="code">ghci> (\x -> Just (x+1)) 1  
Just 2  
ghci> (\x -> Just (x+1)) 100  
Just 101</pre><p>如果我們餵給函數<code>1</code>，他會計算成<code>Just 2</code>。如果我們餵給函數<code>100</code>，那結果便是<code>Just 101</code>。但假如我們餵一個<code>Maybe</code>的值給函數呢？如果我們把<code>Maybe</code>想成一個applicative functor，那答案便很清楚。如果我們拿到一個<code>Just</code>，就把包在<code>Just</code>裡面的值餵給函數。如果我們拿到一個<code>Nothing</code>，我們就說結果是<code>Nothing</code>。</p><p>我們呼叫<code>applyMaybe</code>而不呼叫<code>>>=</code>。他接受<code>Maybe a</code>跟一個回傳<code>Maybe b</code>的函數，並套用函數至<code>Maybe a</code>。</p><pre class="code">applyMaybe :: Maybe a -> (a -> Maybe b) -> Maybe b  
applyMaybe Nothing f  = Nothing  
applyMaybe (Just x) f = f x</pre><p>我們套用一個infix函數，這樣<code>Maybe</code>的值可以寫在左邊且函數是在右邊：</p><pre class="code">ghci> Just 3 `applyMaybe` \x -> Just (x+1)  
Just 4  
ghci> Just "smile" `applyMaybe` \x -> Just (x ++ " :")""  
Just "smile :""  
ghci> Nothing `applyMaybe` \x -> Just (x+1)  
Nothing  
ghci> Nothing `applyMaybe` \x -> Just (x ++ " :")")  
Nothing</pre><p>在上述的範例中，我們看到在套用<code>applyMaybe</code>的時候，函數是套用在<code>Just</code>裡面的值。當我們試圖套用到<code>Nothing</code>，那整個結果便是<code>Nothing</code>。假如函數回傳<code>Nothing</code>呢？</p><pre class="code">ghci> Just 3 `applyMaybe` \x -> if x > 2 then Just x else Nothing  
Just 3  
ghci> Just 1 `applyMaybe` \x -> if x > 2 then Just x else Nothing  
Nothing</pre><p>這正是我們期待的結果。如果左邊的monadic value是<code>Nothing</code>，那整個結果就是<code>Nothing</code>。如果右邊的函數是<code>Nothing</code>，那結果也會是<code>Nothing</code>。這跟我們之前把<code>Maybe</code>當作aaplicative時，過程中有任何一個<code>Nothing</code>整個結果就會是<code>Nothing</code>一樣。</p><p>對於<code>Maybe</code>而言，我們已經找到一個方法處理漂亮值的方式。我們作到這件事的同時，也保留了<code>Maybe</code>代表可能造成錯誤的計算的意義。</p><p>你可能會問，這樣的結果有用嗎？由於applicative functors讓我們可以拿一個接受普通值的函數，並讓他可以操作具有context的值，這樣看起來applicative functors好像比monad強。但我們會看到monad也能作到，因為他只是applicative functors的升級版。他們同時也能作到applicative functors不能作到的事情。</p><p>稍候我們會再繼續探討<code>Maybe</code>，但我們先來看看monad的type class。</p><a name="Monad type class"></a><h2>Monad type class</h2><p>正如functors有<code>Functor</code>這個type class，而applicative functors有一個<code>Applicative</code>這個type class，monad也有他自己的type class：<code>Monad</code>他看起來像這樣：</p><pre class="code">class Monad m where  
    return :: a -> m a  

    (>>=) :: m a -> (a -> m b) -> m b  

    (>>) :: m a -> m b -> m b  
    x >> y = x >>= \_ -> y  

    fail :: String -> m a  
    fail msg = error msg</pre><p>我們從第一行開始看。他說<code>class Monad m where</code>。但我們之前不是提到monad是applicative functors的加強版嗎？不是應該有一個限制說一個型態必須先是一個applicative functor才可能是一個monad嗎？像是<code>class (Applicative m) = > Monad m where</code>。他的確應該要有，但當Haskell被創造的早期，人們沒有想到applicative functor適合被放進語言中，所以最後沒有這個限制。但的確每個monad都是applicative functor，即使<code>Monad</code>並沒有這麼宣告。</p><a name="走鋼索"></a><h2>走鋼索</h2><a name="do表示法"></a><h2>do表示法</h2><a name="List Monad"></a><h2>List Monad</h2><a name="Monad laws (單子律)"></a><h2>Monad laws (單子律)</h2>
            <ul class="nav">
                <li class="left">  <img src="img/prv.png"></img><a href="functors-applicative-functors-and-monoids.html">Functors, Applicative Functors與Monoids</a></li>
                <li class="center"><a href="chapters.html">Index</a></li>
                <li class="right"> <a href="for-a-few-monads-more.html">再來看看更多Monad</a><img src="img/nxt.png"></img></li>
            </ul>
        </div>
        <div id="footer">
        </div>
        <div id="feedback">Send feedback</div>
    </body>
</html>
