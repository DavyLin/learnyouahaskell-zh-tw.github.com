<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
        <style>
            @import url(/css/style.css);
            @import url(/css/feedback.css);
        </style>
        <script src="/js/jquery.js"></script>
        <script src="/js/jquery.chili-2.2.js"></script>
        <script src="/js/script.js"></script>
        <script src="/js/html2canvas.js"></script>
        <script src="/js/jsfeedback.js"></script>
        <script>
             ChiliBook.recipeFolder = "/js/chili/";  
             ChiliBook.automaticSelector = "pre";
        </script>
        <script>
            $(function(){
                $('#feedback').click(function(){
                    $('body').feedback();
                })
            });
        </script>
        <script type="text/javascript">
            var _gaq = _gaq || [];
            _gaq.push(['_setAccount', 'UA-32830659-1']);
            _gaq.push(['_trackPageview']);

            (function() {
                var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
                ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
                    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
            })();
        </script>
        <title>Functors, Applicative Functors与Monoids</title>
    </head>
    <body>
        <div id="header">
            <img id="beta" alt="beta" src="/img/beta.png" />
        </div>

        <div id="main">
            <ul class="nav">
                <li class="left">  <img src="/img/prv.png"></img><a href="functionally-solving-problems.html">函数式地思考来解决问题</a></li>
                <li class="center"><a href="chapters.html">Index</a></li>
                <li class="right"> <a href="a-fistful-of-monads.html">来看看几种Monad</a><img src="/img/nxt.png"></img></li>
            </ul>
            <a name="Functors, Applicative Functors与Monoids"></a><h1>Functors, Applicative Functors与Monoids</h1><p>Haskell的一些特色，像是纯粹性，高端函数，algebraic data types，typeclasses，这些让我们可以从更高的角度来看到polymorphism这件事。不像OOP当中需要从庞大的型态阶层来思考。我们只需要看看手边的型态的行为，将他们跟适当地typeclass对应起来就可以了。像<code>Int</code>的行为跟很多东西很像。好比说他可以比较相不相等，可以从大到小排列，也可以将他们一一穷举出来。</p><p>Typeclass的运用是很随意的。我们可以定义自己的数据型态，然后描述他可以怎样被操作，跟typeclass关联起来便定义了他的行为。由于Haskell强大的型态系统，这让我们只要读函数的型态宣告就可以知道很多信息。typeclass可以定义得很抽象很general。我们之前有看过typeclass定义了可以比较两个东西是否相等，或是定义了可以比较两个东西的大小。这些是既抽象但又描述简洁的行为，但我们不会认为他们有什么特别之处，因为我们时常碰到他们。最近我们看过了functor，基本上他们是一群可以被map over的对象。这是其中一个例子能够抽象但又漂亮地描述行为。在这一章中，我们会详加阐述functors，并会提到比较强一些的版本，也就是applicative functors。我们也会提到monoids。</p><a name="温习Functors"></a><h2>温习Functors</h2><img src="/img/frogtor.png" style="float:right"></img><p>我们已经在之前的章节提到functors。如果你还没读那个章节，也许你应该先去看看。或是你直接假装你已经读过了。</p><p>来快速复习一下：Functors是可以被map over的对象，像是lists，<code>Maybe</code>，trees等等。在Haskell中我们是用<code>Functor</code>这个typeclass来描述他。这个typeclass只有一个method，叫做<code>fmap</code>，他的型态是<code>fmap :: (a -> b) ->  fa -> f b</code>。这型态说明了如果给我一个从<code>a</code>映到<code>b</code>的函数，以及一个装了<code>a</code>的盒子，我会回给你一个装了<code>b</code>的盒子。就好像用这个函数将每个元素都转成<code>b</code>一样</p><blockquote><p><b>给一点建议</b>。这盒子的比喻尝试让你抓到些functors是如何运作的感觉。在之后我们也会用相同的比喻来比喻applicative functors跟monads。在多数情况下这种比喻是恰当的，但不要过度引申，有些functors是不适用这个比喻的。一个比较正确的形容是functors是一个计算语境(computational context)。这个语境可能是这个computation可能带有值，或是有可能会失败(像<code>Maybe</code>跟<code>Either a</code>)，或是他可能有多个值(像lists)，等等。</p></blockquote><p>如果一个type constructor要是<code>Functor</code>的instance，那他的kind必须是<code>* -> *</code>，这代表他必须刚好接受一个type当作type parameter。像是<code>Maybe</code>可以是Functor的一个instance，因为他接受一个type parameter，来做成像是<code>Maybe Int</code>，或是<code>Maybe String</code>。如果一个type constructor接受两个参数，像是<code>Either</code>，我们必须给他两个type parameter。所以我们不能这样写：<code>instance Functor Either where</code>，但我们可以写<code>instance Functor (Either a) where</code>，如果我们把<code>fmap</code>限缩成只是<code>Either a</code>的，那他的型态就是<code>fmap :: (b -> c) -> Either a b -> Either a c</code>。就像你看到的，<code>Either a</code>的是固定的一部分，因为<code>Either a</code>只恰好接受一个type parameter，但<code>Either</code>则要接球两个type parameters。这样fmap的型态变成<code>fmap :: (b -> c) -> Either b -> Either c</code>，这不太合理。</p><p>我们知道有许多态态都是<code>Functor</code>的instance，像是<code>[]</code>，<code>Maybe</code>，<code>Either a</code>以及我们自己写的<code>Tree</code>。我们也看到了如何用一个函数map他们。在这一章节，我们再多举两个例子，也就是<code>IO</code>跟<code>(->) r</code>。</p><p>如果一个值的型态是<code>IO String</code>，他代表的是一个会被计算成String结果的I/O action。我们可以用do syntax来把结果绑定到某个名称。我们之前把I/O action比喻做长了脚的盒子，会到真实世界帮我们取一些值回来。我们可以查看他们取了什么值，但一旦看过，我们必须要把值放回盒子中。用这个比喻，<code>IO</code>的行为就像是一个functor。</p><p>我们来看看<code>IO</code>是怎么样的一个<code>Functor</code>instance。当我们<code>fmap</code>用一个function来map over I/O action时，我们会想要拿回一个装着已经用function映射过值的I/O action。</p><pre class="code">instance Functor IO where
    fmap f action = do
        result <- action
        return (f result)</pre><p>对一个I/O action做map over动作的结果仍会是一个I/O action，所以我们才用do syntax来把两个I/O action黏成一个。在<code>fmap</code>的实做中，我们先执行了原本传进的I/O action，并把结果绑定成<code>result</code>。然后我们写了<code>return (f result)</code>。<code>return</code>就如你所知道的，是一个只会回传包了你传给他东西的I/O action。还有一个do block的回传值一定是他最后一个I/O action的回传值。这也是为什么我们需要return。其实他只是回传包了<code>f result</code>的I/O action。</p><p>我们可以再多实验一下来找到些感觉。来看看这段code：</p><pre class="code">main = do line <- getLine   
        let line' = reverse line  
        putStrLn $ "You said " ++ line' ++ " backwards!"  
        putStrLn $ "Yes, you really said" ++ line' ++ " backwards!"</pre><p>这程序要求用户输入一行文本，然后印出一行反过来的。</p><p>我们可以用<code>fmap</code>来改写：</p><pre class="code">main = do line <- fmap reverse getLine  
            putStrLn $ "You said " ++ line ++ " backwards!"  
            putStrLn $ "Yes, you really said" ++ line ++ " backwards!"</pre><img src="/img/alien.png" style="float:left"></img><p>就像我们用<code>fmap</code><code>reverse</code>来map over<code>Just "blah"</code>会得到<code>Just "halb"</code>，我们也可以<code>fmap</code><code>reverse</code>来map over<code>getLine</code>。<code>getLine</code>是一个I/O action，他的type是<code>IO String</code>，而用<code>reverse</code>来map over他会回传一个取回一个字串并<code>reverse</code>他的I/O action。就像我们apply一个function到一个<code>Maybe</code>一样，我们也可以apply一个function到一个<code>IO</code>，只是这个<code>IO</code>会跑去外面拿回某些值。然后我们把结果用<code><-</code>绑定到某个名称，而这个名称绑定的值是已经<code>reverse</code>过了。</p><p>而<code>fmap (++"!") getLine</code>这个I/O action表现得就像<code>getLine</code>，只是他的结果多了一个<code>"!"</code>在最后。</p><p>如果我们限缩<code>fmap</code>到<code>IO</code>型态上，那fmap的型态是<code>fmap :: (a -> b) -> IO a -> IO b</code>。<code>fmap</code>接受一个函数跟一个I/O action，并回传一个I/O action包含了已经apply过function的结果。</p><p>如果你曾经注意到你想要将一个I/O action绑定到一个名称上，只是为了要apply一个function。你可以考虑使用<code>fmap</code>，那会更漂亮地表达这件事。或者你想要对functor中的数据做transformation，你可以先将你要用的function写在top level，或是把他作成一个lambda function，甚至用function composition。</p><pre class="code">import Data.Char  
import Data.List  
  
main = do line <- fmap (intersperse '-' . reverse . map toUpper) getLine  
        putStrLn line</pre><pre class="code">$ runhaskell fmapping_io.hs  
hello there  
E-R-E-H-T- -O-L-L-E-H</pre><p>正如你想的，<code>intersperse '-' . reverse . map toUpper</code>合成了一个function，他接受一个字串，将他转成大写，然后反过来，再用<code>intersperse '-'</code>安插'-'。他是比较漂亮版本的<code>(\xs -> intersperse '-' (reverse (map toUpper xs)))</code>。</p><p>另一个<code>Functor</code>的案例是<code>(->) r</code>，只是我们先前没有注意到。你可能会困惑到底<code>(->) r</code>究竟代表什么？一个<code>r -> a</code>的型态可以写成<code>(->) r a</code>，就像是<code>2 + 3</code>可以写成<code>(+) 2 3</code>一样。我们可以从一个不同的角度来看待<code>(->) r a</code>，他其实只是一个接受两个参数的type constructor，好比<code>Either</code>。但记住我们说过<code>Functor</code>只能接受一个type constructor。这也是为什么<code>(->)</code>不是<code>Functor</code>的一个instance，但<code>(->) r</code>则是。如果程序的语法允许的话，你也可以将<code>(->) r</code>写成(r ->)。就如<code>(2+)</code>代表的其实是<code>(+) 2</code>。至于细节是如何呢？我们可以看看<code>Control.Monad.Instances</code>。</p><blockquote><p>我们通常说一个接受任何东西以及回传随便一个东西的函数型态是<code>a -> b</code>。<code>r -> a</code>是同样意思，只是把符号代换了一下。</p></blockquote><pre class="code">instance Functor ((->) r) where  
    fmap f g = (\x -> f (g x))</pre><p>如果语法允许的话，他可以被写成</p><pre class="code">instance Functor (r ->) where  
    fmap f g = (\x -> f (g x))</pre><p>但其实是不允许的，所以我们必须写成第一种的样子。</p><p>首先我们来看看<code>fmap</code>的型态。他的型态是<code>fmap :: (a -> b) -> f a -> f b</code>。我们把所有的<code>f</code>在心里代换成<code>(->) r</code>。则<code>fmap</code>的型态就变成<code>fmap :: (a -> b) -> ((->) r a) -> ((->) r b)</code>。接着我们把<code>(->) r a</code>跟<code>(->) r b</code>换成<code>r -> a</code>跟<code>r -> b</code>。则我们得到<code>fmap :: (a -> b) -> (r -> a) -> (r -> b)</code>。</p><p>从上面的结果看到将一个function map over一个function会得到另一个function，就如map over一个function到<code>Maybe</code>会得到一个<code>Maybe</code>，而map over一个function到一个list会得到一个list。而<code>fmap :: (a -> b) -> (r -> a) -> (r -> b)</code>告诉我们什么？他接受一个从<code>a</code>到<code>b</code>的function，跟一个从<code>r</code>到<code>a</code>的function，并回传一个从<code>r</code>到<code>b</code>的function。这根本就是function composition。把<code>r -> a</code>的输出接到<code>a -> b</code>的输入，的确是function composition在做的事。如果你再仔细看看instance的定义，会发现真的就是一个function composition。</p><pre class="code">instance Functor ((->) r) where  
    fmap = (.)</pre><p>这很明显就是把<code>fmap</code>当composition在用。可以用<code>:m + Control.Monad.Instances</code>把模块装载进来，并做一些尝试。</p><pre class="code">ghci> :t fmap (*3) (+100)  
fmap (*3) (+100) :: (Num a) => a -> a  
ghci> fmap (*3) (+100) 1  
303  
ghci> (*3) `fmap` (+100) $ 1  
303  
ghci> (*3) . (+100) $ 1  
303  
ghci> fmap (show . (*3)) (*100) 1  
"300"</pre><p>我们调用<code>fmap</code>的方式是infix的方式，这跟<code>.</code>很像。在第二行，我们把<code>(*3)</code>map over到<code>(+100)</code>上，这会回传一个先把输入值<code>(+100)</code>再<code>(*3)</code>的function，我们再用<code>1</code>去调用他。</p><p>到这边为止盒子的比喻还适用吗？如果你硬是要解释的话还是解释得通。当我们将<code>fmap (+3)</code>map over<code>Just 3</code>的时候，对于<code>Maybe</code>我们很容易把他想成是装了值的盒子，我们只是对盒子里面的值<code>(+3)</code>。但对于<code>fmap (*3) (+100)</code>呢？你可以把<code>(+100)</code>想成是一个装了值的盒子。有点像把I/O action想成长了脚的盒子一样。对<code>(+100)</code>使用<code>fmap (*3)</code>会产生另一个表现得像<code>(+100)</code>的function。只是在算出值之前，会再多计算<code>(*3)</code>。这样我们可以看出来<code>fmap</code>表现得就像<code>.</code>一样。</p><p><code>fmap</code>等同于function composition这件事对我们来说并不是很实用，但至少是一个有趣的观点。这也让我们打开视野，看到盒子的比喻不是那么恰当，functors其实比较像computation。function被map over到一个computation会产生经由那个function映射过后的computation。</p><img src="/img/lifter.png" style="float:right"></img><p>在我们继续看<code>fmap</code>该遵守的规则之前，我们再看一次<code>fmap</code>的型态，他是<code>fmap :: (a -> b) -> f a -> f b</code>。很明显我们是在讨论Functor，所以为了简洁，我们就不写<code>(Functor f) =></code>的部份。当我们在学curry的时候，我们说过Haskell的function实际上只接受一个参数。一个型态是<code>a -> b -> c</code>的函数实际上是接受<code>a</code>然后回传<code>b -> c</code>，而<code>b -> c</code>实际上接受一个<code>b</code>然后回传一个<code>c</code>。如果我们用比较少的参数调用一个函数，他就会回传一个函数需要接受剩下的参数。所以<code>a -> b -> c</code>可以写成<code>a -> (b -> c)</code>。这样curry可以明显一些。</p><p>同样的，我们可以不要把<code>fmap</code>想成是一个接受function跟functor并回传一个function的function。而是想成一个接受function并回传一个新的function的function，回传的function接受一个functor并回传一个functor。他接受<code>a -> b</code>并回传<code>f a -> f b</code>。这动作叫做lifting。我们用GHCI的<code>:t</code>来做的实验。</p><pre class="code">ghci> :t fmap (*2)  
fmap (*2) :: (Num a, Functor f) => f a -> f a  
ghci> :t fmap (replicate 3)  
fmap (replicate 3) :: (Functor f) => f a -> f [a]</pre><p><code>fmap (*2)</code>接受一个functor<code>f</code>，并回传一个基于数字的functor。那个functor可以是list，可以是<code>Maybe</code>，可以是<code>Either String</code>。<code>fmap (replicate 3)</code>可以接受一个基于任何型态的functor，并回传一个基于list的functor。</p><blockquote><p>当我们提到functor over numbers的时候，你可以想像他是一个functor包含有许多数字在里面。前面一种说法其实比较正确，但后面一种说法比较容易让人理解。</p></blockquote><p>这样的观察在我们只有绑定一个部份套用的函数，像是<code>fmap (++"!")</code>，的时候会显得更清楚，</p><p>你可以把<code>fmap</code>想做是一个函数，他接受另一个函数跟一个functor，然后把函数对functor每一个元素做映射，或你可以想做他是一个函数，他接受一个函数并把他lift到可以在functors上面操作。两种想法都是正确的，而且在Haskell中是等价。</p><p><code>fmap (replicate 3) :: (Functor f) => f a -> f [a]</code>这样的型态代表这个函数可以运作在任何functor上。至于确切的行为则要看究竟我们操作的是什么样的functor。如果我们是用<code>fmap (replicate 3)</code>对一个list操作，那我们会选择<code>fmap</code>针对list的实作，也就是只是一个<code>map</code>。如果我们是碰到<code>Maybe a</code>。那他在碰到<code>Just</code>型态的时候，会对里面的值套用<code>replicate 3</code>。而碰到<code>Nothing</code>的时候就回传<code>Nothing</code>。</p><pre class="code">ghci> fmap (replicate 3) [1,2,3,4]  
[[1,1,1],[2,2,2],[3,3,3],[4,4,4]]  
ghci> fmap (replicate 3) (Just 4)  
Just [4,4,4]  
ghci> fmap (replicate 3) (Right "blah")  
Right ["blah","blah","blah"]  
ghci> fmap (replicate 3) Nothing  
Nothing  
ghci> fmap (replicate 3) (Left "foo")  
Left "foo"</pre><p>接下来我们来看看functor laws。一个东西要成为functor，必须要遵守某些定律。不管任何一个functor都被要求具有某些性质。他们必须是能被map over的。对他们调用<code>fmap</code>应该是要用一个函数map每一个元素，不多做任何事情。这些行为都被functor laws所描述。对于<code>Functor</code>的instance来说，总共两条定律应该被遵守。不过他们不会在Haskell中自动被检查，所以你必须自己确认这些条件。</p><p>functor law的第一条说明，如果我们对functor做map<code>id</code>，那得到的新的functor应该要跟原来的一样。如果写得正式一点，他代表<code>fmap id = id</code>。基本上他就是说对functor调用<code>fmap id</code>，应该等同于对functor调用<code>id</code>一样。毕竟<code>id</code>只是identity function，他只会把参数照原样丢出。他也可以被写成<code>\x -> x</code>。如果我们对functor的概念就是可以被map over的对象，那<code>fmap id = id</code>的性就显而易见。</p><p>我们来看看这个定律的几个案例：</p><pre class="code">ghci> fmap id (Just 3)  
Just 3  
ghci> id (Just 3)  
Just 3  
ghci> fmap id [1..5]  
[1,2,3,4,5]  
ghci> id [1..5]  
[1,2,3,4,5]  
ghci> fmap id []  
[]  
ghci> fmap id Nothing  
Nothing</pre><p>如果我们看看<code>Maybe</code>的<code>fmap</code>的实作，我们不难发现第一定律为何被遵守。</p><pre class="code">instance Functor Maybe where  
    fmap f (Just x) = Just (f x)  
    fmap f Nothing = Nothing</pre><p>我们可以想像在<code>f</code>的位置摆上<code>id</code>。我们看到<code>fmap id</code>拿到<code>Just x</code>的时候，结果只不过是<code>Just (id x)</code>，而<code>id</code>有只回传他拿到的东西，所以可以知道<code>Just (id x)</code>等价于<code>Just x</code>。所以说我们可以知道对<code>Maybe</code>中的<code>Just</code>用<code>id</code>去做map over的动作，会拿回一样的值。</p><p>而将<code>id</code>map over<code>Nothing</code>会拿回<code>Nothing</code>并不稀奇。所以从这两个<code>fmap</code>的实作，我们可以看到的确<code>fmap id = id</code>有被遵守。</p><img src="/img/justice.png" style="float:left"></img><p>第二定律描述说先将两个函数合成并将结果map over一个functor的结果，应该跟先将第一个函数map over一个functor，再将第二个函数map over那个functor的结果是一样的。正式地写下来的话就是<code>fmap (f . g) = fmap f . fmap g</code>。或是用另外一种写法，对于任何一个functor F，下面这个式子应该要被遵守：<code>fmap (f . g) F = fmap f (fmap g F)</code>v</p><p>如果我们能够证明某个型别遵守两个定律，那我们就可以保证他跟其他functor对于映射方面都拥有相同的性质。我们知道如果对他用<code>fmap</code>，我们知道不会有除了mapping以外的事会发生，而他就仅仅会表现成某个可以被map over的东西。也就是一个functor。你可以再仔细查看<code>fmap</code>对于某些型别的实作来了解第二定律。正如我们先前对<code>Maybe</code>查看第一定律一般。</p><p>如果你需要的话，我们能在这边演练一下<code>Maybe</code>是如何遵守第二定律的。首先<code>fmap (f . g)</code>来map over<code>Nothing</code>的话，我们会得到<code>Nothing</code>。因为用任何函数来<code>fmap</code><code>Nothing</code>的话都会回传<code>Nothing</code>。如果我们<code>fmap f (fmap g Nothing)</code>，我们会得到<code>Nothing</code>。可以看到当面对<code>Nothing</code>的时候，<code>Maybe</code>很显然是遵守第二定律的。</p><p>那对于<code>Just something</code>呢？如果我们使用<code>fmap (f . g) (Just x)</code>的话，从实作的代码中我可以看到<code>Just ((f . g ) x)</code>，也就是<code>Just (f (g x))</code>。如果我们使用<code>fmap f (fmap g (Just x))</code>的话我们可以从实作知道<code>fmap g (Just x)</code>会是<code>Just (g x)</code>。<code>fmap f (fmap g (Just x))</code>跟<code>fmap f (Just (g x))</code>相等。而从实作上这又会相等于<code>Just (f (g x))</code>。</p><p>如果你不太理解这边的说明，别担心。只要确定你了解什么是函数合成就好。在多数的情况下你可以直觉地对应到这些型别表现得就像containers或函数一样。或是也可以换种方法，只要多尝试对型别中不同的值做操作你就可以看看型别是否有遵守定律。</p><p>我们来看一些经典的例子。这些型别建构子虽然是<code>Functor</code>的instance，但实际上他们并不是functor，因为他们并不遵守这些定律。我们来看看其中一个型别。</p><pre class="code">data CMaybe a = CNothing | CJust Int a deriving (Show)</pre><p>C这边代表的是计数器。他是一种看起来像是<code>Maybe a</code>的型别，只差在<code>Just</code>包含了两个field而不是一个。在<code>CJust</code>中的第一个field是<code>Int</code>，他是扮演计数器用的。而第二个field则为型别<code>a</code>，他是从型别参数来的，而他确切的型别当然会依据我们选定的<code>CMaybe a</code>而定。我们来对他作些操作来获得些操作上的直觉吧。</p><pre class="code">ghci> CNothing  
CNothing  
ghci> CJust 0 "haha"  
CJust 0 "haha"  
ghci> :t CNothing  
CNothing :: CMaybe a  
ghci> :t CJust 0 "haha"  
CJust 0 "haha" :: CMaybe [Char]  
ghci> CJust 100 [1,2,3]  
CJust 100 [1,2,3]</pre><p>如果我们使用<code>CNothing</code>，就代表不含有field。如果我们用的是<code>CJust</code>，那第一个field是整数，而第二个field可以为任何型别。我们来定义一个<code>Functor</code>的instance，这样每次我们使用<code>fmap</code>的时候，函数会被套用在第二个field，而第一个field会被加一。</p><pre class="code">instance Functor CMaybe where  
    fmap f CNothing = CNothing  
    fmap f (CJust counter x) = CJust (counter+1) (f x)</pre><p>这种定义方式有点像是<code>Maybe</code>的定义方式，只差在当我们使用<code>fmap</code>的时候，如果碰到的不是空值，那我们不只会套用函数，还会把计数器加一。我们可以来看一些范例操作。</p><pre class="code">ghci> fmap (++"ha") (CJust 0 "ho")  
CJust 1 "hoha"  
ghci> fmap (++"he") (fmap (++"ha") (CJust 0 "ho"))  
CJust 2 "hohahe"  
ghci> fmap (++"blah") CNothing  
CNothing</pre><p>这些会遵守functor laws吗？要知道有不遵守的情形，只要找到一个反例就好了。</p><pre class="code">ghci> fmap id (CJust 0 "haha")  
CJust 1 "haha"  
ghci> id (CJust 0 "haha")  
CJust 0 "haha"</pre><p>我们知道functor law的第一定律描述当我们用<code>id</code>来map over一个functor的时候，他的结果应该跟只对functor调用<code>id</code>的结果一样。但我们可以看到这个例子中，这对于<code>CMaybe</code>并不遵守。尽管他的确是<code>Functor</code>typeclass的一个instace。但他并不遵守functor law因此不是一个functor。如果有人使用我们的<code>CMaybe</code>型别，把他当作functor用，那他就会期待functor laws会被遵守。但<code>CMaybe</code>并没办法满足，便会造成错误的程序。当我们使用一个functor的时候，函数合成跟map over的先后顺序不应该有影响。但对于<code>CMaybe</code>他是有影响的，因为他纪录了被map over的次数。如果我们希望<code>CMaybe</code>遵守functor law，我们必须要让<code>Int</code>字段在做<code>fmap</code>的时候维持不变。</p><p>乍看之下functor laws看起来不是很必要，也容易让人搞不懂，但我们知道如果一个型别遵守functor laws，那我们就能对他作些基本的假设。如果遵守了functor laws，我们知道对他做<code>fmap</code>不会做多余的事情，只是用一个函数做映射而已。这让写出来的代码足够抽象也容易扩展。因为我们可以用定律来推论型别的行为。</p><p>所有在标准函式库中的<code>Functor</code>的instance都遵守这些定律，但你可以自己检查一遍。下一次你定义一个型别为<code>Functor</code>的instance的时候，花点时间确认他确实遵守functor laws。一旦你操作过足够多的functors时，你就会获得直觉，知道他们会有什么样的性质跟行为。而且functor laws也会觉得显而易见。但就算没有这些直觉，你仍然可以一行一行地来找看看有没有反例让这些定律失效。</p><p>我们可以把functor看作输出具有context的值。例如说<code>Just 3</code>就是输出<code>3</code>，但他又带有一个可能没有值的context。<code>[1,2,3]</code>输出三个值，<code>1</code>,<code>2</code>跟<code>3</code>，同时也带有可能有多个值或没有值的context。<code>(+3)</code>则会带有一个依赖于参数的context。</p><p>如果你把functor想做是输出值这件事，那你可以把map over一个functor这件事想成在functor输出的后面再多加一层转换。当我们做<code>fmap (+3) [1,2,3]</code>的时候，我们是把<code>(+3)</code>接到<code>[1,2,3]</code>后面，所以当我们查看任何一个list的输出的时候，<code>(+3)</code>也会被套用在上面。另一个例子是对函数做map over。当我们做<code>fmap (+3) (*3)</code>，我们是把<code>(+3)</code>这个转换套用在<code>(*3)</code>后面。这样想的话会很自然就会把<code>fmap</code>跟函数合成关联起来（<code>fmap (+3) (*3)</code>等价于<code>(+3) . (*3)`，也等价于</code>\x -> ((x<b>3)+3)<code>），毕竟我们是接受一个函数</code>(</b>3)<code>然后套用</code>(+3)转换。最后的结果仍然是一个函数，只是当我们喂给他一个数字的时候，他会先乘上三然后做转换加上三。这基本上就是函数合成在做的事。</p><a name="Applicative functors"></a><h2>Applicative functors</h2><img src="/img/present.png" style="float:right"></img><p>在这个章节中，我们会学到applicative functors，也就是加强版的functors，在Haskell中是用在<code>Control.Applicative</code>中的<code>Applicative</code>这个typeclass来定义的。</p><p>你还记得Haskell中函数缺省就是Curried的，那代表接受多个参数的函数实际上是接受一个参数然后回传一个接受剩余参数的函数，以此类推。如果一个函数的型别是<code>a -> b -> c</code>，我们通常会说这个函数接受两个参数并回传<code>c</code>，但他实际上是接受<code>a</code>并回传一个<code>b -> c</code>的函数。这也是为什么我们可以用<code>(f x) y</code>的方式调用<code>f x y</code>。这个机制让我们可以partially apply一个函数，可以用比较少的参数调用他们。可以做成一个函数再喂给其他函数。</p><p>到目前为止，当我们要对functor map over一个函数的时候，我们用的函数都是只接受一个参数的。但如果我们要map一个接受两个参数的函数呢？我们来看几个具体的例子。如果我们有<code>Just 3</code>然后我们做<code>fmap (*) (Just 3)</code>，那我们会获得什么样的结果？从<code>Maybe</code>对<code>Functor</code>的instance实作来看，我们知道如果他是<code>Just something</code>，他会对在<code>Just</code>中的<code>something</code>做映射。因此当<code>fmap (*) (Just 3)</code>会得到<code>Just ((*) 3)</code>，也可以写做<code>Just (* 3)</code>。我们得到了一个包在<code>Just</code>中的函数。</p><pre class="code">ghci> :t fmap (++) (Just "hey")  
fmap (++) (Just "hey") :: Maybe ([Char] -> [Char])  
ghci> :t fmap compare (Just 'a')  
fmap compare (Just 'a') :: Maybe (Char -> Ordering)  
ghci> :t fmap compare "A LIST OF CHARS"  
fmap compare "A LIST OF CHARS" :: [Char -> Ordering]  
ghci> :t fmap (\x y z -> x + y / z) [3,4,5,6]  
fmap (\x y z -> x + y / z) [3,4,5,6] :: (Fractional a) => [a -> a -> a]</pre><p>如果我们map<code>compare</code>到一个包含许多字符的list呢？他的型别是<code>(Ord a) => a -> a -> Ordering</code>，我们会得到包含许多<code>Char -> Ordering</code>型别函数的list，因为<code>compare</code>被partially apply到list中的字符。他不是包含许多<code>(Ord a) => a -> Ordering</code>的函数，因为第一个<code>a</code>碰到的型别是<code>Char</code>，所以第二个<code>a</code>也必须是<code>Char</code>。</p><p>我们看到如何用一个多参数的函数来map functor，我们会得到一个包含了函数的functor。那现在我们能对这个包含了函数的functor做什么呢？我们能用一个吃这些函数的函数来map over这个functor，这些在functor中的函数都会被当作参数丢给我们的函数。</p><pre class="code">ghci> let a = fmap (*) [1,2,3,4]  
ghci> :t a  
a :: [Integer -> Integer]  
ghci> fmap (\f -> f 9) a  
[9,18,27,36]</pre><p>但如果我们的有一个functor里面是<code>Just (3 *)</code>还有另一个functor里面是<code>Just 5</code>，但我们想要把第一个<code>Just (3 *)</code>map over<code>Just 5</code>呢？如果是普通的functor，那就没救了。因为他们只允许map一个普通的函数。即使我们用<code>\f -> f 9</code>来map一个装了很多函数的functor，我们也是使用了普通的函数。我们是无法单纯用<code>fmap</code>来把包在一个functor的函数map另一个包在functor中的值。我们能用模式匹配<code>Just</code>来把函数从里面抽出来，然后再map<code>Just 5</code>，但我们是希望有一个一般化的作法，对任何functor都有效。</p><p>我们来看看<code>Applicative</code>这个typeclass。他位在<code>Control.Applicative</code>中，在其中定义了两个函数<code>pure</code>跟<code><*></code>。他并没有提供缺省的实作，如果我们想使用他必须要为他们applicative functor的实作。typeclass定义如下：</p><pre class="code">class (Functor f) => Applicative f where  
    pure :: a -> f a  
    (<*>) :: f (a -> b) -> f a -> f b</pre><p>这简简单单的三行可以让我们学到不少。首先来看第一行。他开启了<code>Applicative</code>的定义，并加上class contraint。描述了一个型别构造子要是<code>Applicative</code>，他必须也是<code>Functor</code>。这就是为什么我们说一个型别构造子属于<code>Applicative</code>的话，他也会是<code>Functor</code>，因此我们能对他使用<code>fmap</code>。</p><p>第一个定义的是<code>pure</code>。他的型别宣告是<code>pure :: a -> f a</code>。<code>f</code>代表applicative functor的instance。由于Haskell有一个优秀的型别系统，其中函数又是将一些参数映射成结果，我们可以从型别宣告中读出许多消息。<code>pure</code>应该要接受一个值，然后回传一个包含那个值的applicative functor。我们这边是用盒子来作比喻，即使有一些比喻不完全符合现实的情况。尽管这样，<code>a -> f a</code>仍有许多丰富的信息，他确实告诉我们他会接受一个值并回传一个applicative functor，里面装有结果。</p><p>对于<code>pure</code>比较好的书法是把一个普通值放到一个缺省的context下，一个最小的context但仍然包含这个值。</p><p><code><*></code>也非常有趣。他的型别是<code>f (a -> b) -> f a -> f b</code>。这有让你联想到什么吗？没错！就是<code>fmap :: (a -> b) -> f a -> f b</code>。他有点像加强版的<code>fmap</code>。然而<code>fmap</code>接受一个函数跟一个functor，然后套用functor之中的函数。<code><*></code>则是接受一个装有函数的functor跟另一个functor，然后取出第一个functor中的函数将他对第二个functor中的值做map。</p><p>我们来看看<code>Maybe</code>的<code>Applicative</code>实作：</p><pre class="code">instance Applicative Maybe where  
    pure = Just  
    Nothing <*> _ = Nothing  
    (Just f) <*> something = fmap f something</pre><p>从class的定义我们可以看到<code>f</code>作为applicative functor会接受一个具体型别当作参数，所以我们是写成<code>instance Applicative Maybe where</code>而不是写成<code>instance Applicative (Maybe a) where</code>。</p><p>首先看到<code>pure</code>。他只不过是接受一个东西然后包成applicative functor。我们写成<code>pure = Just</code>是因为<code>Just</code>不过就是一个普通函数。我们其实也可以写成<code>pure x = Just x</code>。</p><p>接着我们定义了<code><*></code>。我们无法从<code>Nothing</code>中抽出一个涮，因为<code>Nothing</code>并不包含一个函数。所以我们说如果我们要尝试从<code>Nothing</code>中取出一个函数，结果必定是<code>Nothing</code>。如果你看看<code>Applicative</code>的定义，你会看到他有<code>Functor</code>的限制，他代表<code><*></code>的两个参数都会是functors。如果第一个参数不是<code>Nothing</code>，而是一个装了函数的<code>Just</code>，而且我们希望将这个函数对第二个参数做map。这个也考虑到第二个参数是<code>Nothing</code>的情况，因为<code>fmap</code>任何一个函数至<code>Nothing</code>会回传<code>Nothing</code>。</p><p>对于<code>Maybe</code>而言，如果左边是<code>Just</code>，那<code><*></code>会从其中抽出了一个函数来map右边的值。如果有任何一个参数是<code>Nothing</code>。那结果便是<code>Nothing</code>。</p><p>来试试看吧！</p><pre class="code">ghci> Just (+3) <*> Just 9  
Just 12  
ghci> pure (+3) <*> Just 10  
Just 13  
ghci> pure (+3) <*> Just 9  
Just 12  
ghci> Just (++"hahah") <*> Nothing  
Nothing  
ghci> Nothing <*> Just "woot"  
Nothing</pre><p>我们看到<code>pure (+3)</code>跟<code>Just (+3)</code>在这个case下是一样的。如果你是在applicative context底下跟<code>Maybe</code>打交道的话请用<code>pure</code>，要不然就用<code>Just</code>。前四个输入展示了函数是如何被取出并做map的动作，但在这个case底下，他们同样也可以用unwrap函数来map over functors。最后一行比较有趣，因为我们试着从<code>Nothing</code>取出函数并将他map到某个值。结果当然是<code>Nothing</code>。</p><p>对于普通的functors，你可以用一个函数map over一个functors，但你可能没办法拿到结果。而applicative functors则让你可以用单一一个函数操作好几个functors。看看下面一段代码：</p><pre class="code">ghci> pure (+) <*> Just 3 <*> Just 5  
Just 8  
ghci> pure (+) <*> Just 3 <*> Nothing  
Nothing  
ghci> pure (+) <*> Nothing <*> Just 5  
Nothing</pre><img src="/img/whale.png" style="float:right"></img><p>究竟我们写了些什么？我们来一步步看一下。<code><*></code>是left-associative，也就是说<code>pure (+) <*> Just 3 <*> Just 5</code>可以写成<code>(pure (+) <*> Just 3) <*> Just 5</code>。首先<code>+</code>是摆在一个functor中，在这边刚好他是一个<code>Maybe</code>。所以首先，我们有<code>pure (+)</code>，他等价于<code>Just (+)</code>。接下来由于partial application的关系，<code>Just (+) <*> Just 3</code>等价于<code>Just (3+)</code>。把一个<code>3</code>喂给<code>+</code>形成另一个只接受一个参数的函数，他的效果等于加上3。最后<code>Just (3+) <*> Just 5</code>被运算，其结果是<code>Just 8</code>。</p><p>这样很棒吧！用applicative style的方式来使用applicative functors。像是<code>pure f <*> x <*> y <*> ...</code>就让我们可以拿一个接受多个参数的函数，而且这些参数不一定是被包在functor中。就这样来套用在多个在functor context的值。这个函数可以吃任意多的参数，毕竟<code><*></code>只是做partial application而已。</p><p>如果我们考虑到<code>pure f <*> x</code>等于<code>fmap f x</code>的话，这样的用法就更方便了。这是applicative laws的其中一条。我们稍后会更仔细地查看这条定律。现在我们先依直觉来使用他。就像我们先前所说的，<code>pure</code>把一个值放进一个缺省的context中。如果我们要把一个函数放在一个缺省的context，然后把他取出并套用在放在另一个applicative functor的值。我们会做的事就是把函数map over那个applicative functor。但我们不会写成<code>pure f <*> x <*> y <*> ...</code>，而是写成<code>fmap f x <*> y <*> ...</code>。这也是为什么<code>Control.Aaplicative</code>会export一个函数<code><$></code>，他基本上就是中餟版的<code>fmap</code>。他是这么被定义的：</p><pre class="code">(<$>) :: (Functor f) => (a -> b) -> f a -> f b  
f <$> x = fmap f x</pre><blockquote><p>要记住型别变量跟参数的名字还有值绑定的名称不冲突。<code>f</code>在函数的型别宣告中是型别变量，说名<code>f</code>应该要满足<code>Functor</code>typeclass的条件。而在函数本体中的<code>f</code>则表示一个函数，我们将他map over x。我们同样用<code>f</code>来表示他们并代表他们是相同的东西。</p></blockquote><p><code><$></code>的使用显示了applicative style的好处。如果我们想要将<code>f</code>套用三个applicative functor。我们可以写成<code>f <$> x <*> y <*> z</code>。如果参数不是applicative functor而是普通值的话。我们则写成<code>f x y z</code>。</p><p>我们再仔细看看他是如何运作的。我们有一个<code>Just "johntra"</code>跟<code>Just "volta"</code>这样的值，我们希望将他们结合成一个<code>String</code>，并且包含在<code>Maybe</code>中。我们会这样做：</p><pre class="code">ghci> (++) <$> Just "johntra" <*> Just "volta"  
Just "johntravolta"</pre><p>可以将上面的跟下面这行比较一下：</p><pre class="code">ghci> (++) "johntra" "volta"  
"johntravolta"</pre><p>可以将一个普通的函数套用在applicative functor上真不错。只要稍微写一些<code><$></code>跟<code><*></code>就可以把函数变成applicative style，可以操作applicatives并回传applicatives。</p><p>总之当我们在做<code>(++) <$> Just "johntra" <*> Just "volta"</code>时，首先我们将<code>(++)</code>map over到<code>Just "johntra"</code>，然后产生<code>Just ("johntra"++)</code>，其中<code>(++)</code>的型别为<code>(++) :: [a] -> [a] -> [a]</code>，<code>Just ("johntra"++)</code>的型别为<code>Maybe ([Char] -> [Char])</code>。注意到<code>(++)</code>是如何吃掉第一个参数，以及我们是怎么决定<code>a</code>是<code>Char</code>的。当我们做<code>Just ("johntra"++) <*> Just "volta"</code>，他接受一个包在<code>Just</code>中的函数，然后map over<code>Just "volta"</code>，产生了<code>Just "johntravolta"</code>。如果两个值中有任意一个为<code>Nothing</code>，那整个结果就会是<code>Nothing</code>。</p><p>到目前为止我们只有用<code>Maybe</code>当作我们的案例，你可能也会想说applicative functor差不多就等于<code>Maybe</code>。不过其实有许多其他<code>Applicative</code>的instance。我们来看看有哪些。</p><p>List也是applicative functor。很惊讶吗？来看看我们是怎么定义<code>[]</code>为<code>Applicative</code>的instance的。</p><pre class="code">instance Applicative [] where  
    pure x = [x]  
    fs <*> xs = [f x | f <- fs, x <- xs]</pre><p>早先我们说过<code>pure</code>是把一个值放进缺省的context中。换种说法就是一个会产生那个值的最小context。而对list而言最小context就是<code>[]</code>，但由于空的list并不包含一个值，所以我们没办法把他当作<code>pure</code>。这也是为什么<code>pure</code>其实是接受一个值然后回传一个包含单元素的list。同样的，<code>Maybe</code>的最小context是<code>Nothing</code>，但他其实表示的是没有值。所以<code>pure</code>其实是被实作成<code>Just</code>的。</p><pre class="code">ghci> pure "Hey" :: [String]  
["Hey"]  
ghci> pure "Hey" :: Maybe String  
Just "Hey"</pre><p>至于<code><*></code>呢？如果我们假定<code><*></code>的型别是限制在list上的话，我们会得到<code>(<*>) :: [a -> b] -> [a] -> [b]</code>。他是用list comprehension来实作的。<code><*></code>必须要从左边的参数取出函数，将他map over右边的参数。但左边的list有可能不包含任何函数，也可能包含一个函数，甚至是多个函数。而右边的list有可能包含多个值。这也是为什么我们用list comprehension的方式来从两个list取值。我们要对左右任意的组合都做套用的动作。而得到的结果就会是左右两者任意组合的结果。</p><pre class="code">ghci> [(*0),(+100),(^2)] <*> [1,2,3]  
[0,0,0,101,102,103,1,4,9]</pre><p>左边的list包含三个函数，而右边的list有三个值。所以结果会是有九个元素的list。在左边list中的每一个函数都被套用到右边的值。如果我们今天在list中的函数是接收两个参数的，我们也可以套用到两个list上。</p><pre class="code">ghci> [(+),(*)] <*> [1,2] <*> [3,4]  
[4,5,5,6,3,4,6,8]</pre><p>由于<code><*></code>是left-associative，也就是说<code>[(+),(*)] <*> [1,2]</code>会先运作，产生<code>[(1+),(2+),(1*),(2*)]</code>。由于左边的每一个函数都套用至右边的每一个值。也就产生<code>[(1+),(2+),(1*),(2*)] <*> [3,4]</code>，其便是最终结果。</p><p>list的applicative style是相当有趣的：</p><pre class="code">ghci> (++) <$> ["ha","heh","hmm"] <*> ["?","!","."]  
["ha?","ha!","ha.","heh?","heh!","heh.","hmm?","hmm!","hmm."]</pre><p>看看我们是如何将一个接受两个字串参数的函数套用到两个applicative functor上的，只要用适当的applicative运算子就可以达成。</p><p>你可以将list看作是一个non-deterministic的计算。而对于像<code>100</code>或是<code>"what"</code>这样的值则是deterministic的计算，只会有一个结果。而<code>[1,2,3]</code>则可以看作是没有确定究竟是哪一种结果。所以他代表的是所有可能的结果。当你在做<code>(+) <$> [1,2,3] <*> [4,5,6]</code>，你可以想做是是把两个non-deterministic的计算做<code>+</code>，只是他会产生另一个non-deterministic的计算，而且结果更加不确定。</p><p>Applicative style对于list而言是一个取代list comprehension的好方式。在第二章中，我们想要看到<code>[2,5,10]</code>跟<code>[8,10,11]</code>相乘的结果，所以我们这样做：</p><pre class="code">ghci> [ x*y | x <- [2,5,10], y <- [8,10,11]]     
[16,20,22,40,50,55,80,100,110]</pre><p>我们只是从两个list中取出元素，并将一个函数套用在任何元素的组合上。这也可以用applicative style的方式来写：</p><pre class="code">ghci> (*) <$> [2,5,10] <*> [8,10,11]  
[16,20,22,40,50,55,80,100,110]</pre><p>这写法对我来说比较清楚。可以清楚表达我们是要对两个non-deterministic的计算做<code>*</code>。如果我们想要所有相乘大于50可能的计算结果，我们会这样写：</p><pre class="code">ghci> filter (>50) $ (*) <$> [2,5,10] <*> [8,10,11]  
[55,80,100,110]</pre><p>很容易看到<code>pure f <*> xs</code>等价于<code>fmap f xs</code>。而<code>pure f</code>就是<code>[f]</code>，而且<code>[f] <*> xs</code>可将左边的每个函数套用至右边的每个值。但左边其实只有一个函数，所以他做起来就像是mapping。</p><p>另一个我们已经看过的<code>Applicative</code>的instnace是<code>IO</code>，来看看他是怎么实作的：</p><pre class="code">instance Applicative IO where  
    pure = return  
    a <*> b = do  
        f <- a  
        x <- b  
        return (f x)</pre><img src="/img/knight.png" style="float:left"></img><p>由于<code>pure</code>是把一个值放进最小的context中，所以将<code>return</code>定义成<code>pure</code>是很合理的。因为<code>return</code>也是做同样的事情。他做了一个不做任何事情的I/O action，他可以产生某些值来作为结果，但他实际上并没有做任何I/O的动作，例如说印出结果到终端或是文件。</p><p>如果<code><*></code>被限定在<code>IO</code>上操作的话，他的型别会是<code>(<*>) :: IO (a -> b) -> IO a -> IO b</code>。他接受一个产生函数的I/O action，还有另一个I/O action，并从以上两者创造一个新的I/O action，也就是把第二个参数喂给第一个参数。而得到回传的结果，然后放到新的I/O action中。我们用do的语法来实作他。你还记得的话do就是把好几个I/O action黏在一起，变成一个大的I/O action。</p><p>而对于<code>Maybe</code>跟<code>[]</code>而言，我们可以把<code><*></code>想做是从左边的参数取出一个函数，然后套用到右边的参数上。至于<code>IO</code>，这种取出的模拟方式仍然适用，但我们必须多加一个sequencing的概念，因为我们是从两个I/O action中取值，也是在sequencing，把他们黏成一个。我们从第一个I/O action中取值，但要取出I/O action的结果，他必须要先被执行过。</p><p>考虑下面这个范例：</p><pre class="code">myAction :: IO String  
myAction = do  
    a <- getLine  
    b <- getLine  
    return $ a ++ b</pre><p>这是一个提示用户输入两行并产生将两行输入串接在一起结果的一个I/O action。我们先把两个<code>getLine</code>黏在一起，然后用一个<code>return</code>，这是因为我们想要这个黏成的I/O action包含<code>a ++ b</code>的结果。我们也可以用applicative style的方式来描述：</p><pre class="code">myAction :: IO String  
myAction = (++) <$> getLine <*> getLine</pre><p>我们先前的作法是将两个I/O action的结果喂给函数。还记得<code>getLine</code>的型别是<code>getLine :: IO String</code>。当我们对applicative functor使用<code><*></code>的时候，结果也会是applicative functor。</p><p>如果我们再使用盒子的模拟，我们可以把<code>getLine</code>想做是一个去真实世界中拿取字串的盒子。而<code>(++) <$> getLine <*> getLine</code>会创造一个比较大的盒子，这个大盒子会派两个盒子去终端拿取字串，并把结果串接起来放进自己的盒子中。</p><p><code>(++) <$> getLine <*> getLine</code>的型别是<code>IO String</code>，他代表这个表达式式一个再普通不过的I/O action，他里面也装着某种值。这也是为什么我们可以这样写：</p><pre class="code">main = do  
    a <- (++) <$> getLine <*> getLine  
    putStrLn $ "The two lines concatenated turn out to be: " ++ a</pre><p>如果你发现你是在做binding I/O action的动作，而且在binding之后还调用一些函数，最后用<code>return</code>来将结果包起来。</p><p>那你可以考虑使用applicative style，这样可以更简洁。</p><p>另一个<code>Applicative</code>的instance是<code>(->) r</code>。虽然他们通常是用在code golf的情况，但他们还是十分有趣的例子。所以我们还是来看一下他们是怎么被实做的。</p><p>如果你忘记<code>(->) r</code>的意思，回去翻翻前一章节我们介绍<code>(->) r</code>作为一个functor的范例。</p><pre class="code">instance Applicative ((->) r) where  
    pure x = (\_ -> x)  
    f <*> g = \x -> f x (g x)</pre><p>当我们用<code>pure</code>将一个值包成applicative functor的时候，他产生的结果永远都会是那个值。也就是最小的context。那夜市为什么对于function的<code>pure</code>实做来讲，他就是接受一个值，然后造一个函数永远回传那个值，不管他被喂了什么参数。如果你限定<code>pure</code>的型别至<code>(->) r</code>上，他就会是<code>pure :: a -> (r -> a)</code>。</p><pre class="code">ghci> (pure 3) "blah"  
3</pre><p>由于currying的关系，函数套用是left-associative，所以我们忽略掉括弧。</p><pre class="code">ghci> pure 3 "blah"  
3</pre><p>而<code><*></code>的实做是比较不容易了解的，我们最好看一下怎么用applicative style的方式来使用作为applicative functor的function。</p><pre class="code">ghci> :t (+) <$> (+3) <*> (*100)  
(+) <$> (+3) <*> (*100) :: (Num a) => a -> a  
ghci> (+) <$> (+3) <*> (*100) $ 5  
508</pre><p>将两个applicative functor喂给<code><*></code>可以产生一个新的applicative functor，所以如果我们丢给他两个函数，我们能得到一个新的函数。所以是怎么一回事呢？当我们做<code>(+) <$> (+3) <*> (*100)</code>，我们是在实做一个函数，他会将<code>(+3)</code>跟<code>(*100)</code>的结果再套用<code>+</code>。要看一个实际的范例的话，可以看一下<code>(+) <$> (+3) <*> (*100) $ 5</code>首先<code>5</code>被丢给<code>(+3)</code>跟<code>(*100)</code>，产生<code>8</code>跟<code>500</code>。然后<code>+</code>被套用到<code>8</code>跟<code>500</code>，得到<code>508</code>。</p><pre class="code">ghci> (\x y z -> [x,y,z]) <$> (+3) <*> (*2) <*> (/2) $ 5  
[8.0,10.0,2.5]</pre><img src="/img/jazzb.png" style="float:right"></img><p>这边也一样。我们创建了一个函数，他会调用<code>\x y z -> [x,y,z]</code>，而丢的参数是<code>(+3)</code>,<code>(*2)</code>跟<code>(/2)</code>。<code>5</code>被丢给以上三个函数，然后他们结果又接到<code>\x y z -> [x, y, z]</code>。</p><p>你可以将函数想做是装着最终结果的盒子，所以<code>k <$> f <*> g</code>会制造一个函数，他会将<code>f</code>跟<code>g</code>的结果丢给<code>k</code>。当我们做<code>(+) <$> Just 3 <*> Just 5</code>，我们是用<code>+</code>套用在一些可能有或可能没有的值上，所以结果也会是可能有或没有。当我们做<code>(+) <$> (+10) <*> (+5)</code>，我们是将<code>+</code>套用在<code>(+10)</code>跟<code>(+5)</code>的结果上，而结果也会是一个函数，当被喂给一个参数的时候会产生结果。</p><p>我们通常不会将函数当作applicative用，不过仍然值得当作练习。对于<code>(->) r</code>怎么定义成<code>Applicative</code>的并不是真的那么重要，所以如果你不是很懂的话也没关系。这只是让你获得一些操作上的直觉罢了。</p><p>一个我们之前还没碰过的<code>Applicative</code>的instance是<code>ZipList</code>，他是包含在<code>Control.Applicative</code>中。</p><p>对于list要作为一个applicative functor可以有多种方式。我们已经介绍过其中一种。如果套用<code><*></code>，左边是许多函数，而右边是许多值，那结果会是函数套用到值的所有组合。如果我们做<code>[(+3),(*2)] <*> [1,2]</code>。那<code>(+3)</code>会先套用至<code>1</code>跟<code>2</code>。接着<code>(*2)</code>套用至<code>1</code>跟<code>2</code>。而得到<code>[4,5,2,4]</code>。</p><p>然而<code>[(+3),(*2)] <*> [1,2]</code>也可以这样运作:把左边第一个函数套用至右边第一个值，接着左边第二个函数套用右边第二个值，以此类推。这样得到的会是<code>[4,4]</code>。或是<code>[1 + 3, 2 * 2]</code>。</p><p>由于一个型别不能对同一个typeclass定义两个instance，所以才会定义了<code>ZipList a</code>，他只有一个构造子<code>ZipList</code>，他只包含一个字段，他的型别是list。</p><pre class="code">instance Applicative ZipList where  
        pure x = ZipList (repeat x)  
        ZipList fs <*> ZipList xs = ZipList (zipWith (\f x -> f x) fs xs)</pre><p><code><*></code>做的就是我们之前说的。他将第一个函数套用至第一个值，第二个函数套用第二个值。这也是<code>zipWith (\f x -> f x) fs xs</code>做的事。由于<code>zipWith</code>的特性，所以结果会跟list中比较短的那个一样长。</p><p><code>pure</code>也值得我们讨论一下。他接受一个值，把他重复地放进一个list中。<code>pure "haha"</code>就会是<code>ZipList (["haha","haha","haha"...</code>。这可能会造成些混淆，毕竟我们说过<code>pure</code>是把一个值放进一个最小的context中。而你会想说无限长的list不可能会是一个最小的context。但对于zip list来说这是很合理的，因为他必须在list的每个位置都有值。这也遵守了<code>pure f <*> xs</code>必须要等价于<code>fmap f xs</code>的特性。如果<code>pure 3</code>只是回传<code>ZipList [3]</code>，那<code>pure (*2) <*> ZipList [1,5,10]</code>就只会算出<code>ZipList [2]</code>，因为两个zip list算出结果的长度会是比较短的那个的长度。如果我们zip一个有限长的list以及一个无限长的list，那结果的长会是有限长的list的长度。</p><p>那zip list是怎么用applicative style操作的呢？我们来看看，<code>ZipList a</code>型别并没有定义成<code>Show</code>的instance，所以我们必须用<code>getZipList</code>函数来从zip list取出一个普通的list。</p><pre class="code">ghci> getZipList $ (+) <$> ZipList [1,2,3] <*> ZipList [100,100,100]  
[101,102,103]  
ghci> getZipList $ (+) <$> ZipList [1,2,3] <*> ZipList [100,100..]  
[101,102,103]  
ghci> getZipList $ max <$> ZipList [1,2,3,4,5,3] <*> ZipList [5,3,1,2]  
[5,3,3,4]  
ghci> getZipList $ (,,) <$> ZipList "dog" <*> ZipList "cat" <*> ZipList "rat"  
[('d','c','r'),('o','a','a'),('g','t','t')]</pre><blockquote><p><code>(,,)</code>函数跟<code>\x y z -> (x,y,z)</code>是等价的，而<code>(,)</code>跟<code>\x y -> (x,y)</code>是等价的。</p></blockquote><p>除了<code>zipWith</code>，标准函式库中也有<code>zipWith3</code>,<code>zipWith4</code>之类的函数，最多支持到7。<code>zipWith</code>接受一个接受两个参数的函数，并把两个list zip起来。<code>zipWith3</code>则接受一个接受三个参数的函数，然后把三个list zip起来。以此类推。用applicative style的方式来操作zip list的话，我们就不需要对每个数量的list都定义一个独立的zip函数来zip他们。我们只需要用applicative style的方式来把任意数量的list zip起来就可以了。</p><p><code>Control.Applicative</code>定义了一个函数叫做<code>liftA2</code>，他的型别是<code>liftA2 :: (Applicative f) => (a -> b -> c) -> f a -> f b -> f c</code>。他定义如下：</p><pre class="code">liftA2 :: (Applicative f) => (a -> b -> c) -> f a -> f b -> f c  
liftA2 f a b = f <$> a <*> b</pre><p>并没有太难理解的东西，他不过就是对两个applicatives套用函数而已，而不用我们刚刚熟悉的applicative style。我们提及他的理由只是要展示为什么applicative functors比起一般的普通functor要强。如果只是普通的functor的话，我们只能将一个函数map over这个functor。但有了applicative functor，我们可以对好多个functor套用一个函数。看看这个函数的型别，他会是<code>(a -> b -> c) -> (f a -> f b -> f c)</code>。当我们从这样的角度来看他的话，我们可以说<code>liftA2</code>接受一个普通的二元函数，并将他升级成一个函数可以运作在两个functor之上。</p><p>另外一个有趣的概念是，我们可以接受两个applicative functor并把他们结合成一个applicative functor，这个新的将这两个applicative functor装在list中。举例来说，我们现在有<code>Just 3</code>跟<code>Just 4</code>。我们假设后者是一个只包含单元素的list。</p><pre class="code">ghci> fmap (\x -> [x]) (Just 4)  
Just [4]</pre><p>所以假设我们有<code>Just 3</code>跟<code>Just [4]</code>。我们有怎么得到<code>Just [3,4]</code>呢？很简单。</p><pre class="code">ghci> liftA2 (:) (Just 3) (Just [4])  
Just [3,4]  
ghci> (:) <$> Just 3 <*> Just [4]  
Just [3,4]</pre><p>还记得<code>:</code>是一个函数，他接受一个元素跟一个list，并回传一个新的list，其中那个元素已经接在前面。现在我们有了<code>Just [3,4]</code>，我们能够将他跟<code>Just 2</code>绑在一起变成<code>Just [2,3,4]</code>吗？当然可以。我们可以将任意数量的applicative绑在一起变成一个applicative，里面包含一个装有结果的list。我们试着实作一个函数，他接受一串装有applicative的list，然后回传一个applicative里面有一个装有结果的list。我们称呼他为<code>sequenceA</code>。</p><pre class="code">sequenceA :: (Applicative f) => [f a] -> f [a]  
sequenceA [] = pure []  
sequenceA (x:xs) = (:) <$> x <*> sequenceA xs</pre><p>居然用到了递归！首先我们来看一下他的型别。他将一串applicative的list转换成一个applicative装有一个list。从这个信息我们可以推测出边界条件。如果我们要将一个空的list变成一个装有list的applicative。我们只要把这个空的list放进一个缺省的context。现在来看一下我们怎么用递归的。如果们有一个可以分成头跟尾的list（<code>x</code>是一个applicative而<code>xs</code>是一串applicatve），我们可以对尾巴调用<code>sequenceA</code>，便会得到一个装有list的applicative。然后我们只要将在<code>x</code>中的值把他接到装有list的applicative前面就可以了。</p><p>所以如果我们做<code>sequenceA [Just 1, Just 2]</code>，也就是<code>(:) <$> Just 1 <*> sequenceA [Just 2]</code>。那会等价于<code>(:) <$> Just 1 <*> ((:) <$> Just 2 <*> sequenceA [])</code>。我们知道<code>sequenceA []</code>算出来会是<code>Just []</code>，所以运算式就变成<code>(:) <$> Just 1 <*> ((:) <$> Just 2 <*> Just [])</code>，也就是<code>(:) <$> Just 1 <*> Just [2]</code>，算出来就是<code>Just [1,2]</code>。</p><p>另一种实作<code>sequenceA</code>的方式是用fold。要记得几乎任何需要走遍整个list并accumulate成一个结果的都可以用fold来实作。</p><pre class="code">sequenceA :: (Applicative f) => [f a] -> f [a]  
sequenceA = foldr (liftA2 (:)) (pure [])</pre><p>我们从右往左走，并且起始的acuumulator是用<code>pure []</code>。我们是用<code>liftA2 (:)</code>来结合accumulator跟list中最后的元素，而得到一个applicative，里面装有一个单一元素的一个list。然后我们再用<code>liftA2 (:)</code>来结合accumulator跟最后一个元素，最直到我们只剩下accumulator为止，而得到一个applicative，里面装有所有结果。</p><p>我们来试试看套用在不同applicative上。</p><pre class="code">ghci> sequenceA [Just 3, Just 2, Just 1]  
Just [3,2,1]  
ghci> sequenceA [Just 3, Nothing, Just 1]  
Nothing  
ghci> sequenceA [(+3),(+2),(+1)] 3  
[6,5,4]  
ghci> sequenceA [[1,2,3],[4,5,6]]  
[[1,4],[1,5],[1,6],[2,4],[2,5],[2,6],[3,4],[3,5],[3,6]]  
ghci> sequenceA [[1,2,3],[4,5,6],[3,4,4],[]]  
[]</pre><p>很酷吧。当我们套用在<code>Maybe</code>上时，<code>sequenceA</code>创造一个新的<code>Maybe</code>，他包含了一个list装有所有结果。如果其中一个值是<code>Nothing</code>，那整个结果就会是<code>Nothing</code>。如果你有一串<code>Maybe</code>型别的值，但你只在乎当结果不包含任何<code>Nothing</code>的情况，这样的特性就很方便。</p><p>当套用在函数时，<code>sequenceA</code>接受装有一堆函数的list，并回传一个回传list的函数。在我们的范例中，我们写了一个函数，他只接受一个数值作为参数，他会把他套用至list中的每一个函数，并回传一个包含结果的list。<code>sequenceA [(+3),(+2),(+1)] 3</code>会将<code>3</code>喂给<code>(+3)</code>,<code>(+2)</code>跟<code>(+1)</code>，然后将所有结果装在一个list中。</p><p>而<code>(+) <$> (+3) <*> (*2)</code>会创见一个接受单一参数的一函数，将他同时喂给<code>(+3)</code>跟<code>(*2)</code>，然后调用<code>+</code>来将两者加起来。同样的道理，<code>sequenceA [(+3),(*2)]</code>是制造一个接受单一参数的函数，他会将他喂给所有包含在list中的函数。但他最后不是调用<code>+</code>，而是调用<code>:</code>跟<code>pure []</code>来把结果接成一个list，得到最后的结果。</p><p>当我们有一串函数，我们想要将相同的输入都喂给他们并查看结果的时候，<code>sequenceA</code>非常好用。例如说，我们手上有一个数值，但不知道他是否满足一串predicate。一种实作的方式是像这样：</p><pre class="code">ghci> map (\f -> f 7) [(>4),(<10),odd]  
[True,True,True]  
ghci> and $ map (\f -> f 7) [(>4),(<10),odd]  
True</pre><p>记住<code>and</code>接受一串布林值，并只有在全部都是<code>True</code>的时候才回传<code>True</code>。</p><p>另一种实作方式是用<code>sequenceA</code>：</p><pre class="code">ghci> sequenceA [(>4),(<10),odd] 7  
[True,True,True]  
ghci> and $ sequenceA [(>4),(<10),odd] 7  
True</pre><p><code>sequenceA [(>4),(<10),odd]</code>接受一个函数，他接受一个数值并将他喂给所有的predicate，包含<code>[(>4),(<10),odd]</code>。然后回传一串布林值。他将一个型别为<code>(Num a) => [a -> Bool]</code>的list变成一个型别为<code>(Num a) => a -> [Bool]</code>的函数，很酷吧。</p><p>由于list要求里面元素的型别要一致，所以包含在list中的所有函数都是同样型别。你不能创造一个像是<code>[ord, (+3)]</code>这样的list，因为<code>ord</code>接受一个字符并回传一个数值，然而<code>(+3)</code>接受一个数值并回传一个数值。</p><p>当跟<code>[]</code>一起使用的时候，<code>sequenceA</code>接受一串list，并回传另一串list。他实际上是创建一个包含所有可能组合的list。为了方便说明，我们比较一下使用<code>sequenceA</code>跟list comprehension的差异：</p><pre class="code">ghci> sequenceA [[1,2,3],[4,5,6]]  
[[1,4],[1,5],[1,6],[2,4],[2,5],[2,6],[3,4],[3,5],[3,6]]  
ghci> [[x,y] | x <- [1,2,3], y <- [4,5,6]]  
[[1,4],[1,5],[1,6],[2,4],[2,5],[2,6],[3,4],[3,5],[3,6]]  
ghci> sequenceA [[1,2],[3,4]]  
[[1,3],[1,4],[2,3],[2,4]]  
ghci> [[x,y] | x <- [1,2], y <- [3,4]]  
[[1,3],[1,4],[2,3],[2,4]]  
ghci> sequenceA [[1,2],[3,4],[5,6]]  
[[1,3,5],[1,3,6],[1,4,5],[1,4,6],[2,3,5],[2,3,6],[2,4,5],[2,4,6]]  
ghci> [[x,y,z] | x <- [1,2], y <- [3,4], z <- [5,6]]  
[[1,3,5],[1,3,6],[1,4,5],[1,4,6],[2,3,5],[2,3,6],[2,4,5],[2,4,6]]</pre><p>这可能有点难以理解，但如果你多做点尝试，你会比较能看出来些眉目。假设我们在做<code>sequenceA [[1,2],[3,4]]</code>。要知道这是怎么回事，我们首先用<code>sequenceA</code>的定义<code>sequenceA (x:xs) = (:) <$> x <*> sequenceA xs</code>还有边界条件<code>sequenceA [] = pure []</code>来看看。你不需要实际计算，但他可以帮助你理解<code>sequenceA</code>是怎么运作在一串list上，毕竟这有点复杂。</p><ul><li><p>我们从<code>sequenceA [[1,2],[3,4]]</code>开始</p></li><li><p>那可以被计算成<code>(:) <$> [1,2] <*> sequenceA [[3,4]]</code></p></li><li><p>计算内层的<code>sequenceA</code>，会得到<code>(:) <$> [1,2] <*> ((:) <$> [3,4] <*> sequenceA [])</code></p></li><li><p>我们碰到了边界条件，所以会是<code>(:) <$> [1,2] <*> ((:) <$> [3,4] <*> [[]])</code></p></li><li><p>现在我们计算<code>(:) <$> [3,4] <*> [[]]</code>的部份，我们会对左边list中的每一个值 (也就是<code>3</code>跟<code>4</code>) 跟右边的每一个值 (只有<code>[]</code>)套用<code>:</code>，而得到<code>[3:[], 4:[]]</code>，也就是<code>[[3],[4]]</code>。所以我们有<code>(:) <$> [1,2] <*> [[3],[4]]</code></p></li><li><p>而对于左边的每一个值(<code>1</code>跟<code>2</code>)以及右边可能的值（<code>[3]</code>跟<code>[4]</code>）我们套用<code>:</code>而得到<code>[1:[3], 1:[4], 2:[3], 2:[4]]</code>，他等于<code>[[1,3],[1,4],[2,3],[2,4]]</code></p></li></ul><p>计算<code>(+) <$> [1,2] <*> [4,5,6]</code>会得到一个non-deterministic的结果<code>x + y</code>，其中<code>x</code>代表<code>[1,2]</code>中的每一个值，而<code>y</code>代表<code>[4,5,6]</code>中的每一个值。我们用list来表示每一种可能的情形。同样的，当我们在做<code>sequence [[1,2],[3,4],[5,6],[7,8]]</code>，他的结果会是non-deterministic的<code>[x,y,z,w]</code>，其中<code>x</code>代表<code>[1,2]</code>中的每一个值，而<code>y</code>代表<code>[3,4]</code>中的每一个值。以此类推。我们用list 代表non-deterministic的计算，每一个元素都是一个可能的情形。这也是为什么会用到list of list。</p><p>当使用在I/O action上的时候，<code>sequenceA</code>跟<code>sequence</code>是等价的。他接受一串I/O action并回传一个I/O action，这个I/O action会计算list中的每一个I/O action，并把结果放在一个list中。要将型别为<code>[IO a]</code>的值转换成<code>IO [a]</code>的值，也就是会产生一串list的一个I/O action，那这些I/O action必须要一个一个地被计算，毕竟对于这些I/O action你没办法不计算就得到结果。</p><pre class="code">ghci> sequenceA [getLine, getLine, getLine]  
heyh  
ho  
woo  
["heyh","ho","woo"]</pre><p>就像普通的函数一样，applicative functors也遵循一些定律。其中最重要的一个是我们之前提过的<code>pure f <*> x = fmap f x</code>。你可以证明一些我们之前介绍过的applicative functor遵守这个定律当作练习。其他的functors law有：</p><ul><li><p><code>pure id <*> v = v</code></p></li><li><p><code>pure (.) <*> u <*> v <*> w = u <*> (v <*> w)</code></p></li><li><p><code>pure f <*> pure x = pure (f x)</code></p></li><li><p><code>u <*> pure y = pure ($ y) <*> u</code></p></li></ul><p>我们不会一项一项地细看，那样会花费很大的篇幅而且对读者来说很无聊，但如果你有兴趣，你可以针对某些instance看看他们会不会遵守。</p><p>结论就是applicative functor不只是有趣而且实用， 他允许我们结合不同种类的计算，像是I/O计算，non-deterministic的计算，有可能失败的计算等等。而使用<code><$></code>跟<code><*></code>我们可以将普通的函数来运作在任意数量的applicative functors上。</p><a name="关键字"newtype""></a><h2>关键字"newtype"</h2><img src="/img/maoi.png" style="float:left"></img><p>到目前为止，我们已经看过了如何用<code>data</code>关键字定义自己的algebraic data type。我们也学习到了如何用<code>type</code>来定义type synonyms。在这个章节中，我们会看一下如何使用<code>newtype</code>来从一个现有的型别中定义出新的型别，并说明我们为什么会想要那么做。</p><p>在之前的章节中，我们了解到其实list有很多种方式可以被视为一种applicative functor。一中方式是定义<code><*></code>将左边的每一个值跟右边的每一个值组合，而得到各种组合的结果。</p><pre class="code">ghci> [(+1),(*100),(*5)] <*> [1,2,3]  
[2,3,4,100,200,300,5,10,15]</pre><p>第二种方式是将<code><*></code>定义成将左边的第一个函数套用至右边的第一个值，然后将左边第二个函数套用至右边第二个值。以此类推。最终，这表现得有点像将两个list用一个拉链拉起来一样。但由于list已经被定义成<code>Applicaitive`的instance了，所以我们要怎么要让list可以被定义成第二种方式呢？如果你还记得我们说过我们是有很好的理由定义了</code>ZipList a<code>，其中他里面只包含一个值构造子跟只包含一个字段。其实他的理由就是要让</code>ZipList<code>定义成用拉链的方式来表现applicative行为。我们只不过用</code>ZipList<code>这个构造子将他包起来，然后用</code>getZipList来解开来。</p><pre class="code">ghci> getZipList $ ZipList [(+1),(*100),(*5)] <*> ZipList [1,2,3]  
[2,200,15]</pre><p>所以这跟newtype这个关键字有什么关系呢？想想看我们是怎么宣告我们的<code>ZipList a</code>的，一种方式是像这样：</p><pre class="code">data ZipList a = ZipList [a]</pre><p>也就是一个只有一个值构造子的型别而且那个构造子里面只有一个字段。我们也可以用record syntax来定义一个解开的函数：</p><pre class="code">data ZipList a = ZipList { getZipList :: [a] }</pre><p>这样听起来不错。这样我们就有两种方式来让一个型别来表现一个typeclass，我们可以用<code>data</code>关键自来把一个型别包在另一个里面，然后再将他定义成第二种表现方式。</p><p>而在Haskell中<code>newtype</code>正是为了这种情形，我们想将一个型别包在另一个型别中。在实际的函式库中<code>ZipList a</code>是这样定义了：</p><pre class="code">newtype ZipList a = ZipList { getZipList :: [a] }</pre><p>这边我们不用<code>data</code>关键字反而是用<code>newtype</code>关键字。这是为什么呢？第一个理由是<code>newtype</code>比较快速。如果你用<code>data</code>关键字来包一个型别的话，在你执行的时候会有一些包起来跟解开来的成本。但如果你用<code>newtype</code>的话，Haskell会知道你只是要将一个现有的型别包成一个新的型别，你想要内部运作完全一样但只是要一个全新的型别而已。有了这个概念，Haskell可以将包裹跟解开来的成本都去除掉。</p><p>那为什么我们不是一直使用<code>newtype</code>呢？当你用<code>newtype</code>来制作一个新的型别时，你只能定义单一一个值构造子，而且那个构造子只能有一个字段。但使用<code>data</code>的话，你可以让那个型别有好几个值构造子，并且每个构造子可以有零个或多个字段。</p><pre class="code">data Profession = Fighter | Archer | Accountant  
  
data Race = Human | Elf | Orc | Goblin  

data PlayerCharacter = PlayerCharacter Race Profession</pre><p>当使用newtype的时候，你是被限制只能用一个值构造子跟单一字段。</p><p>对于<code>newtype</code>我们也能使用<code>deriving</code>关键字。我们可以derive像是<code>Eq</code>,<code>Ord</code>,<code>Enum</code>,<code>Bounded</code>,<code>Show</code>跟<code>Read</code>的instance。如果我们想要对新的型别做derive，那原本的型别必须已经在那个typeclass中。这样很合理，毕竟<code>newtype</code>就是要将现有的型别包起来。如果我们按照下面的方式定义的话，我们就能对我们的型别做印出以及比较相等性的操作：</p><pre class="code">newtype CharList = CharList { getCharList :: [Char] } deriving (Eq, Show)</pre><p>我们来跑跑看：</p><pre class="code">ghci> CharList "this will be shown!"  
CharList {getCharList = "this will be shown!"}  
ghci> CharList "benny" == CharList "benny"  
True  
ghci> CharList "benny" == CharList "oisters"  
False</pre><p>对于这个<code>newtype</code>，他的值构造子有下列型别：</p><pre class="code">CharList :: [Char] -> CharList</pre><p>他接受一个<code>[Char]</code>的值，例如<code>"my sharona"</code>并回传一个<code>CharList</code>的值。从上面我们使用<code>CharList</code>的值构造子的范例中，我们可以看到的确是这样。相反地，<code>getCharList</code>具有下列的型别。</p><pre class="code">getCharList :: CharList -> [Char]</pre><p>他接受一个<code>CharList</code>的值并将他转成<code>[Char]</code>。你可以将这个想成包装跟解开的动作，但你也可以将他想成从一个型别转成另一个型别。</p><a name="Using newtype to make type class instances"></a><h3>Using newtype to make type class instances</h3><p>有好几次我们想要让我们的型别属于某个typeclass，但型别变量并没有符合我们想要的。要把<code>Maybe</code>定义成<code>Functor</code>的instnace很容易，因为<code>Functor</code>这个typeclass被定义如下：</p><pre class="code">class Functor f where  
    fmap :: (a -> b) -> f a -> f b</pre><p>我们先定义如下：</p><pre class="code">instance Functor Maybe where</pre><p>然后我们实做<code>fmap</code>。当所有的型别变量被填上时，由于<code>Maybe</code>取代了<code>Functor</code>中<code>f</code>的位置，所以如果我们看看<code>fmap</code>运作在<code>Maybe</code>上时是什么样，他会像这样：</p><pre class="code">fmap :: (a -> b) -> Maybe a -> Maybe b</pre><img src="/img/shamrock.png" style="float:right"></img><p>看起来不错吧？现在我们想要tuple成为<code>Functor</code>的一个instance，所以当我们用<code>fmap</code>来map over一个tuple时，他会先套用到tuple中的第一个元素。这样当我们做<code>fmap (+3) (1,1)</code>会得到<code>(4,1)</code>。不过要定义出这样的instance有些困难。对于<code>Maybe</code>，我们只要写<code>instance Functor Maybe where</code>，这是因为对于只吃一个参数的型别构造子我们很容易定义成<code>Functor</code>的instance。但对于<code>(a,b)</code>这样的就没办法。要绕过这样的困境，我们可以用<code>newtype</code>来重新定义我们的tuple，这样第二个型别参数就代表了tuple中的第一个元素部份。</p><pre class="code">newtype Pair b a = Pair { getPair :: (a,b) }</pre><p>现在我们可以将他定义成<code>Functor</code>的instnace，所以函数被map over tuple中的第一个部份。</p><pre class="code">instance Functor (Pair c) where  
    fmap f (Pair (x,y)) = Pair (f x, y)</pre><p>正如你看到的，我们可以对newtype定义的型别做模式匹配。我们用模式匹配来拿到底层的tuple，然后我们将<code>f</code>来套用至tuple的第一个部份，然后我们用<code>Pair</code>这个值构造子来将tuple转换成<code>Pair b a</code>。如果我们问<code>fmap</code>的型别究竟是什么，他会是：</p><pre class="code">fmap :: (a -> b) -> Pair c a -> Pair c b</pre><p>我们说过<code>instance Functor (Pair c) where</code>跟<code>Pair c</code>取代了<code>Functor</code>中<code>f</code>的位置：</p><pre class="code">class Functor f where  
    fmap :: (a -> b) -> f a -> f b</pre><p>如果我们将一个tuple转换成<code>Pair b a</code>，我们可以用<code>fmap</code>来map over第一个部份。</p><pre class="code">ghci> getPair $ fmap (*100) (Pair (2,3))  
(200,3)  
ghci> getPair $ fmap reverse (Pair ("london calling", 3))  
("gnillac nodnol",3)</pre><a name="On newtype laziness"></a><h3>On newtype laziness</h3><p>我们提到<code>newtype</code>一般来讲比<code>data</code>来得有效率。<code>newtype</code>能做的唯一一件事就是将现有的型别包成新的型别。这样Haskell在内部就能将新的型别的值用旧的方式来操作。只是要记住他们还是不同的型别。这代表<code>newtype</code>并不只是有效率，他也具备lazy的特性。我们来说明一下这是什么意思。</p><p>就像我们之前说得，Haskell缺省是具备lazy的特性，这代表只有当我们要将函数的结果印出来的时候计算才会发生。或者说，只有当我们真的需要结果的时候计算才会发生。在Haskell中<code>undefined</code>代表会造成错误的计算。如果我们试着计算他，也就是将他印到终端中，Haskell会丢出错误。</p><pre class="code">ghci> undefined  
*** Exception: Prelude.undefined</pre><p>然而，如果我们做一个list，其中包含一些<code>undefined</code>的值，但却邀邱一个不是<code>undefined</code>的head，那一切都会顺利地被计算，因为Haskell并不需要list中其他元素来得到结果。我们仅仅需要看道地一个元素而已。</p><pre class="code">ghci> head [3,4,5,undefined,2,undefined]  
3</pre><p>现在们考虑下面的型别：</p><pre class="code">data CoolBool = CoolBool { getCoolBool :: Bool }</pre><p>这是一个用<code>data</code>关键字定义的algebraic data type。他有一个值建构子并只有一个型别为<code>Bool</code>的字段。我们写一个函数来对<code>CoolBool</code>做模式匹配，并回传一个<code>"hello"</code>的值。他并不会馆<code>CoolBool</code>中装的究竟是<code>True</code>或<code>False</code>。</p><pre class="code">helloMe :: CoolBool -> String  
helloMe (CoolBool _) = "hello"</pre><p>这次我们不喂给这个函数一个普通的<code>CoolBool</code>，而是丢给他一个<code>undefined</code>。</p><pre class="code">ghci> helloMe undefined  
"*** Exception: Prelude.undefined  "</pre><p>结果收到了一个Exception。是什么造成这个Exception的呢？用<code>data</code>定义的型别可以有好几个值构造子（尽管<code>CoolBool</code>只有一个）所以当我们要看看喂给函数的值是否是<code>(CoolBool _)</code>的形式，Haskell会需要做一些基本的计算来看看是哪个值构造子备用到。但当我们计算<code>undefined</code>的时候，就算是一点也会丢出Exception。</p><p>我们不用<code>data</code>来定义<code>CoolBool</code>而用<code>newtype</code>：</p><pre class="code">newtype CoolBool = CoolBool { getCoolBool :: Bool }</pre><p>我们不用修改<code>helloMe</code>函数，因为对于模式匹配使用<code>newtype</code>或<code>data</code>都是一样。我们再来将<code>undefined</code>喂给<code>helloMe</code>。</p><pre class="code">ghci> helloMe undefined  
"hello"</pre><p>居然正常运作！为什么呢？正如我们说过得，当我们使用<code>newtype</code>的时候，Haskell内部可以将新的型别用旧的型别来表示。他不必加入另一层box来包住旧有的型别。他只要注意他是不同的型别就好了。而且Haskell会知道<code>newtype</code>定义的型别一定只会有一个构造子，他不必计算喂给函数的值就能确定他是<code>(CoolBool _)</code>的形式，因为<code>newtype</code>只有一个可能的值跟单一字段！</p><p>这样行为的差异可能没什么关系，但实际上他非常重要。因为他让我们认知到尽管从撰写程序的观点来看没什么差异，但他们的确是两种不同的机制。尽管<code>data</code>可以让你从无到有定义型别，<code>newtype</code>是从一个现有的型别做出来的。对<code>newtype</code>做模式匹配并不是像从盒子中取出东西，他比较像是将一个型别转换成另一个型别。</p><a name="type vs newtype vs data"></a><h3>type vs newtype vs data</h3><p>到目前为止，你也许对于<code>type</code>,<code>data</code>跟<code>newtype</code>`之间的差异还不是很了解，让我们快速复习一遍。</p><p><code>type</code>关键字是让我们定义type synonyms。他代表我们只是要给一个现有的型别另一个名字，假设我们这样做：</p><pre class="code">type IntList = [Int]</pre><p>这样做可以允许我们用<code>IntList</code>的名称来指称<code>[Int]</code>。我们可以交换地使用他们。但我们并不会因此有一个<code>IntList</code>的值构造子。因为<code>[Int]</code>跟<code>IntList</code>只是两种指称同一个型别的方式。我们在指称的时候用哪一个并无所谓。</p><pre class="code">ghci> ([1,2,3] :: IntList) ++ ([1,2,3] :: [Int])  
[1,2,3,1,2,3]</pre><p>当我们想要让type signature更清楚一些，给予我们更了解函数的context的时候，我们会定义type synonyms。举例来说，当我们用一个型别为<code>[(String,String)]</code>的association list来代表一个电话簿的时候，我们可以定义一个<code>PhoneBook1</code>的type synonym，这样type signature会比较容易读。</p><p><code>newtype</code>关键字将现有的型别包成一个新的型别，大部分是为了要让他们可以是特定typeclass的instance而这样做。当我们使用<code>newtype</code>来包裹一个现有的型别时，这个型别跟原有的型别是分开的。如果我们将下面的型别用<code>newtype</code>定义：</p><pre class="code">newtype CharList = CharList { getCharList :: [Char] }</pre><p>我们不能用<code>++</code>来将<code>CharList</code>跟<code>[Char]</code>接在一起。我们也不能用<code>++</code>来将两个<code>CharList</code>接在一起，因为<code>++</code>只能套用在list上，而<code>CharList</code>并不是list，尽管你会说他包含一个list。但我们可以将两个<code>CharList</code>转成list，将他们<code>++</code>然后再转回<code>CharList</code>。</p><p>当我们在<code>newtype</code>宣告中使用record syntax的时候，我们会得到将新的型别转成旧的型别的函数，也就是我们<code>newtype</code>的值构造子，以及一个函数将他的字段取出。新的型别并不会被自动定义成原有型别所属的typeclass的一个instance，所以我们必须自己来derive他们。</p><p>实际上你可以将<code>newtype</code>想成是只能定义一个构造子跟一个字段的<code>data</code>宣告。如果你碰到这种情形，可以考虑使用<code>newtype</code>。</p><p>使用<code>data</code>关键字是为了定义自己的型别。他们可以在algebraic data type中放任意数量的构造子跟字段。可以定义的东西从list,<code>Maybe</code>到tree。</p><p>如果你只是希望你的type signature看起来比较干净，你可以只需要type synonym。如果你想要将现有的型别包起来并定义成一个type class的instance，你可以尝试使用newtype。如果你想要定义完全新的型别，那你应该使用<code>data</code>关键字。</p><a name="Monoids"></a><h2>Monoids</h2><p>Haskell中typeclass是用来表示一个型别之间共有的行为，是一种interace。我们介绍过<code>Eq</code>，他定义型别是否可以比较相等性，以及<code>Ord</code>，他表示可以被排序的型别。还介绍了更有趣的像是<code>Functor</code>跟<code>Applicative</code>。</p><p>当我们定义一个型别时，我们会想说他应该要支持的行为。也就是表现的行为是什么，并且要让他属于哪些typeclass。如果希望他可以比较相等与否，那我们就应该定义他成为<code>Eq</code>的一个instance。如果我们想要看看型别是否是一种functor，我们可以定义他是<code>Functor</code>的一个instance。以此类推。</p><p>考虑<code>*</code>是一个将两个数值相乘的一个函数。如果我们将一个数值乘上<code>1</code>，那就会得到自身的数值。我们实际上是做<code>1 * x</code>或<code>x * 1</code>并没有差别。结果永远会是<code>x</code>。同样的，<code>++</code>是一个接受两个参数并回传新的值的一个函数。只是他不是相乘而是将两个list接在一起。而类似<code>*</code>，他也有一个特定的值，当他跟其他值使用<code>++</code>时会得到同样的值。那个值就是空的list<code>[]</code>。</p><pre class="code">ghci> 4 * 1  
4  
ghci> 1 * 9  
9  
ghci> [1,2,3] ++ []  
[1,2,3]  
ghci> [] ++ [0.5, 2.5]  
[0.5,2.5]</pre><p>看起来<code>*</code>之于<code>1</code>跟<code>++</code>之于<code>[]</code>有类似的性质：</p><ul><li><p>函数同样接受两个参数</p></li><li><p>参数跟回传值是同样的型别</p></li><li><p>同样存在某些值当套用二元函数时并不会改变其他值</p></li></ul><p>关于这两种操作还有另一个比较难察觉的性质就是，当我们对这个二元函数对三个以上的值操作并化见，函数套用的顺序并不会影响到结果。不论是<code>(3 * 4) * 5</code>或是<code>3 * (4 * 5)</code>？两种方式都会得到<code>60</code>。而<code>++</code>也是相同的。</p><pre class="code">ghci> (3 * 2) * (8 * 5)  
240  
ghci> 3 * (2 * (8 * 5))  
240  
ghci> "la" ++ ("di" ++ "da")  
"ladida"  
ghci> ("la" ++ "di") ++ "da"  
"ladida"</pre><p>我们称呼这样的性质为结合律(associativity)。<code>*</code>遵守结合律，<code>++</code>也是。但<code>-</code>就不遵守。<code>(5 - 3) - 4</code>跟<code>5 - (3 - 4)</code>得到的结果是不同的。</p><p>注意到这些性质并具体地写下来，就可以得到monoid。一个monoid是你有一个遵守结合绿的二元函数还有一个可以相对于那个函数作为identity的值。当某个值相对于一个函数是一个identity，他表示当我们将这个值丢给函数时，结果永远会是另外一边的那个值本身。<code>1</code>是相对于<code>*</code>的identity，而<code>[]</code>是相对于<code>++</code>的identity。在Haskell中还有许多其他的monoid，这也是为什么我们定义了<code>Monoid</code>这个typeclass。他描述了表现成monoid的那些型别。我们来看看这个typeclass是怎么被定义的：</p><pre class="code">class Monoid m where  
    mempty :: m  
    mappend :: m -> m -> m  
    mconcat :: [m] -> m  
    mconcat = foldr mappend mempty</pre><img src="/img/balloondog.png" style="float:right"></img><p><code>Monoid</code>typeclass被定义在<code>import Data.Monoid</code>中。我们来花些时间好好了解他。</p><p>首先我们看到只有具体型别才能定义成<code>Monoid</code>的instance。由于在typeclass定义中的<code>m</code>并不接受任何型别参数。这跟<code>Functor</code>以及<code>Applicative</code>不同，他们要求他们的instance必须是一个接受单一型别参数的型别构造子。</p><p>第一个函数是<code>mempty</code>，由于他不接受任何参数，所以他并不是一个函数，而是一个polymorphic的常数。有点像是<code>Bounded</code>中的<code>minBound</code>一样。<code>mempty</code>表示一个特定monoid的identity。</p><p>再来我们看到<code>mappend</code>，你可能已经猜到，他是一个接受两个相同型别的值的二元函数，并回传同样的型别。不过要注意的是他的名字不太符合他真正的意思，他的名字隐含了我们要将两个东西接在一起。尽管在list的情况下<code>++</code>的确将两个list接起来，但<code>*</code>则否。他只不过将两个数值做相乘。当我们再看到其他<code>Monoid</code>的instance时，我们会看到他们大部分都没有接起来的做，所以不要用接起来的概念来想像<code>mappend</code>，只要想像他们是接受两个monoid的值并回传另外一个就好了。</p><p>在typeclass定义中的最后一个函数是<code>mconcat</code>。他接受一串monoid值，并将他们用<code>mappend</code>简化成单一的值。他有一个缺省的实做，就是从<code>mempty</code>作为起始值，然后用<code>mappend</code>来fold。由于对于大部分的instance缺省的实做就没什么问题，我们不会想要实做自己的<code>mconcat</code>。当我们定义一个型别属于<code>Monoid</code>的时候，多半实做<code>mempty</code>跟<code>mappend</code>就可以了。而<code>mconcat</code>就是因为对于一些instance，有可能有比较有效率的方式来实做<code>mconcat</code>。不过大多数情况都不需要。</p><p>在我们继续接下去看几个<code>Monoid</code>的例子前，我们来看一下monoid law。我们提过必须有一个值作为identity以及一个遵守结合律的二元函数当作前提。我们是可以定义一个<code>Monoid</code>的instance却不遵守这些定律的，但这样写出来的instance就没有用了，因为我们在使用<code>Monoid</code>的时候都是依靠这些定律才可以称作实质上的monoid。所以我们必须确保他们遵守：</p><ul><li><p><code>mempty `mappend` x = x</code></p></li><li><p><code>x `mappend` mempty = x</code></p></li><li><p><code>(x `mappend` y) `mappend` z = x `mappend` (y `mappend` z)</code></p></li></ul><p>前两个描述了<code>mempty</code>相对于<code>mappend</code>必须要表现成identity。而第三个定律说了<code>mappend</code>必须要遵守结合律。也就是说我们做<code>mappend</code>顺序并不重要。Haskell不会自己检查这些定律是否有被遵守。所以你必须自己小心地检查他们。</p><a name="Lists are monoids"></a><h3>Lists are monoids</h3><p>没错，list是一种monoid。正如我们先前看到的，<code>++</code>跟空的list<code>[]</code>共同形成了一个monoid。他的instance很简单：</p><pre class="code">instance Monoid [a] where  
    mempty = []  
    mappend = (++)</pre><p>list是<code>Monoid</code>typeclass的一个instance，这跟他们装的元素的型别无关。注意到我们写<code>instance Monoid [a]</code>而非<code>instance Monoid []</code>，这是因为<code>Monoid</code>要求instance必须是具体型别。</p><p>我们试着跑跑看，得到我们预期中的结果：</p><pre class="code">ghci> [1,2,3] `mappend` [4,5,6]  
[1,2,3,4,5,6]  
ghci> ("one" `mappend` "two") `mappend` "tree"  
"onetwotree"  
ghci> "one" `mappend` ("two" `mappend` "tree")  
"onetwotree"  
ghci> "one" `mappend` "two" `mappend` "tree"  
"onetwotree"  
ghci> "pang" `mappend` mempty  
"pang"  
ghci> mconcat [[1,2],[3,6],[9]]  
[1,2,3,6,9]  
ghci> mempty :: [a]  
[]</pre><img src="/img/smug.png" style="float:left"></img><p>注意到最后一行我们明白地标记出型别。这是因为如果只些<code>mempty</code>的话，GHCi不会知道他是哪一个instance的<code>mempty</code>，所以我们必须清楚说出他是list instance的mempty。我们可以使用一般化的型别<code>[a]</code>，因为空的list可以看作是属于任何型别。</p><p>由于<code>mconcat</code>有一个缺省的实做，我们将某个型别定义成<code>Monoid</code>的型别时就可以自动地得到缺省的实做。但对于list而言，<code>mconcat</code>其实就是<code>concat</code>。他接受一个装有list的list，并把他用<code>++</code>来扁平化他。</p><p>list的instnace也遵守monoid law。当我们有好几个list并且用<code>mappend</code>来把他们串起来，先后顺序并不是很重要，因为他们都是接在最后面。而且空的list也表现得如identity一样。注意到monoid并不要求<code>a `mappend</code>b<code>等于</code>bmappenda。在list的情况下，他们明显不相等。</p><pre class="code">ghci> "one" `mappend` "two"  
"onetwo"  
ghci> "two" `mappend` "one"  
"twoone"</pre><p>这样并没有关系。<code>3 * 5</code>跟<code>5 * 3</code>会相等只不过是乘法的性质而已，但没有保证所有monoid都要遵守。</p><a name="Product and Sum"></a><h3>Product and Sum</h3><p>我们已经描述过将数值表现成一种monoid的方式。只要将<code>*</code>当作二元函数而<code>1</code>当作identity就好了。而且这不是唯一一种方式，另一种方式是将<code>+</code>作为二元函数而<code>0</code>作为identity。</p><pre class="code">ghci> 0 + 4  
4  
ghci> 5 + 0  
5  
ghci> (1 + 3) + 5  
9  
ghci> 1 + (3 + 5)  
9</pre><p>他也遵守monoid law，因为将0加上其他数值，都会是另外一者。而且加法也遵守结合律。所以现在我们有两种方式来将数值表现成monoid，那要选哪一个呢？其实我们不必要强迫定下来，还记得当同一种型别有好几种表现成某个typeclass的方式时，我们可以用<code>newtype</code>来包裹现有的型别，然后再定义新的instance。这样就行了。</p><p><code>Data.Monoid</code>这个模块导出了两种型别，<code>Product</code>跟<code>Sum</code>。<code>Product</code>定义如下：</p><pre class="code">newtype Product a =  Product { getProduct :: a }  
    deriving (Eq, Ord, Read, Show, Bounded)</pre><p>简单易懂，就是一个单一型别参数的<code>newtype</code>，并derive一些性质。他的<code>`Monoid</code>的instance长得像这样：</p><pre class="code">instance Num a => Monoid (Product a) where  
    mempty = Product 1  
    Product x `mappend` Product y = Product (x * y)</pre><p><code>mempty</code>只不过是将<code>1</code>包在<code>Product</code>中。<code>mappend</code>则对<code>Product</code>的构造子做模式匹配，将两个取出的数值相乘后再将结果放回去。就如你看到的，typeclass定义前面有<code>Num a</code>的条件限制。所以他代表<code>Product a</code>对于所有属于<code>Num</code>的<code>a</code>是一个<code>Monoid</code>。要将<code>Product a</code>作为一个monoid使用，我们需要用newtype来做包裹跟解开的动作。</p><pre class="code">ghci> getProduct $ Product 3 `mappend` Product 9  
27  
ghci> getProduct $ Product 3 `mappend` mempty  
3  
ghci> getProduct $ Product 3 `mappend` Product 4 `mappend` Product 2  
24  
ghci> getProduct . mconcat . map Product $ [3,4,2]  
24</pre><p>这当作<code>Monoid</code>的一个演练还不错，但并不会有人觉得这会比<code>3 * 9</code>跟<code>3 * 1</code>这种方式来做乘法要好。但我们稍后会说明尽管像这种显而易见的定义还是有他方便的地方。</p><p><code>Sum</code>跟<code>Product</code>定义的方式类似，我们也可以用类似的方式操作：</p><pre class="code">ghci> getSum $ Sum 2 `mappend` Sum 9  
11  
ghci> getSum $ mempty `mappend` Sum 3  
3  
ghci> getSum . mconcat . map Sum $ [1,2,3]  
6</pre><a name="Any and ALL"></a><h3>Any and ALL</h3><p>另一种可以有两种表示成monoid方式的型别是<code>Bool</code>。第一种方式是将<code>||</code>当作二元函数，而<code>False</code>作为identity。这样的意思是只要有任何一个参数是<code>True</code>他就回传<code>True</code>，否则回传<code>Falsse</code>。所以如果我们使用<code>False</code>作为identity，他会在跟<code>False</code>做OR时回传<code>False</code>，跟<code>True</code>做OR时回传<code>True</code>。<code>Any</code>这个newtype是<code>Monoid</code>的一个instance，并定义如下：</p><pre class="code">newtype Any = Any { getAny :: Bool }  
    deriving (Eq, Ord, Read, Show, Bounded)</pre><p>他的instance长得像这样：</p><pre class="code">instance Monoid Any where  
    mempty = Any False  
    Any x `mappend` Any y = Any (x || y)</pre><p>他叫做<code>Any</code>的理由是<code>x `mappend` y</code>当有任何一个是<code>True</code>时就会是<code>True</code>。就算是更多个用<code>mappend</code>串起来的<code>Any</code>，他也会在任何一个是<code>True</code>回传<code>True</code>。</p><pre class="code">ghci> getAny $ Any True `mappend` Any False  
True  
ghci> getAny $ mempty `mappend` Any True  
True  
ghci> getAny . mconcat . map Any $ [False, False, False, True]  
True  
ghci> getAny $ mempty `mappend` mempty  
False</pre><p>另一种<code>Bool</code>表现成<code>Monoid</code>的方式是用<code>&&</code>作为二元函数，而<code>True</code>作为identity。只有当所有都是<code>True</code>的时候才会回传<code>True</code>。下面是他的newtype定义：</p><pre class="code">newtype All = All { getAll :: Bool }  
        deriving (Eq, Ord, Read, Show, Bounded)</pre><p>而这是他的instance：</p><pre class="code">instance Monoid All where  
        mempty = All True  
        All x `mappend` All y = All (x && y)</pre><p>当我们用<code>mappend</code>来串起<code>All</code>型别的值时，结果只有当所有<code>mappend</code>的值是<code>True</code>时才会是<code>True</code>：</p><pre class="code">ghci> getAll $ mempty `mappend` All True  
True  
ghci> getAll $ mempty `mappend` All False  
False  
ghci> getAll . mconcat . map All $ [True, True, True]  
True  
ghci> getAll . mconcat . map All $ [True, True, False]  
False</pre><p>就如乘法跟加法一样，我们通常宁愿用二元函数来操作他们也不会用newtype来将他们包起来。不会将他们包成<code>Any</code>或<code>All</code>然后用<code>mappend</code>，<code>mempty</code>或<code>mconcat</code>来操作。通常使用<code>or</code>跟<code>and</code>，他们接受一串<code>Bool</code>，并只有当任意一个或是所有都是<code>True</code>的时候才回传<code>True</code>。</p><a name="The Ordering monoid"></a><h3>The Ordering monoid</h3><p>还记得<code>Ordering</code>型别吗?他是比较运算之后得到的结果，包含三个值：<code>LT</code>，<code>EQ</code>跟<code>GT</code>，分别代表小于，等于跟大于：</p><pre class="code">ghci> 1 `compare` 2  
LT  
ghci> 2 `compare` 2  
EQ  
ghci> 3 `compare` 2  
GT</pre><p>针对list，数值跟布林值而言，要找出monoid的行为只要去查看已经定义的函数，然后看看有没有展现出monoid的特性就可以了，但对于<code>Ordering</code>，我们就必须要更仔细一点才能看出来是否是一个monoid，但其实他的<code>Monoid</code>instance还蛮直觉的：</p><pre class="code">instance Monoid Ordering where  
    mempty = EQ  
    LT `mappend` _ = LT  
    EQ `mappend` y = y  
    GT `mappend` _ = GT</pre><img src="/img/bear.png" style="float:right"></img><p>这个instance定义如下：当我们用<code>mappend</code>两个<code>Ordering</code>型别的值时，左边的会被保留下来。除非左边的值是<code>EQ</code>，那我们就会保留右边的当作结果。而identity就是<code>EQ</code>。乍看之下有点随便，但实际上他是我们比较两个英文本时所用的方法。我们先比较两个字母是否相等，如果他们不一样，那我们就知道那一个字在字典中会在前面。而如果两个字母相等，那我们就继续比较下一个字母，以此类推。</p><p>举例来说，如果我们字典顺序地比较<code>"ox"</code>跟<code>"on"</code>的话。我们会先比较两个字的首个字母，看看他们是否相等，然后继续比较第二个字母。我们看到<code>'x'</code>是比<code>'n'</code>要来得大，所以我们就知道如何比较两个字了。而要了解为何<code>EQ</code>是identity，我们可以注意到如果我们在两个字中间的同样位置塞入同样的字母，那他们之间的字典顺序并不会改变。<code>"oix"</code>仍然比<code>"oin"</code>要大。</p><p>很重要的一件事是在<code>Ordering</code>的<code>Monoid</code>定义里<code>x `mappend` y</code>并不等于<code>y `mappend` x</code>。因为除非第一个参数是<code>EQ</code>，不然结果就会是第一个参数。所以<code>LT `mappend` GT</code>等于<code>LT</code>，然而<code>GT `mappend` LT</code>等于<code>GT</code>。</p><pre class="code">ghci> LT `mappend` GT  
LT  
ghci> GT `mappend` LT  
GT  
ghci> mempty `mappend` LT  
LT  
ghci> mempty `mappend` GT  
GT</pre><p>所以这个monoid在什么情况下会有用呢？假设你要写一个比较两个字串长度的函数，并回传<code>Ordering</code>。而且当字串一样长的时候，我们不直接回传<code>EQ</code>，反而继续用字典顺序比较他们。一种实做的方式如下：</p><pre class="code">lengthCompare :: String -> String -> Ordering  
lengthCompare x y = let a = length x `compare` length y   
                        b = x `compare` y  
                    in  if a == EQ then b else a</pre><p>我们称呼比较长度的结果为<code>a</code>，而比较字典顺序的结果为<code>b</code>，而当长度一样时，我们就回传字典顺序。</p><p>如果善用我们<code>Ordering</code>是一种monoid这项知识，我们可以把我们的函数写得更简单些：</p><pre class="code">import Data.Monoid

lengthCompare :: String -> String -> Ordering  
lengthCompare x y = (length x `compare` length y) `mappend`  
                    (x `compare` y)</pre><p>我们可以试着跑跑看：</p><pre class="code">ghci> lengthCompare "zen" "ants"  
LT  
ghci> lengthCompare "zen" "ant"  
GT</pre><p>要记住当我们使用<code>mappend</code>。他在左边不等于<code>EQ</code>的情况下都会回传左边的值。相反地则回传右边的值。这也是为什么我们将我们认为比较重要的顺序放在左边的参数。如果我们要继续延展这个函数，要让他们比较元音的顺序，并把这顺串行为第二重要，那我们可以这样修改他：</p><pre class="code">import Data.Monoid  
  
lengthCompare :: String -> String -> Ordering  
lengthCompare x y = (length x `compare` length y) `mappend`  
                    (vowels x `compare` vowels y) `mappend`  
                    (x `compare` y)  
    where vowels = length . filter (`elem` "aeiou")</pre><p>我们写了一个辅助函数，他接受一个字串并回传他有多少元音。他是先用filter来把字母滤到剩下<code>"aeiou"</code>，然后再用<code>length</code>计算长度。</p><pre class="code">ghci> lengthCompare "zen" "anna"  
LT  
ghci> lengthCompare "zen" "ana"  
LT  
ghci> lengthCompare "zen" "ann"  
GT</pre><p>在第一个例子中我们看到长度不同所以回传<code>LT</code>，明显地<code>"zen"</code>要短于<code>"anna"</code>。在第二个例子中，长度是一样的，但第二个字串有比较多的元音，所以结果仍然是<code>LT</code>。在第三个范例中，两个长度都相等，他们也有相同个数的元音，经由字典顺序比较后得到<code>"zen"</code>比较大。</p><p><code>Ordering</code>的monoid允许我们用不同方式比较事物，并将这些顺序也定义了依重要度不同的一个顺序。</p><a name="Maybe the monoid"></a><h3>Maybe the monoid</h3><p>我们来看一下<code>Maybe a</code>是怎样有多种方式来表现成<code>Monoid</code>的，并且说明哪些是比较有用的。一种将<code>Maybe a</code>当作monoid的方式就是他的<code>a</code>也是一个monoid，而我们将<code>mappend</code>实做成使用包在<code>Just</code>里面的值对应的<code>mappend</code>。并且用<code>Nothing</code>当作identity。所以如果我<code>mappend</code>两个参数中有一个是<code>Nothing</code>。那结果就会是另一边的值。他的instance定义如下：</p><pre class="code">instance Monoid a => Monoid (Maybe a) where  
    mempty = Nothing  
    Nothing `mappend` m = m  
    m `mappend` Nothing = m  
    Just m1 `mappend` Just m2 = Just (m1 `mappend` m2)</pre><p>留意到class constraint。他说明<code>Maybe a</code>只有在<code>a</code>是<code>Monoid</code>的情况下才会是一个<code>Monoid</code>。如果我们<code>mappend</code>某个东西跟<code>Nothing</code>。那结果就会是某个东西。如果我们<code>mappend</code>两个<code>Just</code>，那<code>Just</code>包住的结果就会<code>mappended</code>在一起并放回<code>Just</code>。我们能这么做是因为class constraint保证了在<code>Just</code>中的值是<code>Monoid</code>。</p><pre class="code">ghci> Nothing `mappend` Just "andy"  
Just "andy"  
ghci> Just LT `mappend` Nothing  
Just LT  
ghci> Just (Sum 3) `mappend` Just (Sum 4)  
Just (Sum {getSum = 7})</pre><p>这当你在处理有可能失败的monoid的时候比较有用。有了这个instance，我们就不必一一去检查他们是否失败，是否是<code>Nothing</code>或是<code>Just</code>，我们可以直接将他们当作普通的monoid。</p><p>但如果在<code>Maybe</code>中的型别不是<code>Monoid</code>呢？注意到在先前的instance定义中，唯一有依赖于monoid限制的情况就是在<code>mappend</code>两个<code>Just</code>的时候。但如果我们不知道包在<code>Just</code>里面的值究竟是不是monoid，我们根本无法用<code>mappend</code>操作他们，所以该怎么办呢？一种方式就是直接丢掉第二个值而留下第一个值。这就是<code>First a</code>存在的目的，而这是他的定义：</p><pre class="code">newtype First a = First { getFirst :: Maybe a }  
    deriving (Eq, Ord, Read, Show)</pre><p>我们接受一个<code>Maybe a</code>并把他包成newtype，<code>Monoid</code>的定义如下：</p><pre class="code">instance Monoid (First a) where  
    mempty = First Nothing  
    First (Just x) `mappend` _ = First (Just x)  
    First Nothing `mappend` x = x</pre><p>正如我们说过得，<code>mempty</code>就是包在<code>First</code>中的<code>Nothing</code>。如果<code>mappend</code>的第一个参数是<code>Just</code>，我们就直接忽略第二个参数。如果第一个参数是<code>Nothing</code>，那我们就将第二个参数当作结果。并不管他究竟是<code>Just</code>或是<code>Nothing</code>：</p><pre class="code">ghci> getFirst $ First (Just 'a') `mappend` First (Just 'b')  
Just 'a'  
ghci> getFirst $ First Nothing `mappend` First (Just 'b')  
Just 'b'  
ghci> getFirst $ First (Just 'a') `mappend` First Nothing  
Just 'a'</pre><p><code>First</code>在我们有一大串<code>Maybe</code>而且想知道他们之中就竟有没有<code>Just</code>的时候很有用。可以利用<code>mconcat</code>：</p><pre class="code">ghci> getFirst . mconcat . map First $ [Nothing, Just 9, Just 10]  
Just 9</pre><p>如果我们希望定义一个<code>Maybe a</code>的monoid，让他当<code>mappend</code>的两个参数都是<code>Just</code>的时候将第二个参数当作结果。<code>Data.Monoid</code>中有一个现成的<code>Last a</code>，他很像是<code>First a</code>，只差在<code>mappend</code>跟<code>mconcat</code>会保留最后一个非<code>Nothing</code>的值。</p><pre class="code">ghci> getLast . mconcat . map Last $ [Nothing, Just 9, Just 10]  
Just 10  
ghci> getLast $ Last (Just "one") `mappend` Last (Just "two")  
Just "two"</pre><a name="Using monoids to fold data structures"></a><h3>Using monoids to fold data structures</h3><p>另一种有趣的monoid使用方式就是让他来帮助我们fold一些数据结构。到目前为止我们只有fold list。但list并不是唯一一种可以fold的数据结构。我们几乎可以fold任何一种数据结构。像是tree也是一种常见的可以fold的数据结构。</p><p>由于有太多种数据结构可以fold了，所以我们定义了<code>Foldable</code>这个typeclass。就像<code>Functor</code>是定义可以map over的结构。<code>Foldable</code>是定义可以fold的结构。在<code>Data.Foldable</code>中有定义了一些有用的函数，但他们名称跟<code>Prelude</code>中的名称冲突。所以最好是用qualified的方式import他们：</p><pre class="code">import qualified Foldable as F</pre><p>为了少打一些字，我们将他们import qualified成<code>F</code>。所以这个typeclass中定义了哪些函数呢？有<code>foldr</code>，<code>foldl</code>，<code>foldr1</code>跟<code>foldl1</code>。你会说我们已经知道这些函数了，他们有什么不一样的地方吗？我们来比较一下<code>Foldable</code>中的<code>foldr</code>跟<code>Prelude</code>中的<code>foldr</code>的型别异同：</p><pre class="code">ghci> :t foldr  
foldr :: (a -> b -> b) -> b -> [a] -> b  
ghci> :t F.foldr  
F.foldr :: (F.Foldable t) => (a -> b -> b) -> b -> t a -> b</pre><p>尽管<code>foldr</code>接受一个list并将他fold起来，<code>Data.Foldable</code>中的<code>foldr</code>接受任何可以fold的型别。并不只是list。</p><p>而两个<code>foldr</code>对于list的结果是相同的：</p><pre class="code">ghci> foldr (*) 1 [1,2,3]  
6  
ghci> F.foldr (*) 1 [1,2,3]  
6</pre><p>那有哪些数据结构支持fold呢？首先我们有<code>Maybe</code>：</p><pre class="code">ghci> F.foldl (+) 2 (Just 9)  
11  
ghci> F.foldr (||) False (Just True)  
True</pre><p>但fold一个<code>Maybe</code>并没什么新意。毕竟当他是<code>Just</code>的时候表现得像是只有单一元素的list，而当他是<code>Nothing</code>的时候就像是空的list一样。所以我们来看一些比较复杂的数据结构。</p><p>还记得Making Our Own Types and Typeclass章节中的树状的数据结构吗？我们是这样定义的：</p><pre class="code">data Tree a = Empty | Node a (Tree a) (Tree a) deriving (Show, Read, Eq)</pre><p>我们说一棵树要不就是一棵空的树要不然就是一个包含值的节点，并且还指向另外两棵树。定义他之后，我们将他定义成<code>Functor</code>的instance，因此可以<code>fmap</code>他。现在我们要将他定义成<code>Foldable</code>的instance，这样我们就可以fold他。要定义成<code>Foldable</code>的一种方式就是实做<code>foldr</code>。但另一种比较简单的方式就是实做<code>foldMap</code>，他也属于<code>Foldable</code>typeclass。<code>foldMap</code>的型别如下：</p><pre class="code">foldMap :: (Monoid m, Foldable t) => (a -> m) -> t a -> m</pre><p>第一个参数是一个函数，这个函数接受foldable数据结构中包含的元素的型别，并回传一个monoid。他第二个参数是一个foldable的结构，并包含型别<code>a</code>的元素。他将第一个函数来map over这个foldable的结构，因此得到一个包含monoid的foldable结构。然后用<code>mappend</code>来简化这些monoid，最后得到单一的一个monoid。这个函数听起来不太容易理解，但我们下面会看到他其实很容易实做。而且好消息是只要实做了这个函数就可以让我们的函数成为<code>Foldable</code>。所以我们只要实做某个型别的<code>foldMap</code>，我们就可以得到那个型别的<code>foldr</code>跟<code>foldl</code>。</p><p>这就是我们如何定义<code>Tree</code>成为<code>Foldable</code>的：</p><pre class="code">instance F.Foldable Tree where  
    foldMap f Empty = mempty  
    foldMap f (Node x l r) = F.foldMap f l `mappend`  
                                f x           `mappend`  
                                F.foldMap f r</pre><img src="/img/accordion.png" style="float:right"></img><p>我们是这样思考的：如果我们写一个函数，他接受树中的一个元素并回传一个monoid，那我们要怎么简化整棵树到只有单一一个monoid？当我们在对树做<code>fmap</code>的时候，我们将那函数套用至节点上，并递归地套用至左子树以及右子树。这边我们不只是map一个函数而已，我们还要求要把结果用<code>mappend</code>简化成只有单一一个monoid值。首先我们考虑树为空的情形，一棵没有值也没有子树的情形。由于没有值我们也没办法将他套用上面转换成monoid的函数，所以当树为空的时候，结果应该要是<code>mempty</code>。</p><p>在非空节点的情形下比较有趣，他包含一个值跟两棵子树。在这种情况下，我们递归地做<code>foldMap</code>，用<code>f</code>来套用到左子树跟右子树上。药剂祝我们的<code>foldMap</code>只会得到单一的monoid值。我们也会套用<code>f</code>到节点中的值。这样我们就得到三个monoid值，有两个来自简化子树的结果，还有一个是套用<code>f</code>到节点中的值的结果。而我们需要将这三个值集成成单一个值。要达成这个目的我们使用<code>mappend</code>，而且自然地会想到照左子树，节点值以及右子树的顺序来简化。</p><p>注意到我们并不一定要提供一个将普通值转成monoid的函数。我们只是把他当作是<code>foldMap</code>的参数，我们要决定的只是如何套用那个函数，来把得到的monoid们简化成单一结果。</p><p>现在我们有树的<code>Foldable</code>instance，而<code>foldr</code>跟<code>foldl</code>也有缺省的实做了。考虑下面这棵树：</p><pre class="code">testTree = Node 5  
            (Node 3  
             (Node 1 Empty Empty)  
             (Node 6 Empty Empty)  
            )  
            (Node 9  
             (Node 8 Empty Empty)  
             (Node 10 Empty Empty)  
            )</pre><p>他的root是<code>5</code>，而他左边下来分别是<code>3</code>，再来是<code>1</code>跟<code>6</code>。而右边下来是<code>9</code>，再来是<code>8</code>跟<code>10</code>。有了<code>Foldable</code>的定义，我们就能像对list做fold一样对树做fold：</p><pre class="code">ghci> F.foldl (+) 0 testTree  
42  
ghci> F.foldl (*) 1 testTree  
64800</pre><p><code>foldMap</code>不只是定义<code>Foldable</code>新的instance有用。他也对简化我们的结构至单一monoid值有用。举例来说，如果我们想要知道我们的树中有没有<code>3</code>，我们可以这样做：</p><pre class="code">ghci> getAny $ F.foldMap (\x -> Any $ x == 3) testTree  
True</pre><p>这边<code>\x -> Any $ x == 3</code>是一个接受一个数值并回传一个monoid的函数，也就是一个包在<code>Any</code>中的<code>Bool</code>。<code>foldMap</code>将这个函数套用至树的每一个节点，并把结果用<code>mappend</code>简化成单一monoid。如果我们这样做：</p><pre class="code">ghci> getAny $ F.foldMap (\x -> Any $ x > 15) testTree  
False</pre><p>经过套用lambda之后我们所有的节点都会是<code>Any False</code>。但<code>mappend</code>必须要至少吃到一个<code>True</code>才能让最后的结果变成<code>True</code>。这也是为什么结果会是<code>False</code>，因为我们树中所有的值都大于<code>15</code>。</p><p>我们也能将<code>foldMap</code>配合<code>\x -> [x]</code>使用来将我们的树转成list。经过套用那个函数后，所有节点都变成包含单一元素的list。最后用<code>mappend</code>将这些单一元素的list转成一个装有全部元素的list：</p><pre class="code">ghci> F.foldMap (\x -> [x]) testTree  
[1,3,6,5,8,9,10]</pre><p>这个小技巧并不限于树而已，他可以被套用在任何<code>Foldable</code>上。</p>
            <ul class="nav">
                <li class="left">  <img src="/img/prv.png"></img><a href="functionally-solving-problems.html">函数式地思考来解决问题</a></li>
                <li class="center"><a href="chapters.html">Index</a></li>
                <li class="right"> <a href="a-fistful-of-monads.html">来看看几种Monad</a><img src="/img/nxt.png"></img></li>
            </ul>
        </div>
        <div id="footer">
        </div>
        <div id="feedback">Send feedback</div>
    </body>
</html>
