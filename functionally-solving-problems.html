<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
        <style>
            @import url(css/style.css);
            @import url(css/feedback.css);
        </style>
        <script src="js/jquery.js"></script>
        <script src="js/jquery.chili-2.2.js"></script>
        <script src="js/script.js"></script>
        <script src="js/html2canvas.js"></script>
        <script src="js/jsfeedback.js"></script>
        <script>
             ChiliBook.recipeFolder = "js/chili/";  
             ChiliBook.automaticSelector = "pre";
        </script>
        <script>
            $(function(){
                $('#feedback').click(function(){
                    $('body').feedback();
                })
            });
        </script>
        <script type="text/javascript">
            var _gaq = _gaq || [];
            _gaq.push(['_setAccount', 'UA-32830659-1']);
            _gaq.push(['_trackPageview']);

            (function() {
                var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
                ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
                    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
            })();
        </script>
        <title>函數式地思考來解決問題</title>
    </head>
    <body>
        <div id="header">
            <img id="beta" alt="beta" src="img/beta.png" />
        </div>

        <div id="main">
            <ul class="nav">
                <li class="left">  <img src="img/prv.png"></img><a href="input-and-output.html">輸入與輸出</a></li>
                <li class="center"><a href="chapters.html">Index</a></li>
                <li class="right"> <a href="functors-applicative-functors-and-monoids.html">Functors, Applicative Functors與Monoids</a><img src="img/nxt.png"></img></li>
            </ul>
            <a name="函數式地思考來解決問題"></a><h1>函數式地思考來解決問題</h1><p>在這一章中，我們會檢視幾個有趣的問題，並嘗試用函數式的方式來漂亮地解決他們。我們並不會介紹新的概念，我們只是練習我們剛學到的寫程式的技巧。每一節都會探討不同的問題。會先描述問題，然後用最好的方式解決他。</p><a name="運算逆波蘭表示法(Reverse Polish notation form)"></a><h2>運算逆波蘭表示法(Reverse Polish notation form)</h2><p>我們在學校學習數學的時候，我們多半都是用中置(infix)的方式來寫數學式。例如說，我們會寫<code>10 - (4 + 3) * 2</code>。<code>+</code>,<code>*</code>,<code>-</code>是中置運算子(infix operators)。在Haskell中就像是<code>+</code>或<code>elem</code>一樣。這種寫法對於人類來說很容易閱讀與理解，但缺點是我們必須用括號來描述運算的優先順序。</p><p>逆波蘭表示法是另外一種數學式的描述方法。乍看之下顯得怪異，但他其實很容易理解並使用。因為我們不需要括弧來描述，也很容易放進計算機裡面運算。儘管現在的計算機都是用中置的方式讓你輸入，有些人仍堅持用RPN的計算機。前述的算式如果表達成RPN的話會是<code>10 4 3 + 2 * -</code>。我們要如何計算他的結果呢？可以想想堆疊，基本上你是從左向右閱讀算式。每當碰到一個數值，就把他堆上堆疊。當我們碰到一個運算子。就把兩個數值從堆疊上拿下來，用運算子運算兩個數值然後把結果推回堆疊中。當你消耗完整個算式的時候，而且假設你的算式是合法的，那你就應該只剩一個數值在堆疊中，</p><img src="img/rpn.png" style="float:left"></img><p>我們再接著看<code>10 4 3 + 2 * -</code>。首先我們把<code>10</code>推到堆疊上，所以堆疊現在是<code>10</code>。下一個接著的輸入是<code>4</code>，我們也把他推上堆疊。堆疊的狀態便變成<code>10, 4</code>。接著也對下一個輸入<code>3</code>做同樣的事，所以堆疊變成<code>10, 4, 3</code>。然後便碰到了第一個運算子<code>+</code>。我們把堆疊最上層的兩個數值取下來（所以堆疊變成<code>10</code>）把兩個數值加起來然後推回堆疊上。堆疊的狀態便變成<code>10, 7</code>。我們再把輸入<code>2</code>推上堆疊，堆疊變成<code>10, 7, 2</code>。我們又碰到另一個運算子，所以把<code>7</code>跟<code>2</code>取下，把他們相乘起來然後推回堆疊上。<code>7</code>跟<code>2</code>相乘的結果是<code>14</code>，所以堆疊的狀態是<code>10, 14</code>。最後我們碰到了<code>-</code>。我們把<code>10</code>跟<code>14</code>取下，將他們相減然後推回堆疊上。所以現在堆疊的狀態變成<code>-4</code>。而我們已經把所有數值跟運算子的消耗完了，所以<code>-4</code>便是我們的結果。</p><p>現在我們知道我們如何手算RPN運算式了，接下來可以思考一下我們寫一個Haskell的函數，當他接到一個RPN運算式，像是<code>"10 4 3 + 2 * -"</code>時，他可以給出結果。</p><p>這個函數的型別會是什麼樣呢？我們希望他接受一個字串當作參數，並產出一個數值作為結果。所以應該會是<code>solveRPN :: (Num a) => String -> a</code>。</p><blockquote><p>小建議：在你去實作函數之前，先想一下你會怎麼宣告這個函數的型別能夠幫助你釐清問題。在Haskell中由於我們有夠強的型別系統，光從函數的宣告就可以得到許多資訊。</p></blockquote><img src="img/calculator.png" style="float:left"></img><p>當我們要實作一個問題的解法時，你可以先動手一步一步解看看，嘗試從裡面得到一些靈感。我們這邊把每一個用空白隔開的數值或運算子都當作獨立的一項。所以把<code>"10 4 3 + 2 * -"</code>這樣一個字串斷成一串list<code>["10","4","3","+","2","*","-"]</code>應該會有幫助。</p><p>接下來我們要如何應用這個斷好的list呢？我們從左至右來走一遍，並保存一個工作用的堆疊。這樣有讓你想到些什麼可以用的嗎？沒錯，在<code>folds</code>的那一章裡面，我們提到基本上當你需要從左至右或由右至左走過一遍list的時候並產生些結果的時候。我們都能用fold來實作他。</p><p>在這個case中由於我們是從左邊走到右邊，所以我們採取left fold。accumulator則是選用堆疊，而fold的結果也會是一個堆疊，只是裡面只有一個元素而已。</p><p>另外要多考慮一件事是我們用什麼來代表我們的堆疊？我們可以用list來代替，list的head就可以當作是堆疊的頂端。畢竟要把一個元素加到list的head要比加到最後要有效率多。所以如果我們有一個堆疊，裡面有<code>10, 4, 3</code>，那我們可以用<code>[3,4,10]</code>來代表他。</p><p>現在我們有了足夠的資訊來寫出我們的函數。他會接受一個字串<code>"10 4 3 + 2 * -"</code>，隨即用<code>words</code>來斷成list<code>["10","4","3","+","2","*","-"]</code>。接下來我們做一個left fold來產生出只有一個元素的堆疊，也就是<code>[-4]</code>。我們把這個元素從list取出便是最後的結果。</p><p>來看看我們的實作：</p><pre class="code">import Data.List  
  
solveRPN :: (Num a) => String -> a  
solveRPN expression = head (foldl foldingFunction [] (words expression))  
    where   foldingFunction stack item = ...</pre><p>我們接受一個運算式並把他斷成一串List。然後我們用一個folding函數來fold這串list。注意到我們用<code>[]</code>來當作起始的accumulator。這個accumulator就是我們的堆疊，所以<code>[]</code>代表一個空的堆疊。在運算之後我們得到一個只有一個元素的堆疊，我們呼叫<code>head</code>來取出他並用<code>read</code>來轉換他。</p><p>所以我們現在只缺一個接受堆疊的folding函數，像是可以接受<code>[4,10]</code>跟<code>"3"</code>，然後得到<code>[3,4,10]</code>。如果是<code>[4,10]</code>跟<code>"*"</code>，那就會得到<code>[40]</code>。但在實作之前，我們先把我們的函數改寫成point-free style，這樣可以省下許多括號。</p><pre class="code">import Data.List  
  
solveRPN :: (Num a) => String -> a  
solveRPN = head . foldl foldingFunction [] . words  
      where   foldingFunction stack item = ...</pre><p>看起來好多了。我們的folding函數會接受一個堆疊、新的項，並回傳一個新的堆疊。我們使用模式匹配的方式來取出堆疊最上層的元素，然後對<code>"*"</code>跟<code>"-"</code>做匹配。</p><pre class="code">solveRPN :: (Num a, Read a) => String -> a  
solveRPN = head . foldl foldingFunction [] . words  
    where   foldingFunction (x:y:ys) "*" = (x * y):ys  
            foldingFunction (x:y:ys) "+" = (x + y):ys  
            foldingFunction (x:y:ys) "-" = (y - x):ys  
            foldingFunction xs numberString = read numberString:xs</pre><pre class="code">ghci> solveRPN "10 4 3 + 2 * -"  
-4  
ghci> solveRPN "2 3 +"  
5  
ghci> solveRPN "90 34 12 33 55 66 + * - +"  
-3947  
ghci> solveRPN "90 34 12 33 55 66 + * - + -"  
4037  
ghci> solveRPN "90 34 12 33 55 66 + * - + -"  
4037  
ghci> solveRPN "90 3 -"  
87</pre><pre class="code">import Data.List  
  
solveRPN :: String -> Float  
solveRPN = head . foldl foldingFunction [] . words  
where   foldingFunction (x:y:ys) "*" = (x * y):ys  
        foldingFunction (x:y:ys) "+" = (x + y):ys  
        foldingFunction (x:y:ys) "-" = (y - x):ys  
        foldingFunction (x:y:ys) "/" = (y / x):ys  
        foldingFunction (x:y:ys) "^" = (y ** x):ys  
        foldingFunction (x:xs) "ln" = log x:xs  
        foldingFunction xs "sum" = [sum xs]  
        foldingFunction xs numberString = read numberString:xs</pre><pre class="code">ghci> solveRPN "2.7 ln"  
0.9932518  
ghci> solveRPN "10 10 10 10 sum 4 /"  
10.0  
ghci> solveRPN "10 10 10 10 10 sum 4 /"  
12.5  
ghci> solveRPN "10 2 ^"  
100.0</pre><pre class="code">ghci> solveRPN "43.2425 0.5 ^"  
6.575903</pre><a name="路徑規劃"></a><h2>路徑規劃</h2><img src="img/roads.png" style="float:left"></img><pre class="code">50  
10  
30  
5  
90  
20  
40  
2  
25  
10  
8  
0</pre><pre class="code">data Node = Node Road Road | EndNode Road  
data Road = Road Int Node</pre><pre class="code">data Node = Node Road (Maybe Road)  
data Road = Road Int Node</pre><pre class="code">data Section = Section { getA :: Int, getB :: Int, getC :: Int } deriving (Show)  
type RoadSystem = [Section]</pre><pre class="code">heathrowToLondon :: RoadSystem  
heathrowToLondon = [Section 50 10 30, Section 5 90 20, Section 40 2 25, Section 10 8 0]</pre><pre class="code">data Label = A | B | C deriving (Show)  
type Path = [(Label, Int)]</pre><pre class="code">[(B,10),(C,30),(A,5),(C,20),(B,2),(B,8)]</pre><pre class="code">roadStep :: (Path, Path) -> Section -> (Path, Path)  
roadStep (pathA, pathB) (Section a b c) =   
    let priceA = sum $ map snd pathA  
        priceB = sum $ map snd pathB  
        forwardPriceToA = priceA + a  
        crossPriceToA = priceB + b + c  
        forwardPriceToB = priceB + b  
        crossPriceToB = priceA + a + c  
        newPathToA = if forwardPriceToA <= crossPriceToA  
                        then (A,a):pathA  
                        else (C,c):(B,b):pathB  
        newPathToB = if forwardPriceToB <= crossPriceToB  
                        then (B,b):pathB  
                        else (C,c):(A,a):pathA  
    in  (newPathToA, newPathToB)</pre><pre class="code">ghci> roadStep ([], []) (head heathrowToLondon)  
([(C,30),(B,10)],[(B,10)])</pre><pre class="code">optimalPath :: RoadSystem -> Path  
optimalPath roadSystem = 
    let (bestAPath, bestBPath) = foldl roadStep ([],[]) roadSystem  
    in  if sum (map snd bestAPath) <= sum (map snd bestBPath)  
                then reverse bestAPath  
                else reverse bestBPath</pre><pre class="code">ghci> optimalPath heathrowToLondon  
[(B,10),(C,30),(A,5),(C,20),(B,2),(B,8),(C,0)]</pre><pre class="code">groupsOf :: Int -> [a] -> [[a]]  
groupsOf 0 _ = undefined  
groupsOf _ [] = []  
groupsOf n xs = take n xs : groupsOf n (drop n xs)</pre><pre class="code">import Data.List  
  
main = do  
    contents <- getContents  
    let threes = groupsOf 3 (map read $ lines contents)  
        roadSystem = map (\[a,b,c] -> Section a b c) threes  
        path = optimalPath roadSystem  
        pathString = concat $ map (show . fst) path  
        pathPrice = sum $ map snd path  
    putStrLn $ "The best path to take is: " ++ pathString  
    putStrLn $ "The price is: " ++ show pathPrice</pre><pre class="code">50  
10  
30  
5  
90  
20  
40  
2  
25  
10  
8  
0</pre><pre class="code">$ cat paths.txt | runhaskell heathrow.hs  
The best path to take is: BCACBBC  
The price is: 75</pre>
            <ul class="nav">
                <li class="left">  <img src="img/prv.png"></img><a href="input-and-output.html">輸入與輸出</a></li>
                <li class="center"><a href="chapters.html">Index</a></li>
                <li class="right"> <a href="functors-applicative-functors-and-monoids.html">Functors, Applicative Functors與Monoids</a><img src="img/nxt.png"></img></li>
            </ul>
        </div>
        <div id="footer">
        </div>
        <div id="feedback">Send feedback</div>
    </body>
</html>
