<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
        <style>
            @import url(css/style.css);
            @import url(css/feedback.css);
        </style>
        <script src="js/jquery.js"></script>
        <script src="js/jquery.chili-2.2.js"></script>
        <script src="js/script.js"></script>
        <script src="js/html2canvas.js"></script>
        <script src="js/jsfeedback.js"></script>
        <script>
             ChiliBook.recipeFolder = "js/chili/";  
             ChiliBook.automaticSelector = "pre";
        </script>
        <script>
            $(function(){
                $('#feedback').click(function(){
                    $('body').feedback();
                })
            });
        </script>
        <script type="text/javascript">
            var _gaq = _gaq || [];
            _gaq.push(['_setAccount', 'UA-32830659-1']);
            _gaq.push(['_trackPageview']);

            (function() {
                var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
                ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
                    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
            })();
        </script>
        <title>Zippers資料結構</title>
    </head>
    <body>
        <div id="header">
            <img id="beta" alt="beta" src="img/beta.png" />
        </div>

        <div id="main">
            <ul class="nav">
                <li class="left">  <img src="img/prv.png"></img><a href="for-a-few-monads-more.html">再來看看更多Monad</a></li>
                <li class="center"><a href="chapters.html">Index</a></li>
                <li class="right"></li>
            </ul>
            <a name="Zippers資料結構"></a><h1>Zippers資料結構</h1><img src="img/60sdude.png" style="float:right"></img><p>儘管Haskell的純粹性質帶來很多好處，但他讓一些在非純粹語言很容易處理的一些事情變得要用另一種方法解決。由於referential transparency，同樣一件事在Haskell中是沒有分別的。</p><p>所以如果我們有一個裝滿5的樹，而我們希望把其中一個換成6，那我們必須要知道我們究竟是想改變哪個5。我們也必須知道我們身處在這棵樹的哪裡。但在Haskell中，每個5都長得一樣，我們並不能因為他們在記憶體中的位址不同就把他們區分開來。我們也不能改變任何狀態，當我們想要改變一棵樹的時候，我們實際上是說我們要一棵新的樹，只是他長得很像舊的。</p><p>一種解決方式是記住一條從根節點到現在這個節點的路徑。我們可以這樣表達：給定一棵樹，先往左走，再往右走，再往左走，然後改變你走到的元素。雖然這是可行的，但這非常沒有效率。如果我們想接連改變一個在附近的節點，我們必須再從根節點走一次。</p><p>在這個章節中，我們會看到我們可以集中注意在某個資料結構上，這樣讓改變資料結構跟遍歷的動作非常有效率。</p><a name="來走二元樹吧!"></a><h2>來走二元樹吧!</h2><p>我們在生物課中學過，樹有非常多種。所以我們來自己發明棵樹吧！</p><pre class="code">data Tree a = Empty | Node a (Tree a) (Tree a) deriving (Show)</pre><p>這邊我們的樹不是空的就是有兩棵子樹。來看看一個範例：</p><pre class="code">freeTree :: Tree Char  
freeTree =   
    Node 'P'  
        (Node 'O'  
             (Node 'L'  
              (Node 'N' Empty Empty)  
              (Node 'T' Empty Empty)  
             )  
             (Node 'Y'  
              (Node 'S' Empty Empty)  
              (Node 'A' Empty Empty)  
             )  
        )  
        (Node 'L'  
             (Node 'W'  
                  (Node 'C' Empty Empty)  
                  (Node 'R' Empty Empty)  
             )  
             (Node 'A'  
                  (Node 'A' Empty Empty)  
                  (Node 'C' Empty Empty)  
             )  
        )</pre><p>畫成圖的話就是像這樣：</p><img src="img/pollywantsa.png" style="float:right"></img><p>注意到<code>W</code>這個節點了嗎？</p><p>如果我們想要把他變成<code>P</code>。我們會怎麼做呢？</p><p>一種方式是用pattern match的方式做，直到我們找到那個節點為止。</p><p>要先往右走再往左走，再改變元素內容，像是這樣：</p><pre class="code">changeToP :: Tree Char -> Tree Char  
changeToP (Node x l (Node y (Node _ m n) r)) = Node x l (Node y (Node 'P' m n) r)</pre><p>這不只看起來很醜，而且很不容易閱讀。</p><p>這到底是怎麼回事？</p><p>我們使用pattern match來拆開我們的樹，</p><p>我們把root綁定成<code>x</code>，把左子樹綁定成<code>l</code>。</p><p>對於右子樹我們繼續使用pattern match。</p><p>直到我們碰到一個子樹他的root是<code>'W'</code>。</p><p>到此為止我們再重建整棵樹，</p><p>新的樹只差在把<code>'W'</code>改成了<code>'P'</code>。</p><p>有沒有比較好的作法呢？</p><p>有一種作法是我們寫一個函數，他接受一個樹跟一串list，裡面包含有行走整個樹時的方向。</p><p>方向可以是<code>L</code>或是<code>R</code>，分別代表向左走或向右走。</p><p>我們只要跟隨指令就可以走達指定的位置：</p><pre class="code">data Direction = L | R deriving (Show)  
type Directions = [Direction]  
  
changeToP :: Directions-> Tree Char -> Tree Char  
changeToP (L:ds) (Node x l r) = Node x (changeToP ds l) r  
changeToP (R:ds) (Node x l r) = Node x l (changeToP ds r)  
changeToP [] (Node _ l r) = Node 'P' l r</pre><p>如果在list中的第一個元素是<code>L</code>，我們會建構一個左子樹變成<code>'P'</code>的新樹。</p><p>當我們遞迴地呼叫<code>changeToP</code>，</p><p>我們只會傳給他剩下的部份，因為前面的部份已經看過了。</p><p>對於<code>R</code>的case也一樣。</p><p>如果list已經消耗完了，</p><p>那表示我們已經走到我們的目的地，</p><p>所以我們就回傳一個新的樹，他的root被修改成<code>'P'</code>。</p><p>要避免印出整棵樹，</p><p>我們要寫一個函數告訴我們目的地究竟是什麼元素。</p><pre class="code">elemAt :: Directions -> Tree a -> a  
elemAt (L:ds) (Node _ l _) = elemAt ds l  
elemAt (R:ds) (Node _ _ r) = elemAt ds r  
elemAt [] (Node x _ _) = x</pre><p>這函數跟<code>changeToP</code>很像，</p><p>只是他不會記下沿路上的資訊，</p><p>他只會記住目的地是什麼。</p><p>我們把<code>'W'</code>變成<code>'P'</code>，然後用他來查看。</p><pre class="code">ghci> let newTree = changeToP [R,L] freeTree  
ghci> elemAt [R,L] newTree  
'P'</pre><p>看起來運作正常。</p><p>在這些函數裡面，包含方向的list比較像是一種"focus"，</p><p>因為他特別指出了一棵子樹。</p><p>一個像<code>[R]</code>這樣的list是聚焦在root的右子樹。</p><p>一個空的list代表的是主樹本身。</p><p>這個技巧看起來酷炫，但卻不太有效率，特別是在我們想要重複地改變內容的時候。</p><p>假如我們有一個非常大的樹以及非常長的一串包含方向的list。</p><p>我們需要沿著方向從root一直走到樹的底部。</p><p>如果我們想要改變一個鄰近的元素，我們仍需要從root開始走到樹的底部。</p><p>這實在不太令人滿意。</p><p>在下一個章節，我們會介紹一個比較好的方法，讓我們可以有效率地改變我們的focus。</p><a name="凡走過必留下痕跡"></a><h2>凡走過必留下痕跡</h2><p>我們需要一個比包含一串方向的list更好的聚焦的方法。</p><p>如果我們能夠在從root走到指定地點的沿路上撒下些麵包屑，來紀錄我們的足跡呢？</p><p>當我們往左走，我們便記住我們選擇了左邊，當我們往右走，便記住我們選擇了右邊。</p><p>要找個東西來代表我們的麵包屑，就用一串<code>Direction</code>(他可以是<code>L</code>或者是<code>R</code>)，</p><p>只是我們叫他<code>BreadCrumb</code>而不叫<code>Direction</code>。</p><p>這是因為現在我們把這串direction反過來看了：</p><pre class="code">type Breadcrumbs = [Direction]</pre><p>這邊有一個函數，他接受一棵樹跟一些麵包屑，並在我們往左走時在list的前頭加上<code>L</code></p><pre class="code">goLeft :: (Tree a, Breadcrumbs) -> (Tree a, Breadcrumbs)
goLeft (Node _ l _, bs) = (l, L:bs)</pre><p>我們忽略root跟右子樹，直接回傳左子樹以及麵包屑，只是在現有的麵包屑前面加上<code>L</code>。</p><p>再來看看往右走的函數：</p><pre class="code">goRight :: (Tree a, Breadcrumbs) -> (Tree a, Breadcrumbs)  
goRight (Node _ _ r, bs) = (r, R:bs)</pre><p>幾乎是一模一樣。</p><p>我們再來做一個先往右走再往左走的函數，讓他來走我們的<code>freeTree</code></p><pre class="code">ghci> goLeft (goRight (freeTree, []))  
(Node 'W' (Node 'C' Empty Empty) (Node 'R' Empty Empty),[L,R])</pre><p>現在我們有了一棵樹，他的root是<code>'W'</code>，而他的左子樹的root是<code>'C'</code>，</p><p>右子樹的root是<code>'R'</code>。</p><p>而由於我們先往右走再往左走，所以麵包屑是<code>[L,R]</code>。</p><p>要再表示得更清楚些，我們能用定義一個<code>-:</code></p><pre class="code">x -: f = f x</pre><p>他讓我們可以將值餵給函數這件事反過來寫，</p><p>先寫值，再來是<code>-:</code>，最後是函數。</p><p>所以我們可以寫成<code>(freeTree, []) -: goRight</code>而不是<code>goRight (freeTree, [])</code>。</p><p>我們便可以把上面的例子改寫地更清楚。</p><pre class="code">ghci> (freeTree, []) -: goRight -: goLeft  
(Node 'W' (Node 'C' Empty Empty) (Node 'R' Empty Empty),[L,R])</pre><a name="Going back up"></a><h3>Going back up</h3><p>如果我們想要往回上走回我們原來的路徑呢？</p><p>根據留下的麵包屑，我們知道現在的樹是他父親的左子樹，而他的父親是祖父的右子樹。</p><p>這些資訊並不足夠我們往回走。</p><p>看起來要達到這件事情，我們除了單純紀錄方向之外，還必須把其他的資料都記錄下來。</p><p>在這個案例中，也就是他的父親以及他的右子樹。</p><p>一般來說，單單一個麵包屑有足夠的資訊讓我們重建父親的節點。</p><p>所以他應該要包含所有我們沒有選擇的路徑的資訊，並且他應該要紀錄我們沿路走的方向。</p><p>同時他不應該包含我們現在鎖定的子樹。</p><p>因為那棵子樹已經在tuple的第一個部份中，如果我們也把他紀錄在麵包屑裡，那就會有重複的資訊。</p><p>我們來修改一下我們麵包屑的定義，讓他包含我們之前丟掉的資訊。</p><p>我們定義一個新的型態，而不用<code>Direction</code>：</p><pre class="code">data Crumb a = LeftCrumb a (Tree a) | RightCrumb a (Tree a) deriving (Show)</pre><p>我們用<code>LeftCrumb</code>來包含我們沒有走的右子樹，而不僅僅只寫個<code>L</code>。</p><p>我們用<code>RightCrumb</code>來包含我們沒有走的左子樹，而不僅僅只寫個<code>R</code>。</p><p>這些麵包屑包含了所有重建樹所需要的資訊。</p><p>他們像是軟碟一樣存了許多我們的足跡，而不僅僅只是方向而已。</p><p>大致上可以把每個麵包屑想像成一個樹的節點，樹的節點有一個洞。</p><p>當我們往樹的更深層走，</p><p>麵包屑攜帶有我們所有走過得所有資訊，只除了目前我們鎖定的子樹。</p><p>他也必須紀錄洞在哪裡。</p><p>在<code>LeftCrumb</code>的案例中，我們知道我們是向左走，所以我們缺少的便是左子樹。</p><p>我們也要把<code>Breadcrumbs</code>的type synonym改掉：</p><pre class="code">type Breadcrumbs a = [Crumb a]</pre><p>接著我們修改<code>goLeft</code>跟<code>goRight</code>來紀錄一些我們沒走過的路徑的資訊。</p><p>不像我們之前選擇忽略他。<code>goLeft</code>像是這樣：</p><pre class="code">goLeft :: (Tree a, Breadcrumbs a) -> (Tree a, Breadcrumbs a)
goLeft (Node x l r, bs) = (l, LeftCrumb x r:bs)</pre><p>你可以看到跟之前版本的<code>goLeft</code>很像，不只是將<code>L</code>推到list的最前端，</p><p>我們還加入<code>LeftCrumb</code>來表示我們選擇向左走。</p><p>而且我們在<code>LeftCrumb</code>裡面塞有我們之前走的節點，以及我們選擇不走的右子樹的資訊。</p><p>要注意這個函數會假設我們鎖定的子樹並不是<code>Empty</code>。</p><p>一個空的樹並沒有任何子樹，</p><p>所以如果我們選擇在一個空的樹中向左走，</p><p>就會因為我們對<code>Node</code>做模式匹配而產生錯誤。</p><p>我們沒有處理<code>Empty</code>的情況。</p><p><code>goRight</code>也是類似：</p><pre class="code">goRight :: (Tree a, Breadcrumbs a) -> (Tree a, Breadcrumbs a)  
goRight (Node x l r, bs) = (r, RightCrumb x l:bs)</pre><p>在之前我們只能向左或向右走，</p><p>現在我們由於紀錄了關於父節點的資訊以及我們選擇不走的路的資訊，</p><p>而獲得向上走的能力。</p><p>來看看<code>goUp</code>函數：</p><pre class="code">goUp :: (Tree a, Breadcrumbs a) -> (Tree a, Breadcrumbs a)  
goUp (t, LeftCrumb x r:bs) = (Node x t r, bs)  
goUp (t, RightCrumb x l:bs) = (Node x l t, bs)</pre><p>我們鎖定了<code>t</code>這棵樹並檢查最新的<code>Crumb</code>。</p><p>如果他是<code>LeftCrumb</code>，那我們就建立一棵新的樹，其中<code>t</code>是他的左子樹</p><p>並用關於我們沒走過得右子樹的資訊來填寫其他<code>Node</code>的資訊。</p><p>由於我們使用了麵包屑的資訊來建立父子樹，所以新的list移除了我們的麵包屑。</p><p>如果我們已經在樹的頂端並使用這個函數的話，他會引發錯誤。</p><p>等一會我們會用<code>Maybe</code>來表達可能失敗的情況。</p><p>有了<code>Tree a</code>跟<code>Breadcrumbs a</code>，我們就有足夠的資訊來重建整棵樹，並且鎖定其中一棵子樹。</p><p>這種方式讓我們可以輕鬆的往上，往左，往右走。</p><p>這樣成對的資料結構我們叫做Zipper，</p><p>因為當我們改變鎖定的時候，他表現得很像是拉鍊一樣。</p><p>所以我們便定義一個type synonym:</p><pre class="code">type Zipper a = (Tree a, Breadcrumbs a)</pre><p>我個人是比較傾向於命名成<code>Focus</code>，這樣可以清楚強調我們是鎖定在其中一部分，</p><p>至於Zipper被更廣泛地使用，所以這邊仍維持叫他做<code>Zipper</code>。</p><a name="Manipulating trees under focus"></a><h3>Manipulating trees under focus</h3><p>現在我們具備了移動的能力，我們再來寫一個改變元素的函數，他能改變我們目前鎖定的子樹的root。</p><pre class="code">modify :: (a -> a) -> Zipper a -> Zipper a  
modify f (Node x l r, bs) = (Node (f x) l r, bs)  
modify f (Empty, bs) = (Empty, bs)</pre><p>如果我們鎖定一個節點，我們用<code>f</code>改變他的root。</p><p>如果我們鎖定一棵空的樹，那就什麼也不做。</p><p>我們可以移來移去並走到我們想要改變的節點，</p><p>改變元素後並鎖定在那個節點，之後我們可以很方便的移上移下。</p><pre class="code">ghci> let newFocus = modify (\_ -> 'P') (goRight (goLeft (freeTree,[])))</pre><p>我們往左走，然後往右走並將root取代為<code>'P'</code>，用<code>-:</code>來表達的話就是：</p><pre class="code">ghci> let newFocus = (freeTree,[]) -: goLeft -: goRight -: modify (\_ -> 'P')</pre><p>我們也能往上走並置換節點為<code>'X'</code>：</p><pre class="code">ghci> let newFocus2 = modify (\_ -> 'X') (goUp newFocus)</pre><p>如果我們用<code>-:</code>表達的話：</p><pre class="code">ghci> let newFocus2 = newFocus -: goUp -: modify (\_ -> 'X')</pre><p>往上走很簡單，畢竟麵包屑中含有我們沒走過的路徑的資訊，只是裡面的資訊是相反的，這有點像是要把襪子反過來才能用一樣。</p><p>有了這些資訊，我們就不用再從root開始走一遍，我們只要把反過來的樹翻過來就好，然後鎖定他。</p><p>每個節點有兩棵子樹，即使子樹是空的也是視作有樹。</p><p>所以如果我們鎖定的是一棵空的子樹我們可以做的事就是把他變成非空的，也就是葉節點。</p><pre class="code">attach :: Tree a -> Zipper a -> Zipper a  
attach t (_, bs) = (t, bs)</pre><a name="I'm going straight to top, oh yeah, up where the air is fresh and clean!"></a><h3>I'm going straight to top, oh yeah, up where the air is fresh and clean!</h3><a name="來看串列"></a><h2>來看串列</h2><a name="陽春的檔案系統"></a><h2>陽春的檔案系統</h2><a name="小心每一步"></a><h2>小心每一步</h2>
            <ul class="nav">
                <li class="left">  <img src="img/prv.png"></img><a href="for-a-few-monads-more.html">再來看看更多Monad</a></li>
                <li class="center"><a href="chapters.html">Index</a></li>
                <li class="right"></li>
            </ul>
        </div>
        <div id="footer">
        </div>
        <div id="feedback">Send feedback</div>
    </body>
</html>
